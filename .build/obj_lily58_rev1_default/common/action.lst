   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB15:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode) { return false; }
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  55:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  58:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  59:tmk_core/common/action.c **** #endif
  60:tmk_core/common/action.c **** /** \brief Called to execute an action.
  61:tmk_core/common/action.c ****  *
  62:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  63:tmk_core/common/action.c ****  */
  64:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 64 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  65:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 65 5 view .LVU1
  66:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:tmk_core/common/action.c ****         dprint("EVENT: ");
  68:tmk_core/common/action.c ****         debug_event(event);
  69:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 69 19 view .LVU2
  70:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  71:tmk_core/common/action.c ****         retro_tapping_counter++;
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c **** 
  75:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  76:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  77:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  78:tmk_core/common/action.c ****     }
  79:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  80:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c ****     fauxclicky_check();
  83:tmk_core/common/action.c **** #endif
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  86:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  87:tmk_core/common/action.c ****         process_hand_swap(&event);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 91 5 view .LVU3
  51               		.loc 1 91 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  94:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  95:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  96:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  99:tmk_core/common/action.c ****         clear_oneshot_mods();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #    endif
 102:tmk_core/common/action.c **** #endif
 103:tmk_core/common/action.c **** 
 104:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 105:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 105 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 105 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 105 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 106:tmk_core/common/action.c **** #else
 107:tmk_core/common/action.c ****     process_record(&record);
 108:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 109:tmk_core/common/action.c ****         dprint("processed: ");
 110:tmk_core/common/action.c ****         debug_record(record);
 111:tmk_core/common/action.c ****         dprintln();
 112:tmk_core/common/action.c ****     }
 113:tmk_core/common/action.c **** #endif
 114:tmk_core/common/action.c **** }
  76               		.loc 1 114 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
 105:tmk_core/common/action.c **** #else
  85               		.loc 1 105 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE15:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB17:
 115:tmk_core/common/action.c **** 
 116:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 117:tmk_core/common/action.c **** bool swap_hands = false;
 118:tmk_core/common/action.c **** bool swap_held  = false;
 119:tmk_core/common/action.c **** 
 120:tmk_core/common/action.c **** /** \brief Process Hand Swap
 121:tmk_core/common/action.c ****  *
 122:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 123:tmk_core/common/action.c ****  */
 124:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 125:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 126:tmk_core/common/action.c **** 
 127:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 128:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 129:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c ****     if (do_swap) {
 132:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 133:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 134:tmk_core/common/action.c ****     } else {
 135:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 136:tmk_core/common/action.c ****     }
 137:tmk_core/common/action.c **** }
 138:tmk_core/common/action.c **** #endif
 139:tmk_core/common/action.c **** 
 140:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 141:tmk_core/common/action.c **** bool disable_action_cache = false;
 142:tmk_core/common/action.c **** 
 143:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 144:tmk_core/common/action.c ****     disable_action_cache = true;
 145:tmk_core/common/action.c ****     process_record(record);
 146:tmk_core/common/action.c ****     disable_action_cache = false;
 147:tmk_core/common/action.c **** }
 148:tmk_core/common/action.c **** #else
 149:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 150:tmk_core/common/action.c **** #endif
 151:tmk_core/common/action.c **** 
 152:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 152 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 152 74 view .LVU11
 104               		.loc 1 152 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 152 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE17:
 113               		.section	.text.post_process_record_quantum,"ax",@progbits
 114               		.weak	post_process_record_quantum
 116               	post_process_record_quantum:
 117               	.LVL6:
 118               	.LFB18:
 153:tmk_core/common/action.c **** 
 154:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 119               		.loc 1 154 77 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 125               		.loc 1 154 78 view .LVU15
 126               	/* epilogue start */
 127               		.loc 1 154 1 is_stmt 0 view .LVU16
 128 0000 0895      		ret
 129               		.cfi_endproc
 130               	.LFE18:
 132               		.section	.text.process_record_tap_hint,"ax",@progbits
 133               	.global	process_record_tap_hint
 135               	process_record_tap_hint:
 136               	.LVL7:
 137               	.LFB19:
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 157:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 158:tmk_core/common/action.c ****  *
 159:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 160:tmk_core/common/action.c ****  */
 161:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 138               		.loc 1 161 51 is_stmt 1 view -0
 139               		.cfi_startproc
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 162:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 144               		.loc 1 162 5 view .LVU18
 145               		.loc 1 162 23 is_stmt 0 view .LVU19
 146 0000 FC01      		movw r30,r24
 147 0002 8081      		ld r24,Z
 148 0004 9181      		ldd r25,Z+1
 149               	.LVL8:
 150               		.loc 1 162 23 view .LVU20
 151 0006 0C94 0000 		jmp layer_switch_get_action
 152               	.LVL9:
 153               		.loc 1 162 23 view .LVU21
 154               		.cfi_endproc
 155               	.LFE19:
 157               		.section	.text.register_code,"ax",@progbits
 158               	.global	register_code
 160               	register_code:
 161               	.LVL10:
 162               	.LFB23:
 163:tmk_core/common/action.c **** 
 164:tmk_core/common/action.c ****     switch (action.kind.id) {
 165:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 166:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 167:tmk_core/common/action.c ****             switch (action.swap.code) {
 168:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 169:tmk_core/common/action.c ****                 default:
 170:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 171:tmk_core/common/action.c ****                     swap_held  = true;
 172:tmk_core/common/action.c ****             }
 173:tmk_core/common/action.c ****             break;
 174:tmk_core/common/action.c **** #    endif
 175:tmk_core/common/action.c ****     }
 176:tmk_core/common/action.c **** }
 177:tmk_core/common/action.c **** #endif
 178:tmk_core/common/action.c **** 
 179:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 180:tmk_core/common/action.c ****  *
 181:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 182:tmk_core/common/action.c ****  */
 183:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 184:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 185:tmk_core/common/action.c ****         return;
 186:tmk_core/common/action.c ****     }
 187:tmk_core/common/action.c **** 
 188:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 189:tmk_core/common/action.c **** 
 190:tmk_core/common/action.c ****     process_record_handler(record);
 191:tmk_core/common/action.c ****     post_process_record_quantum(record);
 192:tmk_core/common/action.c **** }
 193:tmk_core/common/action.c **** 
 194:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 195:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 196:tmk_core/common/action.c ****     dprint("ACTION: ");
 197:tmk_core/common/action.c ****     debug_action(action);
 198:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 199:tmk_core/common/action.c ****     dprint(" layer_state: ");
 200:tmk_core/common/action.c ****     layer_debug();
 201:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 202:tmk_core/common/action.c ****     default_layer_debug();
 203:tmk_core/common/action.c **** #endif
 204:tmk_core/common/action.c ****     dprintln();
 205:tmk_core/common/action.c **** 
 206:tmk_core/common/action.c ****     process_action(record, action);
 207:tmk_core/common/action.c **** }
 208:tmk_core/common/action.c **** 
 209:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 210:tmk_core/common/action.c ****  *
 211:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 212:tmk_core/common/action.c ****  */
 213:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 214:tmk_core/common/action.c ****     keyevent_t event = record->event;
 215:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 216:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c **** 
 219:tmk_core/common/action.c ****     if (event.pressed) {
 220:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 221:tmk_core/common/action.c ****         clear_weak_mods();
 222:tmk_core/common/action.c ****     }
 223:tmk_core/common/action.c **** 
 224:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 225:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 226:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 227:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 228:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 229:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 230:tmk_core/common/action.c ****     }
 231:tmk_core/common/action.c **** #endif
 232:tmk_core/common/action.c **** 
 233:tmk_core/common/action.c ****     switch (action.kind.id) {
 234:tmk_core/common/action.c ****         /* Key and Mods */
 235:tmk_core/common/action.c ****         case ACT_LMODS:
 236:tmk_core/common/action.c ****         case ACT_RMODS: {
 237:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 238:tmk_core/common/action.c ****             if (event.pressed) {
 239:tmk_core/common/action.c ****                 if (mods) {
 240:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 241:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 242:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 243:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 244:tmk_core/common/action.c ****                         add_mods(mods);
 245:tmk_core/common/action.c ****                     } else {
 246:tmk_core/common/action.c ****                         add_weak_mods(mods);
 247:tmk_core/common/action.c ****                     }
 248:tmk_core/common/action.c ****                     send_keyboard_report();
 249:tmk_core/common/action.c ****                 }
 250:tmk_core/common/action.c ****                 register_code(action.key.code);
 251:tmk_core/common/action.c ****             } else {
 252:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 253:tmk_core/common/action.c ****                 if (mods) {
 254:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 255:tmk_core/common/action.c ****                         del_mods(mods);
 256:tmk_core/common/action.c ****                     } else {
 257:tmk_core/common/action.c ****                         del_weak_mods(mods);
 258:tmk_core/common/action.c ****                     }
 259:tmk_core/common/action.c ****                     send_keyboard_report();
 260:tmk_core/common/action.c ****                 }
 261:tmk_core/common/action.c ****             }
 262:tmk_core/common/action.c ****         } break;
 263:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 264:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 265:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 266:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 267:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 268:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 269:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 270:tmk_core/common/action.c ****                     // Oneshot modifier
 271:tmk_core/common/action.c ****                     if (event.pressed) {
 272:tmk_core/common/action.c ****                         if (tap_count == 0) {
 273:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 274:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 275:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 276:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 277:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 278:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 279:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 280:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 281:tmk_core/common/action.c ****                             clear_oneshot_mods();
 282:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 283:tmk_core/common/action.c ****                             register_mods(mods);
 284:tmk_core/common/action.c **** #        endif
 285:tmk_core/common/action.c ****                         } else {
 286:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 287:tmk_core/common/action.c ****                         }
 288:tmk_core/common/action.c ****                     } else {
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 290:tmk_core/common/action.c ****                             clear_oneshot_mods();
 291:tmk_core/common/action.c ****                             unregister_mods(mods);
 292:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 293:tmk_core/common/action.c ****                             // Retain Oneshot mods
 294:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 295:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 296:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 297:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 298:tmk_core/common/action.c ****                                 unregister_mods(mods);
 299:tmk_core/common/action.c ****                             }
 300:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 301:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 302:tmk_core/common/action.c **** #        endif
 303:tmk_core/common/action.c ****                         } else {
 304:tmk_core/common/action.c ****                             clear_oneshot_mods();
 305:tmk_core/common/action.c ****                             unregister_mods(mods);
 306:tmk_core/common/action.c ****                         }
 307:tmk_core/common/action.c ****                     }
 308:tmk_core/common/action.c ****                     break;
 309:tmk_core/common/action.c **** #    endif
 310:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 311:tmk_core/common/action.c ****                     if (event.pressed) {
 312:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 313:tmk_core/common/action.c ****                             register_mods(mods);
 314:tmk_core/common/action.c ****                         }
 315:tmk_core/common/action.c ****                     } else {
 316:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 317:tmk_core/common/action.c ****                             unregister_mods(mods);
 318:tmk_core/common/action.c ****                         }
 319:tmk_core/common/action.c ****                     }
 320:tmk_core/common/action.c ****                     break;
 321:tmk_core/common/action.c ****                 default:
 322:tmk_core/common/action.c ****                     if (event.pressed) {
 323:tmk_core/common/action.c ****                         if (tap_count > 0) {
 324:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 325:tmk_core/common/action.c ****                             if (
 326:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 327:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event)) &&
 328:tmk_core/common/action.c **** #        endif
 329:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 330:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 331:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 332:tmk_core/common/action.c ****                                 record->tap.count = 0;
 333:tmk_core/common/action.c ****                                 register_mods(mods);
 334:tmk_core/common/action.c ****                             } else
 335:tmk_core/common/action.c **** #    endif
 336:tmk_core/common/action.c ****                             {
 337:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 338:tmk_core/common/action.c ****                                 register_code(action.key.code);
 339:tmk_core/common/action.c ****                             }
 340:tmk_core/common/action.c ****                         } else {
 341:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 342:tmk_core/common/action.c ****                             register_mods(mods);
 343:tmk_core/common/action.c ****                         }
 344:tmk_core/common/action.c ****                     } else {
 345:tmk_core/common/action.c ****                         if (tap_count > 0) {
 346:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 347:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 348:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 349:tmk_core/common/action.c ****                             }
 350:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 351:tmk_core/common/action.c ****                         } else {
 352:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 353:tmk_core/common/action.c ****                             unregister_mods(mods);
 354:tmk_core/common/action.c ****                         }
 355:tmk_core/common/action.c ****                     }
 356:tmk_core/common/action.c ****                     break;
 357:tmk_core/common/action.c ****             }
 358:tmk_core/common/action.c ****         } break;
 359:tmk_core/common/action.c **** #endif
 360:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 361:tmk_core/common/action.c ****         /* other HID usage */
 362:tmk_core/common/action.c ****         case ACT_USAGE:
 363:tmk_core/common/action.c ****             switch (action.usage.page) {
 364:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 365:tmk_core/common/action.c ****                     if (event.pressed) {
 366:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 367:tmk_core/common/action.c ****                     } else {
 368:tmk_core/common/action.c ****                         host_system_send(0);
 369:tmk_core/common/action.c ****                     }
 370:tmk_core/common/action.c ****                     break;
 371:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 372:tmk_core/common/action.c ****                     if (event.pressed) {
 373:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 374:tmk_core/common/action.c ****                     } else {
 375:tmk_core/common/action.c ****                         host_consumer_send(0);
 376:tmk_core/common/action.c ****                     }
 377:tmk_core/common/action.c ****                     break;
 378:tmk_core/common/action.c ****             }
 379:tmk_core/common/action.c ****             break;
 380:tmk_core/common/action.c **** #endif
 381:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 382:tmk_core/common/action.c ****         /* Mouse key */
 383:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 384:tmk_core/common/action.c ****             if (event.pressed) {
 385:tmk_core/common/action.c ****                 switch (action.key.code) {
 386:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 387:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 388:tmk_core/common/action.c ****                         break;
 389:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 390:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 391:tmk_core/common/action.c ****                         break;
 392:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 393:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 394:tmk_core/common/action.c ****                         break;
 395:tmk_core/common/action.c ****                     default:
 396:tmk_core/common/action.c ****                         break;
 397:tmk_core/common/action.c ****                 }
 398:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 399:tmk_core/common/action.c ****                 mousekey_send();
 400:tmk_core/common/action.c ****             } else {
 401:tmk_core/common/action.c ****                 switch (action.key.code) {
 402:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 403:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 404:tmk_core/common/action.c ****                         break;
 405:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 406:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 407:tmk_core/common/action.c ****                         break;
 408:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 409:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 410:tmk_core/common/action.c ****                         break;
 411:tmk_core/common/action.c ****                     default:
 412:tmk_core/common/action.c ****                         break;
 413:tmk_core/common/action.c ****                 }
 414:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 415:tmk_core/common/action.c ****                 mousekey_send();
 416:tmk_core/common/action.c ****             }
 417:tmk_core/common/action.c ****             break;
 418:tmk_core/common/action.c **** #endif
 419:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 420:tmk_core/common/action.c ****         case ACT_LAYER:
 421:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 422:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 423:tmk_core/common/action.c ****                 if (!event.pressed) {
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 425:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 426:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 427:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 428:tmk_core/common/action.c ****                         case OP_BIT_AND:
 429:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 430:tmk_core/common/action.c ****                             break;
 431:tmk_core/common/action.c ****                         case OP_BIT_OR:
 432:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 433:tmk_core/common/action.c ****                             break;
 434:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 435:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 436:tmk_core/common/action.c ****                             break;
 437:tmk_core/common/action.c ****                         case OP_BIT_SET:
 438:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 439:tmk_core/common/action.c ****                             break;
 440:tmk_core/common/action.c ****                     }
 441:tmk_core/common/action.c ****                 }
 442:tmk_core/common/action.c ****             } else {
 443:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 444:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 445:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 446:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 447:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 448:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 449:tmk_core/common/action.c ****                         case OP_BIT_AND:
 450:tmk_core/common/action.c ****                             layer_and(bits | mask);
 451:tmk_core/common/action.c ****                             break;
 452:tmk_core/common/action.c ****                         case OP_BIT_OR:
 453:tmk_core/common/action.c ****                             layer_or(bits | mask);
 454:tmk_core/common/action.c ****                             break;
 455:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 456:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 457:tmk_core/common/action.c ****                             break;
 458:tmk_core/common/action.c ****                         case OP_BIT_SET:
 459:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 460:tmk_core/common/action.c ****                             break;
 461:tmk_core/common/action.c ****                     }
 462:tmk_core/common/action.c ****                 }
 463:tmk_core/common/action.c ****             }
 464:tmk_core/common/action.c ****             break;
 465:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 466:tmk_core/common/action.c ****             if (event.pressed) {
 467:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 468:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 469:tmk_core/common/action.c ****             } else {
 470:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 471:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 472:tmk_core/common/action.c ****             }
 473:tmk_core/common/action.c ****             break;
 474:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 475:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 476:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 477:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 478:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 479:tmk_core/common/action.c ****                     /* tap toggle */
 480:tmk_core/common/action.c ****                     if (event.pressed) {
 481:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 482:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 483:tmk_core/common/action.c ****                         }
 484:tmk_core/common/action.c ****                     } else {
 485:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 486:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 487:tmk_core/common/action.c ****                         }
 488:tmk_core/common/action.c ****                     }
 489:tmk_core/common/action.c ****                     break;
 490:tmk_core/common/action.c ****                 case OP_ON_OFF:
 491:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 492:tmk_core/common/action.c ****                     break;
 493:tmk_core/common/action.c ****                 case OP_OFF_ON:
 494:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 495:tmk_core/common/action.c ****                     break;
 496:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 497:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 498:tmk_core/common/action.c ****                     break;
 499:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 500:tmk_core/common/action.c ****                 case OP_ONESHOT:
 501:tmk_core/common/action.c ****                     // Oneshot modifier
 502:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 503:tmk_core/common/action.c ****                     do_release_oneshot = false;
 504:tmk_core/common/action.c ****                     if (event.pressed) {
 505:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 506:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 507:tmk_core/common/action.c ****                             reset_oneshot_layer();
 508:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 509:tmk_core/common/action.c ****                             break;
 510:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 511:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 512:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 513:tmk_core/common/action.c ****                         }
 514:tmk_core/common/action.c ****                     } else {
 515:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 516:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 517:tmk_core/common/action.c ****                             reset_oneshot_layer();
 518:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 519:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 520:tmk_core/common/action.c ****                         } else {
 521:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 522:tmk_core/common/action.c ****                         }
 523:tmk_core/common/action.c ****                     }
 524:tmk_core/common/action.c **** #            else
 525:tmk_core/common/action.c ****                     if (event.pressed) {
 526:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 527:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 528:tmk_core/common/action.c ****                     } else {
 529:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 530:tmk_core/common/action.c ****                         if (tap_count > 1) {
 531:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 532:tmk_core/common/action.c ****                         }
 533:tmk_core/common/action.c ****                     }
 534:tmk_core/common/action.c **** #            endif
 535:tmk_core/common/action.c ****                     break;
 536:tmk_core/common/action.c **** #        endif
 537:tmk_core/common/action.c ****                 default:
 538:tmk_core/common/action.c ****                     /* tap key */
 539:tmk_core/common/action.c ****                     if (event.pressed) {
 540:tmk_core/common/action.c ****                         if (tap_count > 0) {
 541:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 542:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 543:tmk_core/common/action.c ****                         } else {
 544:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 545:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     } else {
 548:tmk_core/common/action.c ****                         if (tap_count > 0) {
 549:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 550:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 551:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 552:tmk_core/common/action.c ****                             } else {
 553:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 554:tmk_core/common/action.c ****                             }
 555:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 556:tmk_core/common/action.c ****                         } else {
 557:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 558:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 559:tmk_core/common/action.c ****                         }
 560:tmk_core/common/action.c ****                     }
 561:tmk_core/common/action.c ****                     break;
 562:tmk_core/common/action.c ****             }
 563:tmk_core/common/action.c ****             break;
 564:tmk_core/common/action.c **** #    endif
 565:tmk_core/common/action.c **** #endif
 566:tmk_core/common/action.c ****             /* Extentions */
 567:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 568:tmk_core/common/action.c ****         case ACT_MACRO:
 569:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 570:tmk_core/common/action.c ****             break;
 571:tmk_core/common/action.c **** #endif
 572:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 573:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 574:tmk_core/common/action.c ****             switch (action.swap.code) {
 575:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 576:tmk_core/common/action.c ****                     if (event.pressed) {
 577:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 578:tmk_core/common/action.c ****                     }
 579:tmk_core/common/action.c ****                     break;
 580:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 581:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 582:tmk_core/common/action.c ****                     break;
 583:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 584:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 585:tmk_core/common/action.c ****                     break;
 586:tmk_core/common/action.c ****                 case OP_SH_ON:
 587:tmk_core/common/action.c ****                     if (!event.pressed) {
 588:tmk_core/common/action.c ****                         swap_hands = true;
 589:tmk_core/common/action.c ****                     }
 590:tmk_core/common/action.c ****                     break;
 591:tmk_core/common/action.c ****                 case OP_SH_OFF:
 592:tmk_core/common/action.c ****                     if (!event.pressed) {
 593:tmk_core/common/action.c ****                         swap_hands = false;
 594:tmk_core/common/action.c ****                     }
 595:tmk_core/common/action.c ****                     break;
 596:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 597:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 598:tmk_core/common/action.c ****                     /* tap toggle */
 599:tmk_core/common/action.c **** 
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         if (swap_held) {
 602:tmk_core/common/action.c ****                             swap_held = false;
 603:tmk_core/common/action.c ****                         } else {
 604:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:tmk_core/common/action.c ****                         }
 606:tmk_core/common/action.c ****                     } else {
 607:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 608:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 609:tmk_core/common/action.c ****                         }
 610:tmk_core/common/action.c ****                     }
 611:tmk_core/common/action.c ****                     break;
 612:tmk_core/common/action.c ****                 default:
 613:tmk_core/common/action.c ****                     /* tap key */
 614:tmk_core/common/action.c ****                     if (tap_count > 0) {
 615:tmk_core/common/action.c ****                         if (swap_held) {
 616:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 617:tmk_core/common/action.c ****                             swap_held  = false;
 618:tmk_core/common/action.c ****                         }
 619:tmk_core/common/action.c ****                         if (event.pressed) {
 620:tmk_core/common/action.c ****                             register_code(action.swap.code);
 621:tmk_core/common/action.c ****                         } else {
 622:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 623:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 624:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 625:tmk_core/common/action.c ****                         }
 626:tmk_core/common/action.c ****                     } else {
 627:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 628:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 629:tmk_core/common/action.c ****                             swap_held  = false;
 630:tmk_core/common/action.c ****                         }
 631:tmk_core/common/action.c ****                     }
 632:tmk_core/common/action.c **** #    endif
 633:tmk_core/common/action.c ****             }
 634:tmk_core/common/action.c **** #endif
 635:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 636:tmk_core/common/action.c ****         case ACT_FUNCTION:
 637:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 638:tmk_core/common/action.c ****             break;
 639:tmk_core/common/action.c **** #endif
 640:tmk_core/common/action.c ****         default:
 641:tmk_core/common/action.c ****             break;
 642:tmk_core/common/action.c ****     }
 643:tmk_core/common/action.c **** 
 644:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 645:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 646:tmk_core/common/action.c ****     switch (action.kind.id) {
 647:tmk_core/common/action.c ****         case ACT_LAYER:
 648:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 649:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 650:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 651:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 652:tmk_core/common/action.c **** #    endif
 653:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 654:tmk_core/common/action.c ****             break;
 655:tmk_core/common/action.c ****         default:
 656:tmk_core/common/action.c ****             break;
 657:tmk_core/common/action.c ****     }
 658:tmk_core/common/action.c **** #endif
 659:tmk_core/common/action.c **** 
 660:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 661:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 662:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 663:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 664:tmk_core/common/action.c ****     } else {
 665:tmk_core/common/action.c ****         if (event.pressed) {
 666:tmk_core/common/action.c ****             if (tap_count > 0) {
 667:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 668:tmk_core/common/action.c ****             } else {
 669:tmk_core/common/action.c ****             }
 670:tmk_core/common/action.c ****         } else {
 671:tmk_core/common/action.c ****             if (tap_count > 0) {
 672:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 673:tmk_core/common/action.c ****             } else {
 674:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 675:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 676:tmk_core/common/action.c ****                 }
 677:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 678:tmk_core/common/action.c ****             }
 679:tmk_core/common/action.c ****         }
 680:tmk_core/common/action.c ****     }
 681:tmk_core/common/action.c **** #    endif
 682:tmk_core/common/action.c **** #endif
 683:tmk_core/common/action.c **** 
 684:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 685:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 686:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 687:tmk_core/common/action.c ****      */
 688:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 689:tmk_core/common/action.c ****         record->event.pressed = false;
 690:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 691:tmk_core/common/action.c ****         process_record(record);
 692:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 693:tmk_core/common/action.c ****     }
 694:tmk_core/common/action.c **** #endif
 695:tmk_core/common/action.c **** }
 696:tmk_core/common/action.c **** 
 697:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 698:tmk_core/common/action.c ****  *
 699:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 700:tmk_core/common/action.c ****  */
 701:tmk_core/common/action.c **** void register_code(uint8_t code) {
 163               		.loc 1 701 34 is_stmt 1 view -0
 164               		.cfi_startproc
 165               		.loc 1 701 34 is_stmt 0 view .LVU23
 166 0000 CF93      		push r28
 167               	.LCFI4:
 168               		.cfi_def_cfa_offset 3
 169               		.cfi_offset 28, -2
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               	/* stack size = 1 */
 173               	.L__stack_usage = 1
 174 0002 C82F      		mov r28,r24
 702:tmk_core/common/action.c ****     if (code == KC_NO) {
 175               		.loc 1 702 5 is_stmt 1 view .LVU24
 176               		.loc 1 702 8 is_stmt 0 view .LVU25
 177 0004 8823      		tst r24
 178 0006 01F4      		brne .+2
 179 0008 00C0      		rjmp .L5
 703:tmk_core/common/action.c ****         return;
 704:tmk_core/common/action.c ****     }
 705:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 706:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 707:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 708:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 709:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 710:tmk_core/common/action.c **** #    endif
 711:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 712:tmk_core/common/action.c ****         send_keyboard_report();
 713:tmk_core/common/action.c ****         wait_ms(100);
 714:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 715:tmk_core/common/action.c ****         send_keyboard_report();
 716:tmk_core/common/action.c ****     }
 717:tmk_core/common/action.c **** 
 718:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 719:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 720:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 721:tmk_core/common/action.c **** #    endif
 722:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 723:tmk_core/common/action.c ****         send_keyboard_report();
 724:tmk_core/common/action.c ****         wait_ms(100);
 725:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 726:tmk_core/common/action.c ****         send_keyboard_report();
 727:tmk_core/common/action.c ****     }
 728:tmk_core/common/action.c **** 
 729:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 730:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 731:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 732:tmk_core/common/action.c **** #    endif
 733:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 734:tmk_core/common/action.c ****         send_keyboard_report();
 735:tmk_core/common/action.c ****         wait_ms(100);
 736:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 737:tmk_core/common/action.c ****         send_keyboard_report();
 738:tmk_core/common/action.c ****     }
 739:tmk_core/common/action.c **** #endif
 740:tmk_core/common/action.c **** 
 741:tmk_core/common/action.c ****     else if
 180               		.loc 1 741 10 is_stmt 1 view .LVU26
 742:tmk_core/common/action.c ****         IS_KEY(code) {
 181               		.loc 1 742 9 is_stmt 0 view .LVU27
 182 000a 8CEF      		ldi r24,lo8(-4)
 183               	.LVL11:
 184               		.loc 1 742 9 view .LVU28
 185 000c 8C0F      		add r24,r28
 186 000e 813A      		cpi r24,lo8(-95)
 187 0010 00F4      		brsh .L7
 743:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 744:tmk_core/common/action.c ****             if (command_proc(code)) return;
 188               		.loc 1 744 13 is_stmt 1 view .LVU29
 745:tmk_core/common/action.c **** 
 746:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:tmk_core/common/action.c **** /* TODO: remove
 748:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:tmk_core/common/action.c **** 
 752:tmk_core/common/action.c ****             add_key(code);
 753:tmk_core/common/action.c ****             send_keyboard_report();
 754:tmk_core/common/action.c **** 
 755:tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:tmk_core/common/action.c ****             send_keyboard_report();
 757:tmk_core/common/action.c ****             oneshot_cancel();
 758:tmk_core/common/action.c ****         } else
 759:tmk_core/common/action.c **** */
 760:tmk_core/common/action.c **** #endif
 761:tmk_core/common/action.c ****             {
 762:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 763:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 764:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 765:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 189               		.loc 1 765 17 view .LVU30
 190               		.loc 1 765 21 is_stmt 0 view .LVU31
 191 0012 6C2F      		mov r22,r28
 192 0014 8091 0000 		lds r24,keyboard_report
 193 0018 9091 0000 		lds r25,keyboard_report+1
 194 001c 0E94 0000 		call is_key_pressed
 195               	.LVL12:
 196               		.loc 1 765 20 view .LVU32
 197 0020 8823      		tst r24
 198 0022 01F0      		breq .L8
 766:tmk_core/common/action.c ****                     del_key(code);
 199               		.loc 1 766 21 is_stmt 1 view .LVU33
 200 0024 8C2F      		mov r24,r28
 201 0026 0E94 0000 		call del_key
 202               	.LVL13:
 767:tmk_core/common/action.c ****                     send_keyboard_report();
 203               		.loc 1 767 21 view .LVU34
 204 002a 0E94 0000 		call send_keyboard_report
 205               	.LVL14:
 206               	.L8:
 768:tmk_core/common/action.c ****                 }
 769:tmk_core/common/action.c ****                 add_key(code);
 207               		.loc 1 769 17 view .LVU35
 208 002e 8C2F      		mov r24,r28
 209 0030 0E94 0000 		call add_key
 210               	.LVL15:
 770:tmk_core/common/action.c ****                 send_keyboard_report();
 211               		.loc 1 770 17 view .LVU36
 212               	.L17:
 771:tmk_core/common/action.c ****             }
 772:tmk_core/common/action.c ****         }
 773:tmk_core/common/action.c ****     else if
 774:tmk_core/common/action.c ****         IS_MOD(code) {
 775:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 776:tmk_core/common/action.c ****             send_keyboard_report();
 213               		.loc 1 776 13 view .LVU37
 214               	/* epilogue start */
 777:tmk_core/common/action.c ****         }
 778:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 779:tmk_core/common/action.c ****     else if
 780:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 781:tmk_core/common/action.c ****     else if
 782:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 783:tmk_core/common/action.c **** #endif
 784:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 785:tmk_core/common/action.c ****     else if
 786:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 787:tmk_core/common/action.c ****             mousekey_on(code);
 788:tmk_core/common/action.c ****             mousekey_send();
 789:tmk_core/common/action.c ****         }
 790:tmk_core/common/action.c **** #endif
 791:tmk_core/common/action.c **** }
 215               		.loc 1 791 1 is_stmt 0 view .LVU38
 216 0034 CF91      		pop r28
 776:tmk_core/common/action.c ****         }
 217               		.loc 1 776 13 view .LVU39
 218 0036 0C94 0000 		jmp send_keyboard_report
 219               	.LVL16:
 220               	.L7:
 773:tmk_core/common/action.c ****         IS_MOD(code) {
 221               		.loc 1 773 10 is_stmt 1 view .LVU40
 774:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 222               		.loc 1 774 9 is_stmt 0 view .LVU41
 223 003a 80E2      		ldi r24,lo8(32)
 224 003c 8C0F      		add r24,r28
 225 003e 8830      		cpi r24,lo8(8)
 226 0040 00F4      		brsh .L9
 775:tmk_core/common/action.c ****             send_keyboard_report();
 227               		.loc 1 775 13 is_stmt 1 view .LVU42
 775:tmk_core/common/action.c ****             send_keyboard_report();
 228               		.loc 1 775 22 is_stmt 0 view .LVU43
 229 0042 C770      		andi r28,lo8(7)
 230               	.LVL17:
 775:tmk_core/common/action.c ****             send_keyboard_report();
 231               		.loc 1 775 13 view .LVU44
 232 0044 81E0      		ldi r24,lo8(1)
 233 0046 00C0      		rjmp 2f
 234               		1:
 235 0048 880F      		lsl r24
 236               		2:
 237 004a CA95      		dec r28
 238 004c 02F4      		brpl 1b
 239 004e 0E94 0000 		call add_mods
 240               	.LVL18:
 241 0052 00C0      		rjmp .L17
 242               	.LVL19:
 243               	.L9:
 779:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 244               		.loc 1 779 10 is_stmt 1 view .LVU45
 780:tmk_core/common/action.c ****     else if
 245               		.loc 1 780 9 is_stmt 0 view .LVU46
 246 0054 EBE5      		ldi r30,lo8(91)
 247 0056 EC0F      		add r30,r28
 248 0058 E330      		cpi r30,lo8(3)
 249 005a 00F4      		brsh .L10
 780:tmk_core/common/action.c ****     else if
 250               		.loc 1 780 27 is_stmt 1 view .LVU47
 251               	.LVL20:
 252               	.LBB20:
 253               	.LBI20:
 254               		.file 2 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO
  33:tmk_core/common/report.h **** };
  34:tmk_core/common/report.h **** 
  35:tmk_core/common/report.h **** /* Mouse buttons */
  36:tmk_core/common/report.h **** enum mouse_buttons {
  37:tmk_core/common/report.h ****     MOUSE_BTN1 = (1 << 0),
  38:tmk_core/common/report.h ****     MOUSE_BTN2 = (1 << 1),
  39:tmk_core/common/report.h ****     MOUSE_BTN3 = (1 << 2),
  40:tmk_core/common/report.h ****     MOUSE_BTN4 = (1 << 3),
  41:tmk_core/common/report.h ****     MOUSE_BTN5 = (1 << 4)
  42:tmk_core/common/report.h **** };
  43:tmk_core/common/report.h **** 
  44:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  45:tmk_core/common/report.h ****  *
  46:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  47:tmk_core/common/report.h ****  */
  48:tmk_core/common/report.h **** enum consumer_usages {
  49:tmk_core/common/report.h ****     // 15.5 Display Controls (https://www.usb.org/sites/default/files/hutrr41_0.pdf)
  50:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F,
  51:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  52:tmk_core/common/report.h ****     // 15.7 Transport Controls
  53:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  54:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  55:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  56:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  57:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  58:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  59:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  60:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  61:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  62:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  63:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  64:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  65:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  66:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  67:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  68:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  69:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  70:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  71:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  72:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  73:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  74:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  75:tmk_core/common/report.h ****     AC_HOME                = 0x223,
  76:tmk_core/common/report.h ****     AC_BACK                = 0x224,
  77:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
  78:tmk_core/common/report.h ****     AC_STOP                = 0x226,
  79:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
  80:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
  81:tmk_core/common/report.h **** };
  82:tmk_core/common/report.h **** 
  83:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
  84:tmk_core/common/report.h ****  *
  85:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
  86:tmk_core/common/report.h ****  */
  87:tmk_core/common/report.h **** enum desktop_usages {
  88:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
  89:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN = 0x81,
  90:tmk_core/common/report.h ****     SYSTEM_SLEEP      = 0x82,
  91:tmk_core/common/report.h ****     SYSTEM_WAKE_UP    = 0x83
  92:tmk_core/common/report.h **** };
  93:tmk_core/common/report.h **** 
  94:tmk_core/common/report.h **** // clang-format on
  95:tmk_core/common/report.h **** 
  96:tmk_core/common/report.h **** #define NKRO_SHARED_EP
  97:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
  98:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
  99:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 100:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 101:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 102:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 103:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 104:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 105:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 106:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 107:tmk_core/common/report.h **** #    else
 108:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 109:tmk_core/common/report.h **** #    endif
 110:tmk_core/common/report.h **** #endif
 111:tmk_core/common/report.h **** 
 112:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 113:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 114:tmk_core/common/report.h **** #else
 115:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 116:tmk_core/common/report.h **** #endif
 117:tmk_core/common/report.h **** 
 118:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 119:tmk_core/common/report.h **** 
 120:tmk_core/common/report.h **** /* VUSB hardcodes keyboard and mouse+extrakey only */
 121:tmk_core/common/report.h **** #if defined(PROTOCOL_VUSB)
 122:tmk_core/common/report.h **** #    undef KEYBOARD_SHARED_EP
 123:tmk_core/common/report.h **** #    undef MOUSE_SHARED_EP
 124:tmk_core/common/report.h **** #endif
 125:tmk_core/common/report.h **** 
 126:tmk_core/common/report.h **** #ifdef __cplusplus
 127:tmk_core/common/report.h **** extern "C" {
 128:tmk_core/common/report.h **** #endif
 129:tmk_core/common/report.h **** 
 130:tmk_core/common/report.h **** /*
 131:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 132:tmk_core/common/report.h ****  *
 133:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 134:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 135:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 136:tmk_core/common/report.h ****  *
 137:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 138:tmk_core/common/report.h ****  *
 139:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 140:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 141:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 142:tmk_core/common/report.h ****  *
 143:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 144:tmk_core/common/report.h ****  *
 145:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 146:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 147:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 148:tmk_core/common/report.h ****  *
 149:tmk_core/common/report.h ****  */
 150:tmk_core/common/report.h **** typedef union {
 151:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 152:tmk_core/common/report.h ****     struct {
 153:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 154:tmk_core/common/report.h ****         uint8_t report_id;
 155:tmk_core/common/report.h **** #endif
 156:tmk_core/common/report.h ****         uint8_t mods;
 157:tmk_core/common/report.h ****         uint8_t reserved;
 158:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 159:tmk_core/common/report.h ****     };
 160:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 161:tmk_core/common/report.h ****     struct nkro_report {
 162:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 163:tmk_core/common/report.h ****         uint8_t report_id;
 164:tmk_core/common/report.h **** #    endif
 165:tmk_core/common/report.h ****         uint8_t mods;
 166:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 167:tmk_core/common/report.h ****     } nkro;
 168:tmk_core/common/report.h **** #endif
 169:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 170:tmk_core/common/report.h **** 
 171:tmk_core/common/report.h **** typedef struct {
 172:tmk_core/common/report.h ****     uint8_t  report_id;
 173:tmk_core/common/report.h ****     uint16_t usage;
 174:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 175:tmk_core/common/report.h **** 
 176:tmk_core/common/report.h **** typedef struct {
 177:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 178:tmk_core/common/report.h ****     uint8_t report_id;
 179:tmk_core/common/report.h **** #endif
 180:tmk_core/common/report.h ****     uint8_t buttons;
 181:tmk_core/common/report.h ****     int8_t  x;
 182:tmk_core/common/report.h ****     int8_t  y;
 183:tmk_core/common/report.h ****     int8_t  v;
 184:tmk_core/common/report.h ****     int8_t  h;
 185:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 186:tmk_core/common/report.h **** 
 187:tmk_core/common/report.h **** /* keycode to system usage */
 188:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 255               		.loc 2 188 24 view .LVU48
 256               	.LBE20:
 189:tmk_core/common/report.h ****     switch (key) {
 257               		.loc 2 189 5 view .LVU49
 780:tmk_core/common/action.c ****     else if
 258               		.loc 1 780 27 is_stmt 0 view .LVU50
 259 005c F0E0      		ldi r31,0
 260 005e E050      		subi r30,lo8(-(CSWTCH.10))
 261 0060 F040      		sbci r31,hi8(-(CSWTCH.10))
 262 0062 8081      		ld r24,Z
 263 0064 90E0      		ldi r25,0
 264               	/* epilogue start */
 265               		.loc 1 791 1 view .LVU51
 266 0066 CF91      		pop r28
 267               	.LVL21:
 780:tmk_core/common/action.c ****     else if
 268               		.loc 1 780 27 view .LVU52
 269 0068 0C94 0000 		jmp host_system_send
 270               	.LVL22:
 271               	.L10:
 781:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 272               		.loc 1 781 10 is_stmt 1 view .LVU53
 782:tmk_core/common/action.c **** #endif
 273               		.loc 1 782 9 is_stmt 0 view .LVU54
 274 006c C85A      		subi r28,lo8(-(88))
 275               	.LVL23:
 782:tmk_core/common/action.c **** #endif
 276               		.loc 1 782 9 view .LVU55
 277 006e C731      		cpi r28,lo8(23)
 278 0070 00F4      		brsh .L5
 782:tmk_core/common/action.c **** #endif
 279               		.loc 1 782 29 is_stmt 1 view .LVU56
 280               	.LVL24:
 281               	.LBB21:
 282               	.LBI21:
 190:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 191:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 192:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 193:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 194:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 195:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 196:tmk_core/common/report.h ****         default:
 197:tmk_core/common/report.h ****             return 0;
 198:tmk_core/common/report.h ****     }
 199:tmk_core/common/report.h **** }
 200:tmk_core/common/report.h **** 
 201:tmk_core/common/report.h **** /* keycode to consumer usage */
 202:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 283               		.loc 2 202 24 view .LVU57
 284               	.LBE21:
 203:tmk_core/common/report.h ****     switch (key) {
 285               		.loc 2 203 5 view .LVU58
 782:tmk_core/common/action.c **** #endif
 286               		.loc 1 782 29 is_stmt 0 view .LVU59
 287 0072 EC2F      		mov r30,r28
 288 0074 F0E0      		ldi r31,0
 289 0076 EE0F      		lsl r30
 290 0078 FF1F      		rol r31
 291 007a E050      		subi r30,lo8(-(CSWTCH.11))
 292 007c F040      		sbci r31,hi8(-(CSWTCH.11))
 293 007e 8081      		ld r24,Z
 294 0080 9181      		ldd r25,Z+1
 295               	/* epilogue start */
 296               		.loc 1 791 1 view .LVU60
 297 0082 CF91      		pop r28
 298               	.LVL25:
 782:tmk_core/common/action.c **** #endif
 299               		.loc 1 782 29 view .LVU61
 300 0084 0C94 0000 		jmp host_consumer_send
 301               	.LVL26:
 302               	.L5:
 303               	/* epilogue start */
 304               		.loc 1 791 1 view .LVU62
 305 0088 CF91      		pop r28
 306 008a 0895      		ret
 307               		.cfi_endproc
 308               	.LFE23:
 310               		.section	.text.unregister_code,"ax",@progbits
 311               	.global	unregister_code
 313               	unregister_code:
 314               	.LVL27:
 315               	.LFB24:
 792:tmk_core/common/action.c **** 
 793:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 794:tmk_core/common/action.c ****  *
 795:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 796:tmk_core/common/action.c ****  */
 797:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 316               		.loc 1 797 36 is_stmt 1 view -0
 317               		.cfi_startproc
 318               	/* prologue: function */
 319               	/* frame size = 0 */
 320               	/* stack size = 0 */
 321               	.L__stack_usage = 0
 798:tmk_core/common/action.c ****     if (code == KC_NO) {
 322               		.loc 1 798 5 view .LVU64
 323               		.loc 1 798 8 is_stmt 0 view .LVU65
 324 0000 8823      		tst r24
 325 0002 01F0      		breq .L18
 799:tmk_core/common/action.c ****         return;
 800:tmk_core/common/action.c ****     }
 801:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 802:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 803:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 804:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 805:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 806:tmk_core/common/action.c **** #    endif
 807:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 808:tmk_core/common/action.c ****         send_keyboard_report();
 809:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 810:tmk_core/common/action.c ****         send_keyboard_report();
 811:tmk_core/common/action.c ****     }
 812:tmk_core/common/action.c **** 
 813:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 814:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 815:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 816:tmk_core/common/action.c **** #    endif
 817:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 818:tmk_core/common/action.c ****         send_keyboard_report();
 819:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 820:tmk_core/common/action.c ****         send_keyboard_report();
 821:tmk_core/common/action.c ****     }
 822:tmk_core/common/action.c **** 
 823:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 824:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 825:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 826:tmk_core/common/action.c **** #    endif
 827:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 828:tmk_core/common/action.c ****         send_keyboard_report();
 829:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 830:tmk_core/common/action.c ****         send_keyboard_report();
 831:tmk_core/common/action.c ****     }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** 
 834:tmk_core/common/action.c ****     else if
 326               		.loc 1 834 10 is_stmt 1 view .LVU66
 835:tmk_core/common/action.c ****         IS_KEY(code) {
 327               		.loc 1 835 9 is_stmt 0 view .LVU67
 328 0004 9CEF      		ldi r25,lo8(-4)
 329 0006 980F      		add r25,r24
 330 0008 913A      		cpi r25,lo8(-95)
 331 000a 00F4      		brsh .L20
 836:tmk_core/common/action.c ****             del_key(code);
 332               		.loc 1 836 13 is_stmt 1 view .LVU68
 333 000c 0E94 0000 		call del_key
 334               	.LVL28:
 837:tmk_core/common/action.c ****             send_keyboard_report();
 335               		.loc 1 837 13 view .LVU69
 336               	.L26:
 838:tmk_core/common/action.c ****         }
 839:tmk_core/common/action.c ****     else if
 840:tmk_core/common/action.c ****         IS_MOD(code) {
 841:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 842:tmk_core/common/action.c ****             send_keyboard_report();
 337               		.loc 1 842 13 view .LVU70
 338 0010 0C94 0000 		jmp send_keyboard_report
 339               	.LVL29:
 340               	.L20:
 839:tmk_core/common/action.c ****         IS_MOD(code) {
 341               		.loc 1 839 10 view .LVU71
 840:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 342               		.loc 1 840 9 is_stmt 0 view .LVU72
 343 0014 90E2      		ldi r25,lo8(32)
 344 0016 980F      		add r25,r24
 345 0018 9830      		cpi r25,lo8(8)
 346 001a 00F4      		brsh .L21
 841:tmk_core/common/action.c ****             send_keyboard_report();
 347               		.loc 1 841 13 is_stmt 1 view .LVU73
 841:tmk_core/common/action.c ****             send_keyboard_report();
 348               		.loc 1 841 22 is_stmt 0 view .LVU74
 349 001c 8770      		andi r24,lo8(7)
 350               	.LVL30:
 841:tmk_core/common/action.c ****             send_keyboard_report();
 351               		.loc 1 841 13 view .LVU75
 352 001e 91E0      		ldi r25,lo8(1)
 353 0020 00C0      		rjmp 2f
 354               		1:
 355 0022 990F      		lsl r25
 356               		2:
 357 0024 8A95      		dec r24
 358 0026 02F4      		brpl 1b
 359 0028 892F      		mov r24,r25
 360 002a 0E94 0000 		call del_mods
 361               	.LVL31:
 362 002e 00C0      		rjmp .L26
 363               	.LVL32:
 364               	.L21:
 843:tmk_core/common/action.c ****         }
 844:tmk_core/common/action.c ****     else if
 365               		.loc 1 844 10 is_stmt 1 view .LVU76
 845:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 366               		.loc 1 845 9 is_stmt 0 view .LVU77
 367 0030 9BE5      		ldi r25,lo8(91)
 368 0032 980F      		add r25,r24
 369 0034 9330      		cpi r25,lo8(3)
 370 0036 00F4      		brsh .L22
 371               		.loc 1 845 27 is_stmt 1 discriminator 1 view .LVU78
 372 0038 90E0      		ldi r25,0
 373 003a 80E0      		ldi r24,0
 374               	.LVL33:
 375               		.loc 1 845 27 is_stmt 0 discriminator 1 view .LVU79
 376 003c 0C94 0000 		jmp host_system_send
 377               	.LVL34:
 378               	.L22:
 846:tmk_core/common/action.c ****     else if
 379               		.loc 1 846 10 is_stmt 1 view .LVU80
 847:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 380               		.loc 1 847 9 is_stmt 0 view .LVU81
 381 0040 885A      		subi r24,lo8(-(88))
 382               	.LVL35:
 383               		.loc 1 847 9 view .LVU82
 384 0042 8731      		cpi r24,lo8(23)
 385 0044 00F4      		brsh .L18
 386               		.loc 1 847 29 is_stmt 1 discriminator 1 view .LVU83
 387 0046 90E0      		ldi r25,0
 388 0048 80E0      		ldi r24,0
 389               	.LVL36:
 390               		.loc 1 847 29 is_stmt 0 discriminator 1 view .LVU84
 391 004a 0C94 0000 		jmp host_consumer_send
 392               	.LVL37:
 393               	.L18:
 394               	/* epilogue start */
 848:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 849:tmk_core/common/action.c ****     else if
 850:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 851:tmk_core/common/action.c ****             mousekey_off(code);
 852:tmk_core/common/action.c ****             mousekey_send();
 853:tmk_core/common/action.c ****         }
 854:tmk_core/common/action.c **** #endif
 855:tmk_core/common/action.c **** }
 395               		.loc 1 855 1 view .LVU85
 396 004e 0895      		ret
 397               		.cfi_endproc
 398               	.LFE24:
 400               		.section	.text.tap_code,"ax",@progbits
 401               	.global	tap_code
 403               	tap_code:
 404               	.LVL38:
 405               	.LFB25:
 856:tmk_core/common/action.c **** 
 857:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 858:tmk_core/common/action.c ****  *
 859:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 860:tmk_core/common/action.c ****  */
 861:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 406               		.loc 1 861 29 is_stmt 1 view -0
 407               		.cfi_startproc
 408               		.loc 1 861 29 is_stmt 0 view .LVU87
 409 0000 CF93      		push r28
 410               	.LCFI5:
 411               		.cfi_def_cfa_offset 3
 412               		.cfi_offset 28, -2
 413               	/* prologue: function */
 414               	/* frame size = 0 */
 415               	/* stack size = 1 */
 416               	.L__stack_usage = 1
 417 0002 C82F      		mov r28,r24
 862:tmk_core/common/action.c ****     register_code(code);
 418               		.loc 1 862 5 is_stmt 1 view .LVU88
 419 0004 0E94 0000 		call register_code
 420               	.LVL39:
 863:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 421               		.loc 1 863 5 view .LVU89
 422               		.loc 1 863 8 is_stmt 0 view .LVU90
 423 0008 C933      		cpi r28,lo8(57)
 424 000a 01F4      		brne .L29
 864:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 425               		.loc 1 864 9 is_stmt 1 view .LVU91
 426               	.LVL40:
 427               	.LBB22:
 428               	.LBI22:
 429               		.file 3 "c:\\msys64\\home\\kyleo\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\util\\delay.h"
   1:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 430               		.loc 3 166 1 view .LVU92
 431               	.LBB23:
 167:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 432               		.loc 3 168 2 view .LVU93
 169:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 433               		.loc 3 172 2 view .LVU94
 173:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 434               		.loc 3 173 2 view .LVU95
 174:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 435               		.loc 3 174 2 view .LVU96
 175:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 436               		.loc 3 184 3 view .LVU97
 185:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 437               		.loc 3 187 2 view .LVU98
 438 000c 2FEF      		ldi r18,lo8(255999)
 439 000e 87EE      		ldi r24,hi8(255999)
 440 0010 93E0      		ldi r25,hlo8(255999)
 441 0012 2150      	1:	subi r18,1
 442 0014 8040      		sbci r24,0
 443 0016 9040      		sbci r25,0
 444 0018 01F4      		brne 1b
 445 001a 00C0      		rjmp .
 446 001c 0000      		nop
 447               	.LVL41:
 448               	.L29:
 449               		.loc 3 187 2 is_stmt 0 view .LVU99
 450               	.LBE23:
 451               	.LBE22:
 865:tmk_core/common/action.c ****     } else {
 866:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 867:tmk_core/common/action.c ****     }
 868:tmk_core/common/action.c ****     unregister_code(code);
 452               		.loc 1 868 5 is_stmt 1 view .LVU100
 453 001e 8C2F      		mov r24,r28
 454               	/* epilogue start */
 869:tmk_core/common/action.c **** }
 455               		.loc 1 869 1 is_stmt 0 view .LVU101
 456 0020 CF91      		pop r28
 457               	.LVL42:
 868:tmk_core/common/action.c **** }
 458               		.loc 1 868 5 view .LVU102
 459 0022 0C94 0000 		jmp unregister_code
 460               	.LVL43:
 868:tmk_core/common/action.c **** }
 461               		.loc 1 868 5 view .LVU103
 462               		.cfi_endproc
 463               	.LFE25:
 465               		.section	.text.register_mods,"ax",@progbits
 466               	.global	register_mods
 468               	register_mods:
 469               	.LVL44:
 470               	.LFB26:
 870:tmk_core/common/action.c **** 
 871:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 872:tmk_core/common/action.c ****  *
 873:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 874:tmk_core/common/action.c ****  */
 875:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 471               		.loc 1 875 34 is_stmt 1 view -0
 472               		.cfi_startproc
 473               	/* prologue: function */
 474               	/* frame size = 0 */
 475               	/* stack size = 0 */
 476               	.L__stack_usage = 0
 876:tmk_core/common/action.c ****     if (mods) {
 477               		.loc 1 876 5 view .LVU105
 478               		.loc 1 876 8 is_stmt 0 view .LVU106
 479 0000 8823      		tst r24
 480 0002 01F0      		breq .L30
 877:tmk_core/common/action.c ****         add_mods(mods);
 481               		.loc 1 877 9 is_stmt 1 view .LVU107
 482 0004 0E94 0000 		call add_mods
 483               	.LVL45:
 878:tmk_core/common/action.c ****         send_keyboard_report();
 484               		.loc 1 878 9 view .LVU108
 485 0008 0C94 0000 		jmp send_keyboard_report
 486               	.LVL46:
 487               	.L30:
 488               	/* epilogue start */
 879:tmk_core/common/action.c ****     }
 880:tmk_core/common/action.c **** }
 489               		.loc 1 880 1 is_stmt 0 view .LVU109
 490 000c 0895      		ret
 491               		.cfi_endproc
 492               	.LFE26:
 494               		.section	.text.unregister_mods,"ax",@progbits
 495               	.global	unregister_mods
 497               	unregister_mods:
 498               	.LVL47:
 499               	.LFB27:
 881:tmk_core/common/action.c **** 
 882:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 883:tmk_core/common/action.c ****  *
 884:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 885:tmk_core/common/action.c ****  */
 886:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 500               		.loc 1 886 36 is_stmt 1 view -0
 501               		.cfi_startproc
 502               	/* prologue: function */
 503               	/* frame size = 0 */
 504               	/* stack size = 0 */
 505               	.L__stack_usage = 0
 887:tmk_core/common/action.c ****     if (mods) {
 506               		.loc 1 887 5 view .LVU111
 507               		.loc 1 887 8 is_stmt 0 view .LVU112
 508 0000 8823      		tst r24
 509 0002 01F0      		breq .L32
 888:tmk_core/common/action.c ****         del_mods(mods);
 510               		.loc 1 888 9 is_stmt 1 view .LVU113
 511 0004 0E94 0000 		call del_mods
 512               	.LVL48:
 889:tmk_core/common/action.c ****         send_keyboard_report();
 513               		.loc 1 889 9 view .LVU114
 514 0008 0C94 0000 		jmp send_keyboard_report
 515               	.LVL49:
 516               	.L32:
 517               	/* epilogue start */
 890:tmk_core/common/action.c ****     }
 891:tmk_core/common/action.c **** }
 518               		.loc 1 891 1 is_stmt 0 view .LVU115
 519 000c 0895      		ret
 520               		.cfi_endproc
 521               	.LFE27:
 523               		.section	.text.process_action,"ax",@progbits
 524               	.global	process_action
 526               	process_action:
 527               	.LVL50:
 528               	.LFB22:
 213:tmk_core/common/action.c ****     keyevent_t event = record->event;
 529               		.loc 1 213 59 is_stmt 1 view -0
 530               		.cfi_startproc
 213:tmk_core/common/action.c ****     keyevent_t event = record->event;
 531               		.loc 1 213 59 is_stmt 0 view .LVU117
 532 0000 BF92      		push r11
 533               	.LCFI6:
 534               		.cfi_def_cfa_offset 3
 535               		.cfi_offset 11, -2
 536 0002 CF92      		push r12
 537               	.LCFI7:
 538               		.cfi_def_cfa_offset 4
 539               		.cfi_offset 12, -3
 540 0004 DF92      		push r13
 541               	.LCFI8:
 542               		.cfi_def_cfa_offset 5
 543               		.cfi_offset 13, -4
 544 0006 EF92      		push r14
 545               	.LCFI9:
 546               		.cfi_def_cfa_offset 6
 547               		.cfi_offset 14, -5
 548 0008 FF92      		push r15
 549               	.LCFI10:
 550               		.cfi_def_cfa_offset 7
 551               		.cfi_offset 15, -6
 552 000a 0F93      		push r16
 553               	.LCFI11:
 554               		.cfi_def_cfa_offset 8
 555               		.cfi_offset 16, -7
 556 000c 1F93      		push r17
 557               	.LCFI12:
 558               		.cfi_def_cfa_offset 9
 559               		.cfi_offset 17, -8
 560 000e CF93      		push r28
 561               	.LCFI13:
 562               		.cfi_def_cfa_offset 10
 563               		.cfi_offset 28, -9
 564 0010 DF93      		push r29
 565               	.LCFI14:
 566               		.cfi_def_cfa_offset 11
 567               		.cfi_offset 29, -10
 568               	/* prologue: function */
 569               	/* frame size = 0 */
 570               	/* stack size = 9 */
 571               	.L__stack_usage = 9
 572 0012 6C01      		movw r12,r24
 573 0014 D62F      		mov r29,r22
 213:tmk_core/common/action.c ****     keyevent_t event = record->event;
 574               		.loc 1 213 59 view .LVU118
 575 0016 C72F      		mov r28,r23
 214:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 576               		.loc 1 214 5 is_stmt 1 view .LVU119
 577               	.LVL51:
 216:tmk_core/common/action.c **** #endif
 578               		.loc 1 216 5 view .LVU120
 216:tmk_core/common/action.c **** #endif
 579               		.loc 1 216 36 is_stmt 0 view .LVU121
 580 0018 FC01      		movw r30,r24
 581 001a 0581      		ldd r16,Z+5
 582 001c 0295      		swap r16
 583 001e 0F70      		andi r16,lo8(15)
 584               	.LVL52:
 219:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 585               		.loc 1 219 5 is_stmt 1 view .LVU122
 219:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 586               		.loc 1 219 14 is_stmt 0 view .LVU123
 587 0020 1281      		ldd r17,Z+2
 219:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 588               		.loc 1 219 8 view .LVU124
 589 0022 1111      		cpse r17,__zero_reg__
 221:tmk_core/common/action.c ****     }
 590               		.loc 1 221 9 is_stmt 1 view .LVU125
 591 0024 0E94 0000 		call clear_weak_mods
 592               	.LVL53:
 593               	.L35:
 225:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 594               		.loc 1 225 5 view .LVU126
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 595               		.loc 1 227 5 view .LVU127
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 596               		.loc 1 227 9 is_stmt 0 view .LVU128
 597 0028 0E94 0000 		call is_oneshot_layer_active
 598               	.LVL54:
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 599               		.loc 1 227 9 view .LVU129
 600 002c E82E      		mov r14,r24
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 601               		.loc 1 227 8 view .LVU130
 602 002e 8823      		tst r24
 603 0030 01F0      		breq .L36
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 604               		.loc 1 227 35 discriminator 1 view .LVU131
 605 0032 1123      		tst r17
 606 0034 01F0      		breq .L109
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 607               		.loc 1 227 55 discriminator 2 view .LVU132
 608 0036 80E2      		ldi r24,lo8(32)
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 609               		.loc 1 227 55 discriminator 2 view .LVU133
 610 0038 8D0F      		add r24,r29
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 611               		.loc 1 227 52 discriminator 2 view .LVU134
 612 003a 8830      		cpi r24,lo8(8)
 613 003c 00F0      		brlo .L109
 228:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 614               		.loc 1 228 9 is_stmt 1 view .LVU135
 615 003e 82E0      		ldi r24,lo8(2)
 616 0040 0E94 0000 		call clear_oneshot_layer_state
 617               	.LVL55:
 229:tmk_core/common/action.c ****     }
 618               		.loc 1 229 9 view .LVU136
 229:tmk_core/common/action.c ****     }
 619               		.loc 1 229 31 is_stmt 0 view .LVU137
 620 0044 0E94 0000 		call is_oneshot_layer_active
 621               	.LVL56:
 229:tmk_core/common/action.c ****     }
 622               		.loc 1 229 9 view .LVU138
 623 0048 91E0      		ldi r25,lo8(1)
 624 004a E82E      		mov r14,r24
 625 004c E926      		eor r14,r25
 626               	.LVL57:
 627               	.L36:
 233:tmk_core/common/action.c ****         /* Key and Mods */
 628               		.loc 1 233 5 is_stmt 1 view .LVU139
 233:tmk_core/common/action.c ****         /* Key and Mods */
 629               		.loc 1 233 24 is_stmt 0 view .LVU140
 630 004e BC2E      		mov r11,r28
 631 0050 B294      		swap r11
 632 0052 9FE0      		ldi r25,lo8(15)
 633 0054 B922      		and r11,r25
 233:tmk_core/common/action.c ****         /* Key and Mods */
 634               		.loc 1 233 5 view .LVU141
 635 0056 FBE0      		ldi r31,lo8(11)
 636 0058 FB15      		cp r31,r11
 637 005a 00F0      		brlo .L37
 638 005c EB2D      		mov r30,r11
 639 005e F0E0      		ldi r31,0
 640 0060 E050      		subi r30,lo8(-(gs(.L39)))
 641 0062 F040      		sbci r31,hi8(-(gs(.L39)))
 642 0064 0C94 0000 		jmp __tablejump2__
 643               		.section	.jumptables.gcc.process_action,"a",@progbits
 644               		.p2align	1
 645               	.L39:
 646 0000 0000      		.word gs(.L44)
 647 0002 0000      		.word gs(.L44)
 648 0004 0000      		.word gs(.L43)
 649 0006 0000      		.word gs(.L43)
 650 0008 0000      		.word gs(.L42)
 651 000a 0000      		.word gs(.L37)
 652 000c 0000      		.word gs(.L37)
 653 000e 0000      		.word gs(.L37)
 654 0010 0000      		.word gs(.L41)
 655 0012 0000      		.word gs(.L40)
 656 0014 0000      		.word gs(.L38)
 657 0016 0000      		.word gs(.L38)
 658               		.section	.text.process_action
 659               	.LVL58:
 660               	.L109:
 225:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 661               		.loc 1 225 10 view .LVU142
 662 0068 E12C      		mov r14,__zero_reg__
 663 006a 00C0      		rjmp .L36
 664               	.LVL59:
 665               	.L44:
 666               	.LBB24:
 237:tmk_core/common/action.c ****             if (event.pressed) {
 667               		.loc 1 237 13 is_stmt 1 view .LVU143
 668 006c 0C2F      		mov r16,r28
 669               	.LVL60:
 237:tmk_core/common/action.c ****             if (event.pressed) {
 670               		.loc 1 237 13 is_stmt 0 view .LVU144
 671 006e 0F70      		andi r16,lo8(15)
 237:tmk_core/common/action.c ****             if (event.pressed) {
 672               		.loc 1 237 44 view .LVU145
 673 0070 C07F      		andi r28,lo8(-16)
 674               	.LVL61:
 237:tmk_core/common/action.c ****             if (event.pressed) {
 675               		.loc 1 237 21 view .LVU146
 676 0072 01F0      		breq .L45
 237:tmk_core/common/action.c ****             if (event.pressed) {
 677               		.loc 1 237 21 discriminator 2 view .LVU147
 678 0074 0295      		swap r16
 679 0076 007F      		andi r16,lo8(-16)
 680               	.L45:
 681               	.LVL62:
 238:tmk_core/common/action.c ****                 if (mods) {
 682               		.loc 1 238 13 is_stmt 1 discriminator 4 view .LVU148
 238:tmk_core/common/action.c ****                 if (mods) {
 683               		.loc 1 238 16 is_stmt 0 discriminator 4 view .LVU149
 684 0078 1123      		tst r17
 685 007a 01F0      		breq .L46
 239:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 686               		.loc 1 239 17 is_stmt 1 view .LVU150
 239:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 687               		.loc 1 239 20 is_stmt 0 view .LVU151
 688 007c 0023      		tst r16
 689 007e 01F0      		breq .L138
 240:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 690               		.loc 1 240 21 is_stmt 1 view .LVU152
 240:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 691               		.loc 1 240 25 is_stmt 0 view .LVU153
 692 0080 80E2      		ldi r24,lo8(32)
 693 0082 8D0F      		add r24,r29
 240:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 694               		.loc 1 240 24 view .LVU154
 695 0084 8830      		cpi r24,lo8(8)
 696 0086 00F0      		brlo .L48
 240:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 697               		.loc 1 240 49 discriminator 1 view .LVU155
 698 0088 D111      		cpse r29,__zero_reg__
 699 008a 00C0      		rjmp .L49
 700               	.L48:
 244:tmk_core/common/action.c ****                     } else {
 701               		.loc 1 244 25 is_stmt 1 view .LVU156
 702 008c 802F      		mov r24,r16
 703 008e 0E94 0000 		call add_mods
 704               	.LVL63:
 705               	.L50:
 248:tmk_core/common/action.c ****                 }
 706               		.loc 1 248 21 view .LVU157
 707 0092 0E94 0000 		call send_keyboard_report
 708               	.LVL64:
 250:tmk_core/common/action.c ****             } else {
 709               		.loc 1 250 17 view .LVU158
 710               	.L138:
 250:tmk_core/common/action.c ****             } else {
 711               		.loc 1 250 17 is_stmt 0 view .LVU159
 712               	.LBE24:
 541:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 713               		.loc 1 541 75 is_stmt 1 view .LVU160
 542:tmk_core/common/action.c ****                         } else {
 714               		.loc 1 542 29 view .LVU161
 715 0096 8D2F      		mov r24,r29
 716 0098 0E94 0000 		call register_code
 717               	.LVL65:
 718 009c 00C0      		rjmp .L37
 719               	.LVL66:
 720               	.L49:
 721               	.LBB25:
 246:tmk_core/common/action.c ****                     }
 722               		.loc 1 246 25 view .LVU162
 723 009e 802F      		mov r24,r16
 724 00a0 0E94 0000 		call add_weak_mods
 725               	.LVL67:
 726 00a4 00C0      		rjmp .L50
 727               	.L46:
 252:tmk_core/common/action.c ****                 if (mods) {
 728               		.loc 1 252 17 view .LVU163
 729 00a6 8D2F      		mov r24,r29
 730 00a8 0E94 0000 		call unregister_code
 731               	.LVL68:
 253:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 732               		.loc 1 253 17 view .LVU164
 253:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 733               		.loc 1 253 20 is_stmt 0 view .LVU165
 734 00ac 0023      		tst r16
 735 00ae 01F0      		breq .L37
 254:tmk_core/common/action.c ****                         del_mods(mods);
 736               		.loc 1 254 21 is_stmt 1 view .LVU166
 254:tmk_core/common/action.c ****                         del_mods(mods);
 737               		.loc 1 254 25 is_stmt 0 view .LVU167
 738 00b0 80E2      		ldi r24,lo8(32)
 739 00b2 8D0F      		add r24,r29
 254:tmk_core/common/action.c ****                         del_mods(mods);
 740               		.loc 1 254 24 view .LVU168
 741 00b4 8830      		cpi r24,lo8(8)
 742 00b6 00F0      		brlo .L52
 254:tmk_core/common/action.c ****                         del_mods(mods);
 743               		.loc 1 254 49 discriminator 1 view .LVU169
 744 00b8 D111      		cpse r29,__zero_reg__
 745 00ba 00C0      		rjmp .L53
 746               	.L52:
 255:tmk_core/common/action.c ****                     } else {
 747               		.loc 1 255 25 is_stmt 1 view .LVU170
 748 00bc 802F      		mov r24,r16
 749 00be 0E94 0000 		call del_mods
 750               	.LVL69:
 751               	.L54:
 259:tmk_core/common/action.c ****                 }
 752               		.loc 1 259 21 view .LVU171
 753 00c2 0E94 0000 		call send_keyboard_report
 754               	.LVL70:
 755               	.L37:
 259:tmk_core/common/action.c ****                 }
 756               		.loc 1 259 21 is_stmt 0 view .LVU172
 757               	.LBE25:
 646:tmk_core/common/action.c ****         case ACT_LAYER:
 758               		.loc 1 646 5 is_stmt 1 view .LVU173
 759 00c6 2B2D      		mov r18,r11
 760 00c8 2850      		subi r18,8
 761 00ca 330B      		sbc r19,r19
 762 00cc 2430      		cpi r18,4
 763 00ce 3105      		cpc r19,__zero_reg__
 764 00d0 00F4      		brsh .L104
 653:tmk_core/common/action.c ****             break;
 765               		.loc 1 653 13 view .LVU174
 766 00d2 0E94 0000 		call host_keyboard_leds
 767               	.LVL71:
 768 00d6 0E94 0000 		call led_set
 769               	.LVL72:
 654:tmk_core/common/action.c ****         default:
 770               		.loc 1 654 13 view .LVU175
 771               	.L104:
 688:tmk_core/common/action.c ****         record->event.pressed = false;
 772               		.loc 1 688 5 view .LVU176
 688:tmk_core/common/action.c ****         record->event.pressed = false;
 773               		.loc 1 688 8 is_stmt 0 view .LVU177
 774 00da EE20      		tst r14
 775 00dc 01F4      		brne .+2
 776 00de 00C0      		rjmp .L34
 688:tmk_core/common/action.c ****         record->event.pressed = false;
 777               		.loc 1 688 33 discriminator 1 view .LVU178
 778 00e0 0E94 0000 		call get_oneshot_layer_state
 779               	.LVL73:
 688:tmk_core/common/action.c ****         record->event.pressed = false;
 780               		.loc 1 688 28 discriminator 1 view .LVU179
 781 00e4 80FD      		sbrc r24,0
 782 00e6 00C0      		rjmp .L34
 689:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 783               		.loc 1 689 9 is_stmt 1 view .LVU180
 689:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 784               		.loc 1 689 31 is_stmt 0 view .LVU181
 785 00e8 F601      		movw r30,r12
 786 00ea 1282      		std Z+2,__zero_reg__
 690:tmk_core/common/action.c ****         process_record(record);
 787               		.loc 1 690 9 is_stmt 1 view .LVU182
 788 00ec 0E94 0000 		call get_oneshot_layer
 789               	.LVL74:
 790 00f0 0E94 0000 		call layer_on
 791               	.LVL75:
 691:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 792               		.loc 1 691 9 view .LVU183
 793 00f4 C601      		movw r24,r12
 794 00f6 0E94 0000 		call process_record
 795               	.LVL76:
 692:tmk_core/common/action.c ****     }
 796               		.loc 1 692 9 view .LVU184
 797 00fa 0E94 0000 		call get_oneshot_layer
 798               	.LVL77:
 799               	/* epilogue start */
 695:tmk_core/common/action.c **** 
 800               		.loc 1 695 1 is_stmt 0 view .LVU185
 801 00fe DF91      		pop r29
 802               	.LVL78:
 695:tmk_core/common/action.c **** 
 803               		.loc 1 695 1 view .LVU186
 804 0100 CF91      		pop r28
 695:tmk_core/common/action.c **** 
 805               		.loc 1 695 1 view .LVU187
 806 0102 1F91      		pop r17
 807 0104 0F91      		pop r16
 808 0106 FF90      		pop r15
 809 0108 EF90      		pop r14
 810               	.LVL79:
 695:tmk_core/common/action.c **** 
 811               		.loc 1 695 1 view .LVU188
 812 010a DF90      		pop r13
 813 010c CF90      		pop r12
 814               	.LVL80:
 695:tmk_core/common/action.c **** 
 815               		.loc 1 695 1 view .LVU189
 816 010e BF90      		pop r11
 692:tmk_core/common/action.c ****     }
 817               		.loc 1 692 9 view .LVU190
 818 0110 0C94 0000 		jmp layer_off
 819               	.LVL81:
 820               	.L53:
 821               	.LBB26:
 257:tmk_core/common/action.c ****                     }
 822               		.loc 1 257 25 is_stmt 1 view .LVU191
 823 0114 802F      		mov r24,r16
 824 0116 0E94 0000 		call del_weak_mods
 825               	.LVL82:
 826 011a 00C0      		rjmp .L54
 827               	.LVL83:
 828               	.L43:
 257:tmk_core/common/action.c ****                     }
 829               		.loc 1 257 25 is_stmt 0 view .LVU192
 830               	.LBE26:
 831               	.LBB27:
 266:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 832               		.loc 1 266 13 is_stmt 1 view .LVU193
 833 011c 2C2F      		mov r18,r28
 834 011e 2F70      		andi r18,lo8(15)
 835 0120 F22E      		mov r15,r18
 266:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 836               		.loc 1 266 44 is_stmt 0 view .LVU194
 837 0122 C07F      		andi r28,lo8(-16)
 838               	.LVL84:
 266:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 839               		.loc 1 266 21 view .LVU195
 840 0124 C032      		cpi r28,lo8(32)
 841 0126 01F0      		breq .L55
 266:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 842               		.loc 1 266 21 discriminator 2 view .LVU196
 843 0128 F294      		swap r15
 844 012a 80EF      		ldi r24,lo8(-16)
 845 012c F822      		and r15,r24
 846               	.L55:
 847               	.LVL85:
 267:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 848               		.loc 1 267 13 is_stmt 1 discriminator 4 view .LVU197
 849 012e DD23      		tst r29
 850 0130 01F0      		breq .L56
 851 0132 D130      		cpi r29,lo8(1)
 852 0134 01F0      		breq .L57
 322:tmk_core/common/action.c ****                         if (tap_count > 0) {
 853               		.loc 1 322 21 view .LVU198
 322:tmk_core/common/action.c ****                         if (tap_count > 0) {
 854               		.loc 1 322 24 is_stmt 0 view .LVU199
 855 0136 1123      		tst r17
 856 0138 01F0      		breq .L65
 323:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 857               		.loc 1 323 25 is_stmt 1 view .LVU200
 323:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 858               		.loc 1 323 28 is_stmt 0 view .LVU201
 859 013a 0023      		tst r16
 860 013c 01F0      		breq .L66
 325:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 861               		.loc 1 325 29 is_stmt 1 view .LVU202
 329:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 862               		.loc 1 329 33 is_stmt 0 view .LVU203
 863 013e F601      		movw r30,r12
 864 0140 8581      		ldd r24,Z+5
 325:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 865               		.loc 1 325 32 view .LVU204
 866 0142 80FF      		sbrs r24,0
 867 0144 00C0      		rjmp .L138
 330:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 868               		.loc 1 330 76 is_stmt 1 view .LVU205
 332:tmk_core/common/action.c ****                                 register_mods(mods);
 869               		.loc 1 332 33 view .LVU206
 332:tmk_core/common/action.c ****                                 register_mods(mods);
 870               		.loc 1 332 51 is_stmt 0 view .LVU207
 871 0146 8F70      		andi r24,lo8(15)
 872 0148 8583      		std Z+5,r24
 333:tmk_core/common/action.c ****                             } else
 873               		.loc 1 333 33 is_stmt 1 view .LVU208
 874 014a 00C0      		rjmp .L66
 875               	.L56:
 271:tmk_core/common/action.c ****                         if (tap_count == 0) {
 876               		.loc 1 271 21 view .LVU209
 271:tmk_core/common/action.c ****                         if (tap_count == 0) {
 877               		.loc 1 271 24 is_stmt 0 view .LVU210
 878 014c 1123      		tst r17
 879 014e 01F0      		breq .L59
 272:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 880               		.loc 1 272 25 is_stmt 1 view .LVU211
 272:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 881               		.loc 1 272 28 is_stmt 0 view .LVU212
 882 0150 0111      		cpse r16,__zero_reg__
 883 0152 00C0      		rjmp .L60
 884               	.L61:
 286:tmk_core/common/action.c ****                         }
 885               		.loc 1 286 29 is_stmt 1 view .LVU213
 286:tmk_core/common/action.c ****                         }
 886               		.loc 1 286 50 is_stmt 0 view .LVU214
 887 0154 0E94 0000 		call get_oneshot_mods
 888               	.LVL86:
 286:tmk_core/common/action.c ****                         }
 889               		.loc 1 286 29 view .LVU215
 890 0158 8F29      		or r24,r15
 891               	.LVL87:
 892               	.L137:
 286:tmk_core/common/action.c ****                         }
 893               		.loc 1 286 29 view .LVU216
 894               	.LBE27:
 468:tmk_core/common/action.c ****             } else {
 895               		.loc 1 468 17 view .LVU217
 896 015a 0E94 0000 		call register_mods
 897               	.LVL88:
 898 015e 00C0      		rjmp .L37
 899               	.LVL89:
 900               	.L60:
 901               	.LBB30:
 275:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 902               		.loc 1 275 32 is_stmt 1 view .LVU218
 275:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 903               		.loc 1 275 35 is_stmt 0 view .LVU219
 904 0160 0130      		cpi r16,lo8(1)
 905 0162 01F4      		brne .L61
 276:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 906               		.loc 1 276 65 is_stmt 1 view .LVU220
 277:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 907               		.loc 1 277 29 view .LVU221
 277:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 908               		.loc 1 277 53 is_stmt 0 view .LVU222
 909 0164 0E94 0000 		call get_oneshot_mods
 910               	.LVL90:
 277:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 911               		.loc 1 277 29 view .LVU223
 912 0168 8F29      		or r24,r15
 913 016a 0E94 0000 		call set_oneshot_mods
 914               	.LVL91:
 915 016e 00C0      		rjmp .L37
 916               	.L59:
 289:tmk_core/common/action.c ****                             clear_oneshot_mods();
 917               		.loc 1 289 25 is_stmt 1 view .LVU224
 289:tmk_core/common/action.c ****                             clear_oneshot_mods();
 918               		.loc 1 289 28 is_stmt 0 view .LVU225
 919 0170 0111      		cpse r16,__zero_reg__
 920 0172 00C0      		rjmp .L62
 921               	.L140:
 304:tmk_core/common/action.c ****                             unregister_mods(mods);
 922               		.loc 1 304 29 is_stmt 1 view .LVU226
 923 0174 0E94 0000 		call clear_oneshot_mods
 924               	.LVL92:
 305:tmk_core/common/action.c ****                         }
 925               		.loc 1 305 29 view .LVU227
 926               	.L68:
 352:tmk_core/common/action.c ****                             unregister_mods(mods);
 927               		.loc 1 352 67 view .LVU228
 353:tmk_core/common/action.c ****                         }
 928               		.loc 1 353 29 view .LVU229
 929 0178 8F2D      		mov r24,r15
 930 017a 0E94 0000 		call unregister_mods
 931               	.LVL93:
 932 017e 00C0      		rjmp .L37
 933               	.L62:
 292:tmk_core/common/action.c ****                             // Retain Oneshot mods
 934               		.loc 1 292 32 view .LVU230
 292:tmk_core/common/action.c ****                             // Retain Oneshot mods
 935               		.loc 1 292 35 is_stmt 0 view .LVU231
 936 0180 0130      		cpi r16,lo8(1)
 937 0182 01F4      		brne .+2
 938 0184 00C0      		rjmp .L37
 939 0186 00C0      		rjmp .L140
 940               	.L57:
 311:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 941               		.loc 1 311 21 is_stmt 1 view .LVU232
 311:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 942               		.loc 1 311 24 is_stmt 0 view .LVU233
 943 0188 1123      		tst r17
 944 018a 01F0      		breq .L64
 312:tmk_core/common/action.c ****                             register_mods(mods);
 945               		.loc 1 312 25 is_stmt 1 view .LVU234
 312:tmk_core/common/action.c ****                             register_mods(mods);
 946               		.loc 1 312 28 is_stmt 0 view .LVU235
 947 018c 0630      		cpi r16,lo8(6)
 948 018e 00F0      		brlo .+2
 949 0190 00C0      		rjmp .L37
 950               	.L66:
 341:tmk_core/common/action.c ****                             register_mods(mods);
 951               		.loc 1 341 67 is_stmt 1 view .LVU236
 342:tmk_core/common/action.c ****                         }
 952               		.loc 1 342 29 view .LVU237
 953 0192 8F2D      		mov r24,r15
 954 0194 00C0      		rjmp .L137
 955               	.L64:
 316:tmk_core/common/action.c ****                             unregister_mods(mods);
 956               		.loc 1 316 25 view .LVU238
 316:tmk_core/common/action.c ****                             unregister_mods(mods);
 957               		.loc 1 316 28 is_stmt 0 view .LVU239
 958 0196 0530      		cpi r16,lo8(5)
 959 0198 00F0      		brlo .+2
 960 019a 00C0      		rjmp .L37
 961 019c 00C0      		rjmp .L68
 962               	.L65:
 345:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 963               		.loc 1 345 25 is_stmt 1 view .LVU240
 345:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 964               		.loc 1 345 28 is_stmt 0 view .LVU241
 965 019e 0023      		tst r16
 966 01a0 01F0      		breq .L68
 346:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 967               		.loc 1 346 71 is_stmt 1 view .LVU242
 347:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 968               		.loc 1 347 29 view .LVU243
 347:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 969               		.loc 1 347 32 is_stmt 0 view .LVU244
 970 01a2 D933      		cpi r29,lo8(57)
 971 01a4 01F4      		brne .L103
 348:tmk_core/common/action.c ****                             }
 972               		.loc 1 348 33 is_stmt 1 view .LVU245
 973               	.LVL94:
 974               	.LBB28:
 975               	.LBI28:
 166:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 976               		.loc 3 166 1 view .LVU246
 977               	.LBB29:
 168:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 978               		.loc 3 168 2 view .LVU247
 172:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 979               		.loc 3 172 2 view .LVU248
 173:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 980               		.loc 3 173 2 view .LVU249
 174:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 981               		.loc 3 174 2 view .LVU250
 184:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 982               		.loc 3 184 3 view .LVU251
 983               		.loc 3 187 2 view .LVU252
 984 01a6 FFEF      		ldi r31,lo8(255999)
 985 01a8 27EE      		ldi r18,hi8(255999)
 986 01aa 33E0      		ldi r19,hlo8(255999)
 987 01ac F150      	1:	subi r31,1
 988 01ae 2040      		sbci r18,0
 989 01b0 3040      		sbci r19,0
 990 01b2 01F4      		brne 1b
 991               	.LVL95:
 992               	.L141:
 993               		.loc 3 187 2 is_stmt 0 view .LVU253
 994               	.LBE29:
 995               	.LBE28:
 996               	.LBE30:
 997               	.LBB31:
 998               	.LBB32:
 999 01b4 00C0      		rjmp .
 1000 01b6 0000      		nop
 1001               	.L103:
 1002               	.LBE32:
 1003               	.LBE31:
 555:tmk_core/common/action.c ****                         } else {
 1004               		.loc 1 555 29 is_stmt 1 view .LVU254
 1005 01b8 8D2F      		mov r24,r29
 1006 01ba 0E94 0000 		call unregister_code
 1007               	.LVL96:
 1008 01be 00C0      		rjmp .L37
 1009               	.L42:
 363:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1010               		.loc 1 363 13 view .LVU255
 363:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1011               		.loc 1 363 33 is_stmt 0 view .LVU256
 1012 01c0 8C2F      		mov r24,r28
 1013 01c2 8695      		lsr r24
 1014 01c4 8695      		lsr r24
 1015 01c6 8370      		andi r24,lo8(3)
 1016 01c8 01F0      		breq .L70
 1017 01ca 8130      		cpi r24,lo8(1)
 1018 01cc 01F0      		breq .+2
 1019 01ce 00C0      		rjmp .L37
 372:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1020               		.loc 1 372 21 is_stmt 1 view .LVU257
 373:tmk_core/common/action.c ****                     } else {
 1021               		.loc 1 373 25 is_stmt 0 view .LVU258
 1022 01d0 8D2F      		mov r24,r29
 1023 01d2 9C2F      		mov r25,r28
 1024 01d4 9370      		andi r25,lo8(3)
 372:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1025               		.loc 1 372 24 view .LVU259
 1026 01d6 1111      		cpse r17,__zero_reg__
 1027 01d8 00C0      		rjmp .L139
 375:tmk_core/common/action.c ****                     }
 1028               		.loc 1 375 25 is_stmt 1 view .LVU260
 1029 01da 90E0      		ldi r25,0
 1030 01dc 80E0      		ldi r24,0
 1031               	.L139:
 1032 01de 0E94 0000 		call host_consumer_send
 1033               	.LVL97:
 1034 01e2 00C0      		rjmp .L37
 1035               	.L70:
 365:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1036               		.loc 1 365 21 view .LVU261
 366:tmk_core/common/action.c ****                     } else {
 1037               		.loc 1 366 25 is_stmt 0 view .LVU262
 1038 01e4 8D2F      		mov r24,r29
 1039 01e6 9C2F      		mov r25,r28
 1040 01e8 9370      		andi r25,lo8(3)
 365:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1041               		.loc 1 365 24 view .LVU263
 1042 01ea 1111      		cpse r17,__zero_reg__
 1043 01ec 00C0      		rjmp .L135
 368:tmk_core/common/action.c ****                     }
 1044               		.loc 1 368 25 is_stmt 1 view .LVU264
 1045 01ee 90E0      		ldi r25,0
 1046 01f0 80E0      		ldi r24,0
 1047               	.L135:
 1048 01f2 0E94 0000 		call host_system_send
 1049               	.LVL98:
 1050 01f6 00C0      		rjmp .L37
 1051               	.L41:
 421:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1052               		.loc 1 421 13 view .LVU265
 421:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1053               		.loc 1 421 39 is_stmt 0 view .LVU266
 1054 01f8 8C2F      		mov r24,r28
 1055 01fa 8370      		andi r24,lo8(3)
 421:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1056               		.loc 1 421 16 view .LVU267
 1057 01fc 01F0      		breq .+2
 1058 01fe 00C0      		rjmp .L74
 423:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1059               		.loc 1 423 17 is_stmt 1 view .LVU268
 423:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1060               		.loc 1 423 20 is_stmt 0 view .LVU269
 1061 0200 1111      		cpse r17,__zero_reg__
 1062 0202 00C0      		rjmp .L37
 1063               	.LBB34:
 424:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1064               		.loc 1 424 21 is_stmt 1 view .LVU270
 1065               	.LVL99:
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1066               		.loc 1 425 21 view .LVU271
 424:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1067               		.loc 1 424 61 is_stmt 0 view .LVU272
 1068 0204 4D2F      		mov r20,r29
 1069 0206 4295      		swap r20
 1070 0208 4695      		lsr r20
 1071 020a 4770      		andi r20,lo8(7)
 424:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1072               		.loc 1 424 35 view .LVU273
 1073 020c 440F      		lsl r20
 1074 020e 440F      		lsl r20
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1075               		.loc 1 425 77 view .LVU274
 1076 0210 0D2F      		mov r16,r29
 1077               	.LVL100:
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1078               		.loc 1 425 77 view .LVU275
 1079 0212 0F70      		andi r16,lo8(15)
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1080               		.loc 1 425 44 view .LVU276
 1081 0214 10E0      		ldi r17,0
 1082               	.LVL101:
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1083               		.loc 1 425 44 view .LVU277
 1084 0216 30E0      		ldi r19,0
 1085 0218 20E0      		ldi r18,0
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1086               		.loc 1 425 35 view .LVU278
 1087 021a 042E      		mov r0,r20
 1088 021c 00C0      		rjmp 2f
 1089               		1:
 1090 021e 000F      		lsl r16
 1091 0220 111F      		rol r17
 1092 0222 221F      		rol r18
 1093 0224 331F      		rol r19
 1094               		2:
 1095 0226 0A94      		dec r0
 1096 0228 02F4      		brpl 1b
 1097               	.LVL102:
 426:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1098               		.loc 1 426 21 is_stmt 1 view .LVU279
 426:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1099               		.loc 1 426 104 is_stmt 0 view .LVU280
 1100 022a 60E0      		ldi r22,0
 1101 022c 70E0      		ldi r23,0
 1102 022e CB01      		movw r24,r22
 1103 0230 D4FF      		sbrs r29,4
 1104 0232 00C0      		rjmp .L75
 426:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1105               		.loc 1 426 94 discriminator 1 view .LVU281
 1106 0234 6FE0      		ldi r22,lo8(15)
 1107 0236 70E0      		ldi r23,0
 1108 0238 80E0      		ldi r24,0
 1109 023a 90E0      		ldi r25,0
 1110 023c 00C0      		rjmp 2f
 1111               		1:
 1112 023e 660F      		lsl r22
 1113 0240 771F      		rol r23
 1114 0242 881F      		rol r24
 1115 0244 991F      		rol r25
 1116               		2:
 1117 0246 4A95      		dec r20
 1118 0248 02F4      		brpl 1b
 426:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1119               		.loc 1 426 104 discriminator 1 view .LVU282
 1120 024a 6095      		com r22
 1121 024c 7095      		com r23
 1122 024e 8095      		com r24
 1123 0250 9095      		com r25
 1124               	.L75:
 1125               	.LVL103:
 427:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1126               		.loc 1 427 21 is_stmt 1 discriminator 4 view .LVU283
 427:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1127               		.loc 1 427 47 is_stmt 0 discriminator 4 view .LVU284
 1128 0252 C695      		lsr r28
 1129 0254 C695      		lsr r28
 1130               	.LVL104:
 427:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1131               		.loc 1 427 47 discriminator 4 view .LVU285
 1132 0256 C370      		andi r28,lo8(3)
 1133 0258 602B      		or r22,r16
 1134               	.LVL105:
 427:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1135               		.loc 1 427 47 discriminator 4 view .LVU286
 1136 025a 712B      		or r23,r17
 1137 025c 822B      		or r24,r18
 1138 025e 932B      		or r25,r19
 1139 0260 C230      		cpi r28,lo8(2)
 1140 0262 01F0      		breq .L76
 1141 0264 00F4      		brsh .L77
 1142 0266 C130      		cpi r28,lo8(1)
 1143 0268 01F0      		breq .L78
 429:tmk_core/common/action.c ****                             break;
 1144               		.loc 1 429 29 is_stmt 1 view .LVU287
 1145 026a 0E94 0000 		call default_layer_and
 1146               	.LVL106:
 430:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1147               		.loc 1 430 29 view .LVU288
 1148 026e 00C0      		rjmp .L37
 1149               	.L78:
 432:tmk_core/common/action.c ****                             break;
 1150               		.loc 1 432 29 view .LVU289
 1151 0270 0E94 0000 		call default_layer_or
 1152               	.LVL107:
 433:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1153               		.loc 1 433 29 view .LVU290
 1154 0274 00C0      		rjmp .L37
 1155               	.L76:
 435:tmk_core/common/action.c ****                             break;
 1156               		.loc 1 435 29 view .LVU291
 1157 0276 0E94 0000 		call default_layer_xor
 1158               	.LVL108:
 436:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1159               		.loc 1 436 29 view .LVU292
 1160 027a 00C0      		rjmp .L37
 1161               	.L77:
 438:tmk_core/common/action.c ****                             break;
 1162               		.loc 1 438 29 view .LVU293
 1163 027c 0E94 0000 		call default_layer_set
 1164               	.LVL109:
 439:tmk_core/common/action.c ****                     }
 1165               		.loc 1 439 29 view .LVU294
 1166 0280 00C0      		rjmp .L37
 1167               	.LVL110:
 1168               	.L74:
 439:tmk_core/common/action.c ****                     }
 1169               		.loc 1 439 29 is_stmt 0 view .LVU295
 1170               	.LBE34:
 444:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1171               		.loc 1 444 17 is_stmt 1 view .LVU296
 444:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1172               		.loc 1 444 21 is_stmt 0 view .LVU297
 1173 0282 8695      		lsr r24
 1174 0284 1123      		tst r17
 1175 0286 01F0      		breq .L80
 444:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1176               		.loc 1 444 21 discriminator 1 view .LVU298
 1177 0288 8C2F      		mov r24,r28
 1178 028a 8170      		andi r24,lo8(1)
 1179               	.L80:
 444:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1180               		.loc 1 444 20 discriminator 4 view .LVU299
 1181 028c 8823      		tst r24
 1182 028e 01F4      		brne .+2
 1183 0290 00C0      		rjmp .L37
 1184               	.LBB35:
 445:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1185               		.loc 1 445 21 is_stmt 1 view .LVU300
 1186               	.LVL111:
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1187               		.loc 1 446 21 view .LVU301
 445:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1188               		.loc 1 445 61 is_stmt 0 view .LVU302
 1189 0292 4D2F      		mov r20,r29
 1190 0294 4295      		swap r20
 1191 0296 4695      		lsr r20
 1192 0298 4770      		andi r20,lo8(7)
 445:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1193               		.loc 1 445 35 view .LVU303
 1194 029a 440F      		lsl r20
 1195 029c 440F      		lsl r20
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1196               		.loc 1 446 77 view .LVU304
 1197 029e 0D2F      		mov r16,r29
 1198               	.LVL112:
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1199               		.loc 1 446 77 view .LVU305
 1200 02a0 0F70      		andi r16,lo8(15)
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1201               		.loc 1 446 44 view .LVU306
 1202 02a2 10E0      		ldi r17,0
 1203               	.LVL113:
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1204               		.loc 1 446 44 view .LVU307
 1205 02a4 30E0      		ldi r19,0
 1206 02a6 20E0      		ldi r18,0
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1207               		.loc 1 446 35 view .LVU308
 1208 02a8 042E      		mov r0,r20
 1209 02aa 00C0      		rjmp 2f
 1210               		1:
 1211 02ac 000F      		lsl r16
 1212 02ae 111F      		rol r17
 1213 02b0 221F      		rol r18
 1214 02b2 331F      		rol r19
 1215               		2:
 1216 02b4 0A94      		dec r0
 1217 02b6 02F4      		brpl 1b
 1218               	.LVL114:
 447:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1219               		.loc 1 447 21 is_stmt 1 view .LVU309
 447:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1220               		.loc 1 447 104 is_stmt 0 view .LVU310
 1221 02b8 60E0      		ldi r22,0
 1222 02ba 70E0      		ldi r23,0
 1223 02bc CB01      		movw r24,r22
 1224 02be D4FF      		sbrs r29,4
 1225 02c0 00C0      		rjmp .L81
 447:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1226               		.loc 1 447 94 discriminator 1 view .LVU311
 1227 02c2 6FE0      		ldi r22,lo8(15)
 1228 02c4 70E0      		ldi r23,0
 1229 02c6 80E0      		ldi r24,0
 1230 02c8 90E0      		ldi r25,0
 1231 02ca 00C0      		rjmp 2f
 1232               		1:
 1233 02cc 660F      		lsl r22
 1234 02ce 771F      		rol r23
 1235 02d0 881F      		rol r24
 1236 02d2 991F      		rol r25
 1237               		2:
 1238 02d4 4A95      		dec r20
 1239 02d6 02F4      		brpl 1b
 447:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1240               		.loc 1 447 104 discriminator 1 view .LVU312
 1241 02d8 6095      		com r22
 1242 02da 7095      		com r23
 1243 02dc 8095      		com r24
 1244 02de 9095      		com r25
 1245               	.L81:
 1246               	.LVL115:
 448:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1247               		.loc 1 448 21 is_stmt 1 discriminator 4 view .LVU313
 448:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1248               		.loc 1 448 47 is_stmt 0 discriminator 4 view .LVU314
 1249 02e0 C695      		lsr r28
 1250 02e2 C695      		lsr r28
 1251               	.LVL116:
 448:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1252               		.loc 1 448 47 discriminator 4 view .LVU315
 1253 02e4 C370      		andi r28,lo8(3)
 1254 02e6 602B      		or r22,r16
 1255               	.LVL117:
 448:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1256               		.loc 1 448 47 discriminator 4 view .LVU316
 1257 02e8 712B      		or r23,r17
 1258 02ea 822B      		or r24,r18
 1259 02ec 932B      		or r25,r19
 1260 02ee C230      		cpi r28,lo8(2)
 1261 02f0 01F0      		breq .L82
 1262 02f2 00F4      		brsh .L83
 1263 02f4 C130      		cpi r28,lo8(1)
 1264 02f6 01F0      		breq .L84
 450:tmk_core/common/action.c ****                             break;
 1265               		.loc 1 450 29 is_stmt 1 view .LVU317
 1266 02f8 0E94 0000 		call layer_and
 1267               	.LVL118:
 451:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1268               		.loc 1 451 29 view .LVU318
 1269 02fc 00C0      		rjmp .L37
 1270               	.L84:
 453:tmk_core/common/action.c ****                             break;
 1271               		.loc 1 453 29 view .LVU319
 1272 02fe 0E94 0000 		call layer_or
 1273               	.LVL119:
 454:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1274               		.loc 1 454 29 view .LVU320
 1275 0302 00C0      		rjmp .L37
 1276               	.L82:
 456:tmk_core/common/action.c ****                             break;
 1277               		.loc 1 456 29 view .LVU321
 1278 0304 0E94 0000 		call layer_xor
 1279               	.LVL120:
 457:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1280               		.loc 1 457 29 view .LVU322
 1281 0308 00C0      		rjmp .L37
 1282               	.L83:
 459:tmk_core/common/action.c ****                             break;
 1283               		.loc 1 459 29 view .LVU323
 1284 030a 0E94 0000 		call layer_state_set
 1285               	.LVL121:
 460:tmk_core/common/action.c ****                     }
 1286               		.loc 1 460 29 view .LVU324
 1287 030e 00C0      		rjmp .L37
 1288               	.LVL122:
 1289               	.L40:
 460:tmk_core/common/action.c ****                     }
 1290               		.loc 1 460 29 is_stmt 0 view .LVU325
 1291               	.LBE35:
 466:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1292               		.loc 1 466 13 is_stmt 1 view .LVU326
 1293 0310 CF70      		andi r28,lo8(15)
 1294               	.LVL123:
 466:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1295               		.loc 1 466 16 is_stmt 0 view .LVU327
 1296 0312 1123      		tst r17
 1297 0314 01F0      		breq .L85
 467:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1298               		.loc 1 467 17 is_stmt 1 view .LVU328
 1299 0316 8C2F      		mov r24,r28
 1300 0318 0E94 0000 		call layer_on
 1301               	.LVL124:
 468:tmk_core/common/action.c ****             } else {
 1302               		.loc 1 468 17 view .LVU329
 1303 031c 8D2F      		mov r24,r29
 1304 031e 00C0      		rjmp .L137
 1305               	.L85:
 470:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1306               		.loc 1 470 17 view .LVU330
 1307 0320 8D2F      		mov r24,r29
 1308 0322 0E94 0000 		call unregister_mods
 1309               	.LVL125:
 471:tmk_core/common/action.c ****             }
 1310               		.loc 1 471 17 view .LVU331
 1311 0326 8C2F      		mov r24,r28
 1312               	.LVL126:
 1313               	.L134:
 558:tmk_core/common/action.c ****                         }
 1314               		.loc 1 558 29 is_stmt 0 view .LVU332
 1315 0328 0E94 0000 		call layer_off
 1316               	.LVL127:
 1317 032c 00C0      		rjmp .L37
 1318               	.L38:
 477:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1319               		.loc 1 477 13 is_stmt 1 view .LVU333
 1320 032e D23F      		cpi r29,lo8(-14)
 1321 0330 01F0      		breq .L86
 1322 0332 00F4      		brsh .L87
 1323 0334 D03F      		cpi r29,lo8(-16)
 1324 0336 01F0      		breq .L88
 1325 0338 D13F      		cpi r29,lo8(-15)
 1326 033a 01F0      		breq .L89
 1327               	.L90:
 539:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1328               		.loc 1 539 21 view .LVU334
 539:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1329               		.loc 1 539 24 is_stmt 0 view .LVU335
 1330 033c 1123      		tst r17
 1331 033e 01F4      		brne .+2
 1332 0340 00C0      		rjmp .L99
 540:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1333               		.loc 1 540 25 is_stmt 1 view .LVU336
 540:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1334               		.loc 1 540 28 is_stmt 0 view .LVU337
 1335 0342 0111      		cpse r16,__zero_reg__
 1336 0344 00C0      		rjmp .L138
 544:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1337               		.loc 1 544 76 is_stmt 1 view .LVU338
 545:tmk_core/common/action.c ****                         }
 1338               		.loc 1 545 29 view .LVU339
 1339 0346 8C2F      		mov r24,r28
 1340 0348 8F71      		andi r24,lo8(31)
 1341 034a 00C0      		rjmp .L136
 1342               	.L87:
 1343 034c D33F      		cpi r29,lo8(-13)
 1344 034e 01F0      		breq .L91
 1345 0350 D43F      		cpi r29,lo8(-12)
 1346 0352 01F4      		brne .L90
 525:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1347               		.loc 1 525 21 view .LVU340
 525:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1348               		.loc 1 525 24 is_stmt 0 view .LVU341
 1349 0354 1123      		tst r17
 1350 0356 01F0      		breq .L98
 526:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1351               		.loc 1 526 25 is_stmt 1 view .LVU342
 526:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1352               		.loc 1 526 50 is_stmt 0 view .LVU343
 1353 0358 CF71      		andi r28,lo8(31)
 1354               	.LVL128:
 526:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1355               		.loc 1 526 25 view .LVU344
 1356 035a 8C2F      		mov r24,r28
 1357 035c 0E94 0000 		call layer_on
 1358               	.LVL129:
 527:tmk_core/common/action.c ****                     } else {
 1359               		.loc 1 527 25 is_stmt 1 view .LVU345
 1360 0360 63E0      		ldi r22,lo8(3)
 1361 0362 8C2F      		mov r24,r28
 1362 0364 0E94 0000 		call set_oneshot_layer
 1363               	.LVL130:
 1364 0368 00C0      		rjmp .L37
 1365               	.LVL131:
 1366               	.L88:
 480:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1367               		.loc 1 480 21 view .LVU346
 480:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1368               		.loc 1 480 24 is_stmt 0 view .LVU347
 1369 036a 1123      		tst r17
 1370 036c 01F0      		breq .L93
 481:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1371               		.loc 1 481 25 is_stmt 1 view .LVU348
 481:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1372               		.loc 1 481 28 is_stmt 0 view .LVU349
 1373 036e 0530      		cpi r16,lo8(5)
 1374 0370 00F0      		brlo .+2
 1375 0372 00C0      		rjmp .L37
 1376               	.L94:
 482:tmk_core/common/action.c ****                         }
 1377               		.loc 1 482 29 is_stmt 1 view .LVU350
 1378 0374 8C2F      		mov r24,r28
 1379 0376 8F71      		andi r24,lo8(31)
 1380 0378 0E94 0000 		call layer_invert
 1381               	.LVL132:
 1382 037c 00C0      		rjmp .L37
 1383               	.L93:
 485:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1384               		.loc 1 485 25 view .LVU351
 485:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1385               		.loc 1 485 28 is_stmt 0 view .LVU352
 1386 037e 0630      		cpi r16,lo8(6)
 1387 0380 00F0      		brlo .+2
 1388 0382 00C0      		rjmp .L37
 1389 0384 00C0      		rjmp .L94
 1390               	.L89:
 491:tmk_core/common/action.c ****                     break;
 1391               		.loc 1 491 21 is_stmt 1 view .LVU353
 1392 0386 8C2F      		mov r24,r28
 1393 0388 8F71      		andi r24,lo8(31)
 491:tmk_core/common/action.c ****                     break;
 1394               		.loc 1 491 68 is_stmt 0 view .LVU354
 1395 038a 1123      		tst r17
 1396 038c 01F0      		breq .L134
 1397               	.L136:
 545:tmk_core/common/action.c ****                         }
 1398               		.loc 1 545 29 view .LVU355
 1399 038e 0E94 0000 		call layer_on
 1400               	.LVL133:
 1401 0392 00C0      		rjmp .L37
 1402               	.L86:
 494:tmk_core/common/action.c ****                     break;
 1403               		.loc 1 494 21 is_stmt 1 view .LVU356
 1404 0394 8C2F      		mov r24,r28
 1405 0396 8F71      		andi r24,lo8(31)
 494:tmk_core/common/action.c ****                     break;
 1406               		.loc 1 494 69 is_stmt 0 view .LVU357
 1407 0398 1123      		tst r17
 1408 039a 01F0      		breq .L136
 1409 039c 00C0      		rjmp .L134
 1410               	.L91:
 497:tmk_core/common/action.c ****                     break;
 1411               		.loc 1 497 21 is_stmt 1 view .LVU358
 497:tmk_core/common/action.c ****                     break;
 1412               		.loc 1 497 70 is_stmt 0 view .LVU359
 1413 039e 1123      		tst r17
 1414 03a0 01F0      		breq .L97
 497:tmk_core/common/action.c ****                     break;
 1415               		.loc 1 497 37 discriminator 1 view .LVU360
 1416 03a2 8C2F      		mov r24,r28
 1417 03a4 8F71      		andi r24,lo8(31)
 1418 03a6 0E94 0000 		call layer_move
 1419               	.LVL134:
 1420 03aa 00C0      		rjmp .L37
 1421               	.L97:
 497:tmk_core/common/action.c ****                     break;
 1422               		.loc 1 497 72 discriminator 2 view .LVU361
 1423 03ac 0E94 0000 		call layer_clear
 1424               	.LVL135:
 1425 03b0 00C0      		rjmp .L37
 1426               	.L98:
 529:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1427               		.loc 1 529 25 is_stmt 1 view .LVU362
 1428 03b2 81E0      		ldi r24,lo8(1)
 1429 03b4 0E94 0000 		call clear_oneshot_layer_state
 1430               	.LVL136:
 530:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1431               		.loc 1 530 25 view .LVU363
 530:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1432               		.loc 1 530 28 is_stmt 0 view .LVU364
 1433 03b8 0230      		cpi r16,lo8(2)
 1434 03ba 00F4      		brsh .+2
 1435 03bc 00C0      		rjmp .L37
 531:tmk_core/common/action.c ****                         }
 1436               		.loc 1 531 29 is_stmt 1 view .LVU365
 1437 03be 82E0      		ldi r24,lo8(2)
 1438 03c0 0E94 0000 		call clear_oneshot_layer_state
 1439               	.LVL137:
 1440 03c4 00C0      		rjmp .L37
 1441               	.L99:
 548:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1442               		.loc 1 548 25 view .LVU366
 548:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1443               		.loc 1 548 28 is_stmt 0 view .LVU367
 1444 03c6 0023      		tst r16
 1445 03c8 01F0      		breq .L101
 549:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1446               		.loc 1 549 77 is_stmt 1 view .LVU368
 550:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1447               		.loc 1 550 29 view .LVU369
 550:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1448               		.loc 1 550 32 is_stmt 0 view .LVU370
 1449 03ca D933      		cpi r29,lo8(57)
 1450 03cc 01F0      		breq .+2
 1451 03ce 00C0      		rjmp .L103
 551:tmk_core/common/action.c ****                             } else {
 1452               		.loc 1 551 33 is_stmt 1 view .LVU371
 1453               	.LVL138:
 1454               	.LBB36:
 1455               	.LBI31:
 166:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 1456               		.loc 3 166 1 view .LVU372
 1457               	.LBB33:
 168:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1458               		.loc 3 168 2 view .LVU373
 172:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1459               		.loc 3 172 2 view .LVU374
 173:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1460               		.loc 3 173 2 view .LVU375
 174:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1461               		.loc 3 174 2 view .LVU376
 184:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 1462               		.loc 3 184 3 view .LVU377
 1463               		.loc 3 187 2 view .LVU378
 1464 03d0 8FEF      		ldi r24,lo8(255999)
 1465 03d2 97EE      		ldi r25,hi8(255999)
 1466 03d4 E3E0      		ldi r30,hlo8(255999)
 1467 03d6 8150      	1:	subi r24,1
 1468 03d8 9040      		sbci r25,0
 1469 03da E040      		sbci r30,0
 1470 03dc 01F4      		brne 1b
 1471 03de 00C0      		rjmp .L141
 1472               	.LVL139:
 1473               	.L101:
 1474               		.loc 3 187 2 is_stmt 0 view .LVU379
 1475               	.LBE33:
 1476               	.LBE36:
 557:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1477               		.loc 1 557 79 is_stmt 1 view .LVU380
 558:tmk_core/common/action.c ****                         }
 1478               		.loc 1 558 29 view .LVU381
 1479 03e0 8C2F      		mov r24,r28
 1480 03e2 8F71      		andi r24,lo8(31)
 1481 03e4 00C0      		rjmp .L134
 1482               	.LVL140:
 1483               	.L34:
 1484               	/* epilogue start */
 695:tmk_core/common/action.c **** 
 1485               		.loc 1 695 1 is_stmt 0 view .LVU382
 1486 03e6 DF91      		pop r29
 1487               	.LVL141:
 695:tmk_core/common/action.c **** 
 1488               		.loc 1 695 1 view .LVU383
 1489 03e8 CF91      		pop r28
 695:tmk_core/common/action.c **** 
 1490               		.loc 1 695 1 view .LVU384
 1491 03ea 1F91      		pop r17
 1492 03ec 0F91      		pop r16
 1493 03ee FF90      		pop r15
 1494 03f0 EF90      		pop r14
 1495               	.LVL142:
 695:tmk_core/common/action.c **** 
 1496               		.loc 1 695 1 view .LVU385
 1497 03f2 DF90      		pop r13
 1498 03f4 CF90      		pop r12
 1499               	.LVL143:
 695:tmk_core/common/action.c **** 
 1500               		.loc 1 695 1 view .LVU386
 1501 03f6 BF90      		pop r11
 1502 03f8 0895      		ret
 1503               		.cfi_endproc
 1504               	.LFE22:
 1506               		.section	.text.process_record_handler,"ax",@progbits
 1507               	.global	process_record_handler
 1509               	process_record_handler:
 1510               	.LVL144:
 1511               	.LFB21:
 194:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1512               		.loc 1 194 50 is_stmt 1 view -0
 1513               		.cfi_startproc
 194:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1514               		.loc 1 194 50 is_stmt 0 view .LVU388
 1515 0000 0F93      		push r16
 1516               	.LCFI15:
 1517               		.cfi_def_cfa_offset 3
 1518               		.cfi_offset 16, -2
 1519 0002 1F93      		push r17
 1520               	.LCFI16:
 1521               		.cfi_def_cfa_offset 4
 1522               		.cfi_offset 17, -3
 1523 0004 CF93      		push r28
 1524               	.LCFI17:
 1525               		.cfi_def_cfa_offset 5
 1526               		.cfi_offset 28, -4
 1527 0006 DF93      		push r29
 1528               	.LCFI18:
 1529               		.cfi_def_cfa_offset 6
 1530               		.cfi_offset 29, -5
 1531               	/* prologue: function */
 1532               	/* frame size = 0 */
 1533               	/* stack size = 4 */
 1534               	.L__stack_usage = 4
 1535 0008 EC01      		movw r28,r24
 195:tmk_core/common/action.c ****     dprint("ACTION: ");
 1536               		.loc 1 195 5 is_stmt 1 view .LVU389
 195:tmk_core/common/action.c ****     dprint("ACTION: ");
 1537               		.loc 1 195 23 is_stmt 0 view .LVU390
 1538 000a 6881      		ld r22,Y
 1539 000c 7981      		ldd r23,Y+1
 1540 000e 8A81      		ldd r24,Y+2
 1541               	.LVL145:
 195:tmk_core/common/action.c ****     dprint("ACTION: ");
 1542               		.loc 1 195 23 view .LVU391
 1543 0010 0E94 0000 		call store_or_get_action
 1544               	.LVL146:
 1545 0014 8C01      		movw r16,r24
 1546               	.LVL147:
 196:tmk_core/common/action.c ****     debug_action(action);
 1547               		.loc 1 196 23 is_stmt 1 view .LVU392
 197:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1548               		.loc 1 197 5 view .LVU393
 199:tmk_core/common/action.c ****     layer_debug();
 1549               		.loc 1 199 29 view .LVU394
 200:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1550               		.loc 1 200 5 view .LVU395
 1551 0016 0E94 0000 		call layer_debug
 1552               	.LVL148:
 201:tmk_core/common/action.c ****     default_layer_debug();
 1553               		.loc 1 201 37 view .LVU396
 202:tmk_core/common/action.c **** #endif
 1554               		.loc 1 202 5 view .LVU397
 1555 001a 0E94 0000 		call default_layer_debug
 1556               	.LVL149:
 204:tmk_core/common/action.c **** 
 1557               		.loc 1 204 15 view .LVU398
 206:tmk_core/common/action.c **** }
 1558               		.loc 1 206 5 view .LVU399
 206:tmk_core/common/action.c **** }
 1559               		.loc 1 206 5 is_stmt 0 view .LVU400
 1560 001e B801      		movw r22,r16
 1561 0020 CE01      		movw r24,r28
 1562               	/* epilogue start */
 207:tmk_core/common/action.c **** 
 1563               		.loc 1 207 1 view .LVU401
 1564 0022 DF91      		pop r29
 1565 0024 CF91      		pop r28
 1566               	.LVL150:
 207:tmk_core/common/action.c **** 
 1567               		.loc 1 207 1 view .LVU402
 1568 0026 1F91      		pop r17
 1569 0028 0F91      		pop r16
 1570               	.LVL151:
 206:tmk_core/common/action.c **** }
 1571               		.loc 1 206 5 view .LVU403
 1572 002a 0C94 0000 		jmp process_action
 1573               	.LVL152:
 206:tmk_core/common/action.c **** }
 1574               		.loc 1 206 5 view .LVU404
 1575               		.cfi_endproc
 1576               	.LFE21:
 1578               		.section	.text.process_record,"ax",@progbits
 1579               	.global	process_record
 1581               	process_record:
 1582               	.LVL153:
 1583               	.LFB20:
 183:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1584               		.loc 1 183 42 is_stmt 1 view -0
 1585               		.cfi_startproc
 183:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1586               		.loc 1 183 42 is_stmt 0 view .LVU406
 1587 0000 CF93      		push r28
 1588               	.LCFI19:
 1589               		.cfi_def_cfa_offset 3
 1590               		.cfi_offset 28, -2
 1591 0002 DF93      		push r29
 1592               	.LCFI20:
 1593               		.cfi_def_cfa_offset 4
 1594               		.cfi_offset 29, -3
 1595               	/* prologue: function */
 1596               	/* frame size = 0 */
 1597               	/* stack size = 2 */
 1598               	.L__stack_usage = 2
 1599 0004 EC01      		movw r28,r24
 184:tmk_core/common/action.c ****         return;
 1600               		.loc 1 184 5 is_stmt 1 view .LVU407
 1601               	.LBB39:
 1602               	.LBI39:
 1603               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1604               		.loc 4 48 20 view .LVU408
 1605               	.LBB40:
 1606               		.loc 4 48 51 view .LVU409
 1607               		.loc 4 48 74 is_stmt 0 view .LVU410
 1608 0006 8B81      		ldd r24,Y+3
 1609 0008 9C81      		ldd r25,Y+4
 1610               	.LVL154:
 1611               		.loc 4 48 74 view .LVU411
 1612 000a 892B      		or r24,r25
 1613 000c 01F0      		breq .L143
 1614 000e 8881      		ld r24,Y
 1615 0010 9981      		ldd r25,Y+1
 1616 0012 8923      		and r24,r25
 1617 0014 8F3F      		cpi r24,lo8(-1)
 1618 0016 01F4      		brne .L152
 1619               	.L143:
 1620               	/* epilogue start */
 1621               	.LBE40:
 1622               	.LBE39:
 192:tmk_core/common/action.c **** 
 1623               		.loc 1 192 1 view .LVU412
 1624 0018 DF91      		pop r29
 1625 001a CF91      		pop r28
 1626               	.LVL155:
 192:tmk_core/common/action.c **** 
 1627               		.loc 1 192 1 view .LVU413
 1628 001c 0895      		ret
 1629               	.LVL156:
 1630               	.L152:
 188:tmk_core/common/action.c **** 
 1631               		.loc 1 188 5 is_stmt 1 view .LVU414
 188:tmk_core/common/action.c **** 
 1632               		.loc 1 188 10 is_stmt 0 view .LVU415
 1633 001e CE01      		movw r24,r28
 1634 0020 0E94 0000 		call process_record_quantum
 1635               	.LVL157:
 188:tmk_core/common/action.c **** 
 1636               		.loc 1 188 8 view .LVU416
 1637 0024 8823      		tst r24
 1638 0026 01F0      		breq .L143
 190:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1639               		.loc 1 190 5 is_stmt 1 view .LVU417
 1640 0028 CE01      		movw r24,r28
 1641 002a 0E94 0000 		call process_record_handler
 1642               	.LVL158:
 191:tmk_core/common/action.c **** }
 1643               		.loc 1 191 5 view .LVU418
 1644 002e CE01      		movw r24,r28
 1645               	/* epilogue start */
 192:tmk_core/common/action.c **** 
 1646               		.loc 1 192 1 is_stmt 0 view .LVU419
 1647 0030 DF91      		pop r29
 1648 0032 CF91      		pop r28
 1649               	.LVL159:
 191:tmk_core/common/action.c **** }
 1650               		.loc 1 191 5 view .LVU420
 1651 0034 0C94 0000 		jmp post_process_record_quantum
 1652               	.LVL160:
 191:tmk_core/common/action.c **** }
 1653               		.loc 1 191 5 view .LVU421
 1654               		.cfi_endproc
 1655               	.LFE20:
 1657               		.section	.text.process_record_nocache,"ax",@progbits
 1658               	.global	process_record_nocache
 1660               	process_record_nocache:
 1661               	.LVL161:
 1662               	.LFB16:
 143:tmk_core/common/action.c ****     disable_action_cache = true;
 1663               		.loc 1 143 50 is_stmt 1 view -0
 1664               		.cfi_startproc
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 0 */
 1668               	.L__stack_usage = 0
 144:tmk_core/common/action.c ****     process_record(record);
 1669               		.loc 1 144 5 view .LVU423
 144:tmk_core/common/action.c ****     process_record(record);
 1670               		.loc 1 144 26 is_stmt 0 view .LVU424
 1671 0000 21E0      		ldi r18,lo8(1)
 1672 0002 2093 0000 		sts disable_action_cache,r18
 145:tmk_core/common/action.c ****     disable_action_cache = false;
 1673               		.loc 1 145 5 is_stmt 1 view .LVU425
 1674 0006 0E94 0000 		call process_record
 1675               	.LVL162:
 146:tmk_core/common/action.c **** }
 1676               		.loc 1 146 5 view .LVU426
 146:tmk_core/common/action.c **** }
 1677               		.loc 1 146 26 is_stmt 0 view .LVU427
 1678 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1679               	/* epilogue start */
 147:tmk_core/common/action.c **** #else
 1680               		.loc 1 147 1 view .LVU428
 1681 000e 0895      		ret
 1682               		.cfi_endproc
 1683               	.LFE16:
 1685               		.section	.text.register_weak_mods,"ax",@progbits
 1686               	.global	register_weak_mods
 1688               	register_weak_mods:
 1689               	.LVL163:
 1690               	.LFB28:
 892:tmk_core/common/action.c **** 
 893:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 894:tmk_core/common/action.c ****  *
 895:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 896:tmk_core/common/action.c ****  */
 897:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1691               		.loc 1 897 39 is_stmt 1 view -0
 1692               		.cfi_startproc
 1693               	/* prologue: function */
 1694               	/* frame size = 0 */
 1695               	/* stack size = 0 */
 1696               	.L__stack_usage = 0
 898:tmk_core/common/action.c ****     if (mods) {
 1697               		.loc 1 898 5 view .LVU430
 1698               		.loc 1 898 8 is_stmt 0 view .LVU431
 1699 0000 8823      		tst r24
 1700 0002 01F0      		breq .L154
 899:tmk_core/common/action.c ****         add_weak_mods(mods);
 1701               		.loc 1 899 9 is_stmt 1 view .LVU432
 1702 0004 0E94 0000 		call add_weak_mods
 1703               	.LVL164:
 900:tmk_core/common/action.c ****         send_keyboard_report();
 1704               		.loc 1 900 9 view .LVU433
 1705 0008 0C94 0000 		jmp send_keyboard_report
 1706               	.LVL165:
 1707               	.L154:
 1708               	/* epilogue start */
 901:tmk_core/common/action.c ****     }
 902:tmk_core/common/action.c **** }
 1709               		.loc 1 902 1 is_stmt 0 view .LVU434
 1710 000c 0895      		ret
 1711               		.cfi_endproc
 1712               	.LFE28:
 1714               		.section	.text.unregister_weak_mods,"ax",@progbits
 1715               	.global	unregister_weak_mods
 1717               	unregister_weak_mods:
 1718               	.LVL166:
 1719               	.LFB29:
 903:tmk_core/common/action.c **** 
 904:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 905:tmk_core/common/action.c ****  *
 906:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 907:tmk_core/common/action.c ****  */
 908:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1720               		.loc 1 908 41 is_stmt 1 view -0
 1721               		.cfi_startproc
 1722               	/* prologue: function */
 1723               	/* frame size = 0 */
 1724               	/* stack size = 0 */
 1725               	.L__stack_usage = 0
 909:tmk_core/common/action.c ****     if (mods) {
 1726               		.loc 1 909 5 view .LVU436
 1727               		.loc 1 909 8 is_stmt 0 view .LVU437
 1728 0000 8823      		tst r24
 1729 0002 01F0      		breq .L156
 910:tmk_core/common/action.c ****         del_weak_mods(mods);
 1730               		.loc 1 910 9 is_stmt 1 view .LVU438
 1731 0004 0E94 0000 		call del_weak_mods
 1732               	.LVL167:
 911:tmk_core/common/action.c ****         send_keyboard_report();
 1733               		.loc 1 911 9 view .LVU439
 1734 0008 0C94 0000 		jmp send_keyboard_report
 1735               	.LVL168:
 1736               	.L156:
 1737               	/* epilogue start */
 912:tmk_core/common/action.c ****     }
 913:tmk_core/common/action.c **** }
 1738               		.loc 1 913 1 is_stmt 0 view .LVU440
 1739 000c 0895      		ret
 1740               		.cfi_endproc
 1741               	.LFE29:
 1743               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1744               	.global	clear_keyboard_but_mods_and_keys
 1746               	clear_keyboard_but_mods_and_keys:
 1747               	.LFB32:
 914:tmk_core/common/action.c **** 
 915:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 916:tmk_core/common/action.c ****  *
 917:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 918:tmk_core/common/action.c ****  */
 919:tmk_core/common/action.c **** void clear_keyboard(void) {
 920:tmk_core/common/action.c ****     clear_mods();
 921:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 922:tmk_core/common/action.c **** }
 923:tmk_core/common/action.c **** 
 924:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 925:tmk_core/common/action.c ****  *
 926:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 927:tmk_core/common/action.c ****  */
 928:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 929:tmk_core/common/action.c ****     clear_keys();
 930:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 931:tmk_core/common/action.c **** }
 932:tmk_core/common/action.c **** 
 933:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 934:tmk_core/common/action.c ****  *
 935:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 936:tmk_core/common/action.c ****  */
 937:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1748               		.loc 1 937 41 is_stmt 1 view -0
 1749               		.cfi_startproc
 1750               	/* prologue: function */
 1751               	/* frame size = 0 */
 1752               	/* stack size = 0 */
 1753               	.L__stack_usage = 0
 938:tmk_core/common/action.c ****     clear_weak_mods();
 1754               		.loc 1 938 5 view .LVU442
 1755 0000 0E94 0000 		call clear_weak_mods
 1756               	.LVL169:
 939:tmk_core/common/action.c ****     clear_macro_mods();
 1757               		.loc 1 939 5 view .LVU443
 1758 0004 0E94 0000 		call clear_macro_mods
 1759               	.LVL170:
 940:tmk_core/common/action.c ****     send_keyboard_report();
 1760               		.loc 1 940 5 view .LVU444
 1761 0008 0E94 0000 		call send_keyboard_report
 1762               	.LVL171:
 941:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 942:tmk_core/common/action.c ****     mousekey_clear();
 943:tmk_core/common/action.c ****     mousekey_send();
 944:tmk_core/common/action.c **** #endif
 945:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 946:tmk_core/common/action.c ****     host_system_send(0);
 1763               		.loc 1 946 5 view .LVU445
 1764 000c 90E0      		ldi r25,0
 1765 000e 80E0      		ldi r24,0
 1766 0010 0E94 0000 		call host_system_send
 1767               	.LVL172:
 947:tmk_core/common/action.c ****     host_consumer_send(0);
 1768               		.loc 1 947 5 view .LVU446
 1769 0014 90E0      		ldi r25,0
 1770 0016 80E0      		ldi r24,0
 1771 0018 0C94 0000 		jmp host_consumer_send
 1772               	.LVL173:
 1773               		.cfi_endproc
 1774               	.LFE32:
 1776               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1777               	.global	clear_keyboard_but_mods
 1779               	clear_keyboard_but_mods:
 1780               	.LFB31:
 928:tmk_core/common/action.c ****     clear_keys();
 1781               		.loc 1 928 36 view -0
 1782               		.cfi_startproc
 1783               	/* prologue: function */
 1784               	/* frame size = 0 */
 1785               	/* stack size = 0 */
 1786               	.L__stack_usage = 0
 929:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1787               		.loc 1 929 5 view .LVU448
 1788 0000 0E94 0000 		call clear_keys
 1789               	.LVL174:
 930:tmk_core/common/action.c **** }
 1790               		.loc 1 930 5 view .LVU449
 1791 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1792               	.LVL175:
 1793               		.cfi_endproc
 1794               	.LFE31:
 1796               		.section	.text.clear_keyboard,"ax",@progbits
 1797               	.global	clear_keyboard
 1799               	clear_keyboard:
 1800               	.LFB30:
 919:tmk_core/common/action.c ****     clear_mods();
 1801               		.loc 1 919 27 view -0
 1802               		.cfi_startproc
 1803               	/* prologue: function */
 1804               	/* frame size = 0 */
 1805               	/* stack size = 0 */
 1806               	.L__stack_usage = 0
 920:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1807               		.loc 1 920 5 view .LVU451
 1808 0000 0E94 0000 		call clear_mods
 1809               	.LVL176:
 921:tmk_core/common/action.c **** }
 1810               		.loc 1 921 5 view .LVU452
 1811 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1812               	.LVL177:
 1813               		.cfi_endproc
 1814               	.LFE30:
 1816               		.section	.text.is_tap_action,"ax",@progbits
 1817               	.global	is_tap_action
 1819               	is_tap_action:
 1820               	.LVL178:
 1821               	.LFB34:
 948:tmk_core/common/action.c **** #endif
 949:tmk_core/common/action.c **** }
 950:tmk_core/common/action.c **** 
 951:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 952:tmk_core/common/action.c ****  *
 953:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 954:tmk_core/common/action.c ****  */
 955:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 956:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 957:tmk_core/common/action.c ****     return is_tap_action(action);
 958:tmk_core/common/action.c **** }
 959:tmk_core/common/action.c **** 
 960:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 961:tmk_core/common/action.c ****  *
 962:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 963:tmk_core/common/action.c ****  */
 964:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1822               		.loc 1 964 37 view -0
 1823               		.cfi_startproc
 1824               	/* prologue: function */
 1825               	/* frame size = 0 */
 1826               	/* stack size = 0 */
 1827               	.L__stack_usage = 0
 965:tmk_core/common/action.c ****     switch (action.kind.id) {
 1828               		.loc 1 965 5 view .LVU454
 1829               		.loc 1 965 24 is_stmt 0 view .LVU455
 1830 0000 E92F      		mov r30,r25
 1831 0002 E295      		swap r30
 1832 0004 EF70      		andi r30,lo8(15)
 1833               		.loc 1 965 5 view .LVU456
 1834 0006 E250      		subi r30,lo8(-(-2))
 1835 0008 EE30      		cpi r30,lo8(14)
 1836 000a 00F4      		brsh .L170
 1837 000c F0E0      		ldi r31,0
 1838 000e E050      		subi r30,lo8(-(gs(.L164)))
 1839 0010 F040      		sbci r31,hi8(-(gs(.L164)))
 1840 0012 0C94 0000 		jmp __tablejump2__
 1841               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 1842               		.p2align	1
 1843               	.L164:
 1844 0000 0000      		.word gs(.L165)
 1845 0002 0000      		.word gs(.L165)
 1846 0004 0000      		.word gs(.L170)
 1847 0006 0000      		.word gs(.L170)
 1848 0008 0000      		.word gs(.L166)
 1849 000a 0000      		.word gs(.L170)
 1850 000c 0000      		.word gs(.L170)
 1851 000e 0000      		.word gs(.L170)
 1852 0010 0000      		.word gs(.L165)
 1853 0012 0000      		.word gs(.L165)
 1854 0014 0000      		.word gs(.L163)
 1855 0016 0000      		.word gs(.L170)
 1856 0018 0000      		.word gs(.L170)
 1857 001a 0000      		.word gs(.L163)
 1858               		.section	.text.is_tap_action
 1859               	.L165:
 966:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 967:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 968:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 969:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 970:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1860               		.loc 1 970 13 is_stmt 1 view .LVU457
 1861 0016 803F      		cpi r24,lo8(-16)
 1862 0018 01F0      		breq .L173
 1863 001a 00F4      		brsh .L167
 1864 001c 883E      		cpi r24,lo8(-24)
 1865 001e 00F4      		brsh .L170
 1866               	.L173:
 971:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 972:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 973:tmk_core/common/action.c ****                 case OP_ONESHOT:
 974:tmk_core/common/action.c ****                     return true;
 1867               		.loc 1 974 28 is_stmt 0 view .LVU458
 1868 0020 81E0      		ldi r24,lo8(1)
 1869               	.LVL179:
 1870               	/* epilogue start */
 975:tmk_core/common/action.c ****             }
 976:tmk_core/common/action.c ****             return false;
 977:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 978:tmk_core/common/action.c ****             switch (action.swap.code) {
 979:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 980:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 981:tmk_core/common/action.c ****                     return true;
 982:tmk_core/common/action.c ****             }
 983:tmk_core/common/action.c ****             return false;
 984:tmk_core/common/action.c ****         case ACT_MACRO:
 985:tmk_core/common/action.c ****         case ACT_FUNCTION:
 986:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
 987:tmk_core/common/action.c ****                 return true;
 988:tmk_core/common/action.c ****             }
 989:tmk_core/common/action.c ****             return false;
 990:tmk_core/common/action.c ****     }
 991:tmk_core/common/action.c ****     return false;
 992:tmk_core/common/action.c **** }
 1871               		.loc 1 992 1 view .LVU459
 1872 0022 0895      		ret
 1873               	.LVL180:
 1874               	.L167:
 1875               		.loc 1 992 1 view .LVU460
 1876 0024 843F      		cpi r24,lo8(-12)
 1877 0026 01F0      		breq .L173
 1878               	.L170:
 976:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1879               		.loc 1 976 20 view .LVU461
 1880 0028 80E0      		ldi r24,0
 1881               	.LVL181:
 976:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1882               		.loc 1 976 20 view .LVU462
 1883 002a 0895      		ret
 1884               	.LVL182:
 1885               	.L166:
 978:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1886               		.loc 1 978 13 is_stmt 1 view .LVU463
 1887 002c 883E      		cpi r24,lo8(-24)
 1888 002e 00F0      		brlo .L173
 1889 0030 813F      		cpi r24,lo8(-15)
 1890 0032 01F4      		brne .L170
 1891 0034 00C0      		rjmp .L173
 1892               	.L163:
 986:tmk_core/common/action.c ****                 return true;
 1893               		.loc 1 986 13 view .LVU464
 986:tmk_core/common/action.c ****                 return true;
 1894               		.loc 1 986 16 is_stmt 0 view .LVU465
 1895 0036 93FB      		bst r25,3
 1896 0038 8827      		clr r24
 1897 003a 80F9      		bld r24,0
 1898               	.LVL183:
 986:tmk_core/common/action.c ****                 return true;
 1899               		.loc 1 986 16 view .LVU466
 1900 003c 0895      		ret
 1901               		.cfi_endproc
 1902               	.LFE34:
 1904               		.section	.text.is_tap_key,"ax",@progbits
 1905               	.global	is_tap_key
 1907               	is_tap_key:
 1908               	.LVL184:
 1909               	.LFB33:
 955:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1910               		.loc 1 955 31 is_stmt 1 view -0
 1911               		.cfi_startproc
 1912               	/* prologue: function */
 1913               	/* frame size = 0 */
 1914               	/* stack size = 0 */
 1915               	.L__stack_usage = 0
 956:tmk_core/common/action.c ****     return is_tap_action(action);
 1916               		.loc 1 956 5 view .LVU468
 956:tmk_core/common/action.c ****     return is_tap_action(action);
 1917               		.loc 1 956 23 is_stmt 0 view .LVU469
 1918 0000 0E94 0000 		call layer_switch_get_action
 1919               	.LVL185:
 957:tmk_core/common/action.c **** }
 1920               		.loc 1 957 5 is_stmt 1 view .LVU470
 957:tmk_core/common/action.c **** }
 1921               		.loc 1 957 12 is_stmt 0 view .LVU471
 1922 0004 0C94 0000 		jmp is_tap_action
 1923               	.LVL186:
 1924               		.cfi_endproc
 1925               	.LFE33:
 1927               		.section	.text.debug_event,"ax",@progbits
 1928               	.global	debug_event
 1930               	debug_event:
 1931               	.LFB35:
 993:tmk_core/common/action.c **** 
 994:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 995:tmk_core/common/action.c ****  *
 996:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 997:tmk_core/common/action.c ****  */
 998:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 1932               		.loc 1 998 36 is_stmt 1 view -0
 1933               		.cfi_startproc
 1934 0000 CF93      		push r28
 1935               	.LCFI21:
 1936               		.cfi_def_cfa_offset 3
 1937               		.cfi_offset 28, -2
 1938 0002 DF93      		push r29
 1939               	.LCFI22:
 1940               		.cfi_def_cfa_offset 4
 1941               		.cfi_offset 29, -3
 1942 0004 00D0      		rcall .
 1943 0006 00D0      		rcall .
 1944 0008 0F92      		push __tmp_reg__
 1945               	.LCFI23:
 1946               		.cfi_def_cfa_offset 9
 1947 000a CDB7      		in r28,__SP_L__
 1948 000c DEB7      		in r29,__SP_H__
 1949               	.LCFI24:
 1950               		.cfi_def_cfa_register 28
 1951               	/* prologue: function */
 1952               	/* frame size = 5 */
 1953               	/* stack size = 7 */
 1954               	.L__stack_usage = 7
 1955               		.loc 1 998 138 view .LVU473
 1956               	/* epilogue start */
 1957               		.loc 1 998 1 is_stmt 0 view .LVU474
 1958 000e 0F90      		pop __tmp_reg__
 1959 0010 0F90      		pop __tmp_reg__
 1960 0012 0F90      		pop __tmp_reg__
 1961 0014 0F90      		pop __tmp_reg__
 1962 0016 0F90      		pop __tmp_reg__
 1963 0018 DF91      		pop r29
 1964 001a CF91      		pop r28
 1965 001c 0895      		ret
 1966               		.cfi_endproc
 1967               	.LFE35:
 1969               		.section	.text.debug_record,"ax",@progbits
 1970               	.global	debug_record
 1972               	debug_record:
 1973               	.LFB36:
 999:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1000:tmk_core/common/action.c ****  *
1001:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1002:tmk_core/common/action.c ****  */
1003:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 1974               		.loc 1 1003 39 is_stmt 1 view -0
 1975               		.cfi_startproc
 1976 0000 CF93      		push r28
 1977               	.LCFI25:
 1978               		.cfi_def_cfa_offset 3
 1979               		.cfi_offset 28, -2
 1980 0002 DF93      		push r29
 1981               	.LCFI26:
 1982               		.cfi_def_cfa_offset 4
 1983               		.cfi_offset 29, -3
 1984 0004 00D0      		rcall .
 1985 0006 00D0      		rcall .
 1986 0008 00D0      		rcall .
 1987               	.LCFI27:
 1988               		.cfi_def_cfa_offset 10
 1989 000a CDB7      		in r28,__SP_L__
 1990 000c DEB7      		in r29,__SP_H__
 1991               	.LCFI28:
 1992               		.cfi_def_cfa_register 28
 1993               	/* prologue: function */
 1994               	/* frame size = 6 */
 1995               	/* stack size = 8 */
 1996               	.L__stack_usage = 8
1004:tmk_core/common/action.c ****     debug_event(record.event);
 1997               		.loc 1 1004 5 view .LVU476
1005:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1006:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 1998               		.loc 1 1006 77 view .LVU477
 1999               	/* epilogue start */
1007:tmk_core/common/action.c **** #endif
1008:tmk_core/common/action.c **** }
 2000               		.loc 1 1008 1 is_stmt 0 view .LVU478
 2001 000e 2696      		adiw r28,6
 2002 0010 0FB6      		in __tmp_reg__,__SREG__
 2003 0012 F894      		cli
 2004 0014 DEBF      		out __SP_H__,r29
 2005 0016 0FBE      		out __SREG__,__tmp_reg__
 2006 0018 CDBF      		out __SP_L__,r28
 2007 001a DF91      		pop r29
 2008 001c CF91      		pop r28
 2009 001e 0895      		ret
 2010               		.cfi_endproc
 2011               	.LFE36:
 2013               		.section	.text.debug_action,"ax",@progbits
 2014               	.global	debug_action
 2016               	debug_action:
 2017               	.LVL187:
 2018               	.LFB37:
1009:tmk_core/common/action.c **** 
1010:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1011:tmk_core/common/action.c ****  *
1012:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1013:tmk_core/common/action.c ****  */
1014:tmk_core/common/action.c **** void debug_action(action_t action) {
 2019               		.loc 1 1014 36 is_stmt 1 view -0
 2020               		.cfi_startproc
 2021               	/* prologue: function */
 2022               	/* frame size = 0 */
 2023               	/* stack size = 0 */
 2024               	.L__stack_usage = 0
1015:tmk_core/common/action.c ****     switch (action.kind.id) {
 2025               		.loc 1 1015 5 view .LVU480
1016:tmk_core/common/action.c ****         case ACT_LMODS:
1017:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1018:tmk_core/common/action.c ****             break;
1019:tmk_core/common/action.c ****         case ACT_RMODS:
1020:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1021:tmk_core/common/action.c ****             break;
1022:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1023:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1024:tmk_core/common/action.c ****             break;
1025:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1026:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1027:tmk_core/common/action.c ****             break;
1028:tmk_core/common/action.c ****         case ACT_USAGE:
1029:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1030:tmk_core/common/action.c ****             break;
1031:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1032:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1033:tmk_core/common/action.c ****             break;
1034:tmk_core/common/action.c ****         case ACT_LAYER:
1035:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1036:tmk_core/common/action.c ****             break;
1037:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1038:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1039:tmk_core/common/action.c ****             break;
1040:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1041:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1042:tmk_core/common/action.c ****             break;
1043:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1044:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1045:tmk_core/common/action.c ****             break;
1046:tmk_core/common/action.c ****         case ACT_MACRO:
1047:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1048:tmk_core/common/action.c ****             break;
1049:tmk_core/common/action.c ****         case ACT_FUNCTION:
1050:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1051:tmk_core/common/action.c ****             break;
1052:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1053:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1054:tmk_core/common/action.c ****             break;
1055:tmk_core/common/action.c ****         default:
1056:tmk_core/common/action.c ****             dprint("UNKNOWN");
1057:tmk_core/common/action.c ****             break;
1058:tmk_core/common/action.c ****     }
1059:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2026               		.loc 1 1059 75 view .LVU481
 2027               	/* epilogue start */
1060:tmk_core/common/action.c **** }
 2028               		.loc 1 1060 1 is_stmt 0 view .LVU482
 2029 0000 0895      		ret
 2030               		.cfi_endproc
 2031               	.LFE37:
 2033               		.section	.rodata.CSWTCH.11,"a"
 2036               	CSWTCH.11:
 2037 0000 E200      		.word	226
 2038 0002 E900      		.word	233
 2039 0004 EA00      		.word	234
 2040 0006 B500      		.word	181
 2041 0008 B600      		.word	182
 2042 000a B700      		.word	183
 2043 000c CD00      		.word	205
 2044 000e 8301      		.word	387
 2045 0010 CC00      		.word	204
 2046 0012 8A01      		.word	394
 2047 0014 9201      		.word	402
 2048 0016 9401      		.word	404
 2049 0018 2102      		.word	545
 2050 001a 2302      		.word	547
 2051 001c 2402      		.word	548
 2052 001e 2502      		.word	549
 2053 0020 2602      		.word	550
 2054 0022 2702      		.word	551
 2055 0024 2A02      		.word	554
 2056 0026 B300      		.word	179
 2057 0028 B400      		.word	180
 2058 002a 6F00      		.word	111
 2059 002c 7000      		.word	112
 2060               		.section	.rodata.CSWTCH.10,"a"
 2063               	CSWTCH.10:
 2064 0000 81        		.byte	-127
 2065 0001 82        		.byte	-126
 2066 0002 83        		.byte	-125
 2067               	.global	disable_action_cache
 2068               		.section	.bss.disable_action_cache,"aw",@nobits
 2071               	disable_action_cache:
 2072 0000 00        		.zero	1
 2073               		.comm	tp_buttons,2,1
 2074               		.text
 2075               	.Letext0:
 2076               		.file 5 "c:\\msys64\\home\\kyleo\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\stdint.h"
 2077               		.file 6 "tmk_core/common/keycode.h"
 2078               		.file 7 "tmk_core/common/host.h"
 2079               		.file 8 "tmk_core/common/mousekey.h"
 2080               		.file 9 "tmk_core/common/command.h"
 2081               		.file 10 "tmk_core/common/action_code.h"
 2082               		.file 11 "tmk_core/common/action.h"
 2083               		.file 12 "tmk_core/common/action_layer.h"
 2084               		.file 13 "tmk_core/common/action_util.h"
 2085               		.file 14 "tmk_core/common/debug.h"
 2086               		.file 15 "tmk_core/common/led.h"
 2087               		.file 16 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:00000000 action.c
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:2      *ABS*:0000003e __SP_H__
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:3      *ABS*:0000003d __SP_L__
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:4      *ABS*:0000003f __SREG__
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:6      *ABS*:00000001 __zero_reg__
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:13     .text.action_exec:00000000 action_exec
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:94     .text.process_record_quantum:00000000 process_record_quantum
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:116    .text.post_process_record_quantum:00000000 post_process_record_quantum
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:135    .text.process_record_tap_hint:00000000 process_record_tap_hint
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:160    .text.register_code:00000000 register_code
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:2063   .rodata.CSWTCH.10:00000000 CSWTCH.10
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:2036   .rodata.CSWTCH.11:00000000 CSWTCH.11
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:313    .text.unregister_code:00000000 unregister_code
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:403    .text.tap_code:00000000 tap_code
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:468    .text.register_mods:00000000 register_mods
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:497    .text.unregister_mods:00000000 unregister_mods
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:526    .text.process_action:00000000 process_action
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1581   .text.process_record:00000000 process_record
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1509   .text.process_record_handler:00000000 process_record_handler
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1660   .text.process_record_nocache:00000000 process_record_nocache
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:2071   .bss.disable_action_cache:00000000 disable_action_cache
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1688   .text.register_weak_mods:00000000 register_weak_mods
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1717   .text.unregister_weak_mods:00000000 unregister_weak_mods
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1746   .text.clear_keyboard_but_mods_and_keys:00000000 clear_keyboard_but_mods_and_keys
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1779   .text.clear_keyboard_but_mods:00000000 clear_keyboard_but_mods
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1799   .text.clear_keyboard:00000000 clear_keyboard
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1819   .text.is_tap_action:00000000 is_tap_action
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1907   .text.is_tap_key:00000000 is_tap_key
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1930   .text.debug_event:00000000 debug_event
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:1972   .text.debug_record:00000000 debug_record
C:\Users\kyleo\AppData\Local\Temp\ccoeinqM.s:2016   .text.debug_action:00000000 debug_action
                            *COM*:00000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
keyboard_report
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
host_keyboard_leds
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
