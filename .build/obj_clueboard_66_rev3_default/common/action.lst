   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB108:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode) { return false; }
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  55:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  58:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  59:tmk_core/common/action.c **** #endif
  60:tmk_core/common/action.c **** /** \brief Called to execute an action.
  61:tmk_core/common/action.c ****  *
  62:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  63:tmk_core/common/action.c ****  */
  64:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 64 36 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  65:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 65 5 view .LVU1
  66:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:tmk_core/common/action.c ****         dprint("EVENT: ");
  68:tmk_core/common/action.c ****         debug_event(event);
  69:tmk_core/common/action.c ****         dprintln();
  49               		.loc 1 69 19 view .LVU2
  70:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  71:tmk_core/common/action.c ****         retro_tapping_counter++;
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c **** 
  75:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  76:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  77:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  78:tmk_core/common/action.c ****     }
  79:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  80:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c ****     fauxclicky_check();
  83:tmk_core/common/action.c **** #endif
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  86:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  87:tmk_core/common/action.c ****         process_hand_swap(&event);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  50               		.loc 1 91 5 view .LVU3
  51               		.loc 1 91 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  94:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  95:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  96:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  99:tmk_core/common/action.c ****         clear_oneshot_mods();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #    endif
 102:tmk_core/common/action.c **** #endif
 103:tmk_core/common/action.c **** 
 104:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 105:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 105 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 105 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 105 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
 106:tmk_core/common/action.c **** #else
 107:tmk_core/common/action.c ****     process_record(&record);
 108:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 109:tmk_core/common/action.c ****         dprint("processed: ");
 110:tmk_core/common/action.c ****         debug_record(record);
 111:tmk_core/common/action.c ****         dprintln();
 112:tmk_core/common/action.c ****     }
 113:tmk_core/common/action.c **** #endif
 114:tmk_core/common/action.c **** }
  76               		.loc 1 114 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
 105:tmk_core/common/action.c **** #else
  85               		.loc 1 105 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE108:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB110:
 115:tmk_core/common/action.c **** 
 116:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 117:tmk_core/common/action.c **** bool swap_hands = false;
 118:tmk_core/common/action.c **** bool swap_held  = false;
 119:tmk_core/common/action.c **** 
 120:tmk_core/common/action.c **** /** \brief Process Hand Swap
 121:tmk_core/common/action.c ****  *
 122:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 123:tmk_core/common/action.c ****  */
 124:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 125:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 126:tmk_core/common/action.c **** 
 127:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 128:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 129:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c ****     if (do_swap) {
 132:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 133:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 134:tmk_core/common/action.c ****     } else {
 135:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 136:tmk_core/common/action.c ****     }
 137:tmk_core/common/action.c **** }
 138:tmk_core/common/action.c **** #endif
 139:tmk_core/common/action.c **** 
 140:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 141:tmk_core/common/action.c **** bool disable_action_cache = false;
 142:tmk_core/common/action.c **** 
 143:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 144:tmk_core/common/action.c ****     disable_action_cache = true;
 145:tmk_core/common/action.c ****     process_record(record);
 146:tmk_core/common/action.c ****     disable_action_cache = false;
 147:tmk_core/common/action.c **** }
 148:tmk_core/common/action.c **** #else
 149:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 150:tmk_core/common/action.c **** #endif
 151:tmk_core/common/action.c **** 
 152:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  97               		.loc 1 152 72 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 103               		.loc 1 152 74 view .LVU11
 104               		.loc 1 152 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 152 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE110:
 113               		.section	.text.post_process_record_quantum,"ax",@progbits
 114               		.weak	post_process_record_quantum
 116               	post_process_record_quantum:
 117               	.LVL6:
 118               	.LFB111:
 153:tmk_core/common/action.c **** 
 154:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 119               		.loc 1 154 77 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 125               		.loc 1 154 78 view .LVU15
 126               	/* epilogue start */
 127               		.loc 1 154 1 is_stmt 0 view .LVU16
 128 0000 0895      		ret
 129               		.cfi_endproc
 130               	.LFE111:
 132               		.section	.text.process_record_tap_hint,"ax",@progbits
 133               	.global	process_record_tap_hint
 135               	process_record_tap_hint:
 136               	.LVL7:
 137               	.LFB112:
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 157:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 158:tmk_core/common/action.c ****  *
 159:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 160:tmk_core/common/action.c ****  */
 161:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 138               		.loc 1 161 51 is_stmt 1 view -0
 139               		.cfi_startproc
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 162:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 144               		.loc 1 162 5 view .LVU18
 145               		.loc 1 162 23 is_stmt 0 view .LVU19
 146 0000 FC01      		movw r30,r24
 147 0002 8081      		ld r24,Z
 148 0004 9181      		ldd r25,Z+1
 149               	.LVL8:
 150               		.loc 1 162 23 view .LVU20
 151 0006 0C94 0000 		jmp layer_switch_get_action
 152               	.LVL9:
 153               		.loc 1 162 23 view .LVU21
 154               		.cfi_endproc
 155               	.LFE112:
 157               		.section	.text.register_code,"ax",@progbits
 158               	.global	register_code
 160               	register_code:
 161               	.LVL10:
 162               	.LFB116:
 163:tmk_core/common/action.c **** 
 164:tmk_core/common/action.c ****     switch (action.kind.id) {
 165:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 166:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 167:tmk_core/common/action.c ****             switch (action.swap.code) {
 168:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 169:tmk_core/common/action.c ****                 default:
 170:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 171:tmk_core/common/action.c ****                     swap_held  = true;
 172:tmk_core/common/action.c ****             }
 173:tmk_core/common/action.c ****             break;
 174:tmk_core/common/action.c **** #    endif
 175:tmk_core/common/action.c ****     }
 176:tmk_core/common/action.c **** }
 177:tmk_core/common/action.c **** #endif
 178:tmk_core/common/action.c **** 
 179:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 180:tmk_core/common/action.c ****  *
 181:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 182:tmk_core/common/action.c ****  */
 183:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 184:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 185:tmk_core/common/action.c ****         return;
 186:tmk_core/common/action.c ****     }
 187:tmk_core/common/action.c **** 
 188:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 189:tmk_core/common/action.c **** 
 190:tmk_core/common/action.c ****     process_record_handler(record);
 191:tmk_core/common/action.c ****     post_process_record_quantum(record);
 192:tmk_core/common/action.c **** }
 193:tmk_core/common/action.c **** 
 194:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 195:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 196:tmk_core/common/action.c ****     dprint("ACTION: ");
 197:tmk_core/common/action.c ****     debug_action(action);
 198:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 199:tmk_core/common/action.c ****     dprint(" layer_state: ");
 200:tmk_core/common/action.c ****     layer_debug();
 201:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 202:tmk_core/common/action.c ****     default_layer_debug();
 203:tmk_core/common/action.c **** #endif
 204:tmk_core/common/action.c ****     dprintln();
 205:tmk_core/common/action.c **** 
 206:tmk_core/common/action.c ****     process_action(record, action);
 207:tmk_core/common/action.c **** }
 208:tmk_core/common/action.c **** 
 209:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 210:tmk_core/common/action.c ****  *
 211:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 212:tmk_core/common/action.c ****  */
 213:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 214:tmk_core/common/action.c ****     keyevent_t event = record->event;
 215:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 216:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c **** 
 219:tmk_core/common/action.c ****     if (event.pressed) {
 220:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 221:tmk_core/common/action.c ****         clear_weak_mods();
 222:tmk_core/common/action.c ****     }
 223:tmk_core/common/action.c **** 
 224:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 225:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 226:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 227:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 228:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 229:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 230:tmk_core/common/action.c ****     }
 231:tmk_core/common/action.c **** #endif
 232:tmk_core/common/action.c **** 
 233:tmk_core/common/action.c ****     switch (action.kind.id) {
 234:tmk_core/common/action.c ****         /* Key and Mods */
 235:tmk_core/common/action.c ****         case ACT_LMODS:
 236:tmk_core/common/action.c ****         case ACT_RMODS: {
 237:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 238:tmk_core/common/action.c ****             if (event.pressed) {
 239:tmk_core/common/action.c ****                 if (mods) {
 240:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 241:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 242:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 243:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 244:tmk_core/common/action.c ****                         add_mods(mods);
 245:tmk_core/common/action.c ****                     } else {
 246:tmk_core/common/action.c ****                         add_weak_mods(mods);
 247:tmk_core/common/action.c ****                     }
 248:tmk_core/common/action.c ****                     send_keyboard_report();
 249:tmk_core/common/action.c ****                 }
 250:tmk_core/common/action.c ****                 register_code(action.key.code);
 251:tmk_core/common/action.c ****             } else {
 252:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 253:tmk_core/common/action.c ****                 if (mods) {
 254:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 255:tmk_core/common/action.c ****                         del_mods(mods);
 256:tmk_core/common/action.c ****                     } else {
 257:tmk_core/common/action.c ****                         del_weak_mods(mods);
 258:tmk_core/common/action.c ****                     }
 259:tmk_core/common/action.c ****                     send_keyboard_report();
 260:tmk_core/common/action.c ****                 }
 261:tmk_core/common/action.c ****             }
 262:tmk_core/common/action.c ****         } break;
 263:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 264:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 265:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 266:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 267:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 268:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 269:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 270:tmk_core/common/action.c ****                     // Oneshot modifier
 271:tmk_core/common/action.c ****                     if (event.pressed) {
 272:tmk_core/common/action.c ****                         if (tap_count == 0) {
 273:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 274:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 275:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 276:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 277:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 278:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 279:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 280:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 281:tmk_core/common/action.c ****                             clear_oneshot_mods();
 282:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 283:tmk_core/common/action.c ****                             register_mods(mods);
 284:tmk_core/common/action.c **** #        endif
 285:tmk_core/common/action.c ****                         } else {
 286:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 287:tmk_core/common/action.c ****                         }
 288:tmk_core/common/action.c ****                     } else {
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 290:tmk_core/common/action.c ****                             clear_oneshot_mods();
 291:tmk_core/common/action.c ****                             unregister_mods(mods);
 292:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 293:tmk_core/common/action.c ****                             // Retain Oneshot mods
 294:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 295:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 296:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 297:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 298:tmk_core/common/action.c ****                                 unregister_mods(mods);
 299:tmk_core/common/action.c ****                             }
 300:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 301:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 302:tmk_core/common/action.c **** #        endif
 303:tmk_core/common/action.c ****                         } else {
 304:tmk_core/common/action.c ****                             clear_oneshot_mods();
 305:tmk_core/common/action.c ****                             unregister_mods(mods);
 306:tmk_core/common/action.c ****                         }
 307:tmk_core/common/action.c ****                     }
 308:tmk_core/common/action.c ****                     break;
 309:tmk_core/common/action.c **** #    endif
 310:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 311:tmk_core/common/action.c ****                     if (event.pressed) {
 312:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 313:tmk_core/common/action.c ****                             register_mods(mods);
 314:tmk_core/common/action.c ****                         }
 315:tmk_core/common/action.c ****                     } else {
 316:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 317:tmk_core/common/action.c ****                             unregister_mods(mods);
 318:tmk_core/common/action.c ****                         }
 319:tmk_core/common/action.c ****                     }
 320:tmk_core/common/action.c ****                     break;
 321:tmk_core/common/action.c ****                 default:
 322:tmk_core/common/action.c ****                     if (event.pressed) {
 323:tmk_core/common/action.c ****                         if (tap_count > 0) {
 324:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 325:tmk_core/common/action.c ****                             if (
 326:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 327:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event)) &&
 328:tmk_core/common/action.c **** #        endif
 329:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 330:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 331:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 332:tmk_core/common/action.c ****                                 record->tap.count = 0;
 333:tmk_core/common/action.c ****                                 register_mods(mods);
 334:tmk_core/common/action.c ****                             } else
 335:tmk_core/common/action.c **** #    endif
 336:tmk_core/common/action.c ****                             {
 337:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 338:tmk_core/common/action.c ****                                 register_code(action.key.code);
 339:tmk_core/common/action.c ****                             }
 340:tmk_core/common/action.c ****                         } else {
 341:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 342:tmk_core/common/action.c ****                             register_mods(mods);
 343:tmk_core/common/action.c ****                         }
 344:tmk_core/common/action.c ****                     } else {
 345:tmk_core/common/action.c ****                         if (tap_count > 0) {
 346:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 347:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 348:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 349:tmk_core/common/action.c ****                             }
 350:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 351:tmk_core/common/action.c ****                         } else {
 352:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 353:tmk_core/common/action.c ****                             unregister_mods(mods);
 354:tmk_core/common/action.c ****                         }
 355:tmk_core/common/action.c ****                     }
 356:tmk_core/common/action.c ****                     break;
 357:tmk_core/common/action.c ****             }
 358:tmk_core/common/action.c ****         } break;
 359:tmk_core/common/action.c **** #endif
 360:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 361:tmk_core/common/action.c ****         /* other HID usage */
 362:tmk_core/common/action.c ****         case ACT_USAGE:
 363:tmk_core/common/action.c ****             switch (action.usage.page) {
 364:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 365:tmk_core/common/action.c ****                     if (event.pressed) {
 366:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 367:tmk_core/common/action.c ****                     } else {
 368:tmk_core/common/action.c ****                         host_system_send(0);
 369:tmk_core/common/action.c ****                     }
 370:tmk_core/common/action.c ****                     break;
 371:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 372:tmk_core/common/action.c ****                     if (event.pressed) {
 373:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 374:tmk_core/common/action.c ****                     } else {
 375:tmk_core/common/action.c ****                         host_consumer_send(0);
 376:tmk_core/common/action.c ****                     }
 377:tmk_core/common/action.c ****                     break;
 378:tmk_core/common/action.c ****             }
 379:tmk_core/common/action.c ****             break;
 380:tmk_core/common/action.c **** #endif
 381:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 382:tmk_core/common/action.c ****         /* Mouse key */
 383:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 384:tmk_core/common/action.c ****             if (event.pressed) {
 385:tmk_core/common/action.c ****                 switch (action.key.code) {
 386:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 387:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 388:tmk_core/common/action.c ****                         break;
 389:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 390:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 391:tmk_core/common/action.c ****                         break;
 392:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 393:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 394:tmk_core/common/action.c ****                         break;
 395:tmk_core/common/action.c ****                     default:
 396:tmk_core/common/action.c ****                         break;
 397:tmk_core/common/action.c ****                 }
 398:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 399:tmk_core/common/action.c ****                 mousekey_send();
 400:tmk_core/common/action.c ****             } else {
 401:tmk_core/common/action.c ****                 switch (action.key.code) {
 402:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 403:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 404:tmk_core/common/action.c ****                         break;
 405:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 406:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 407:tmk_core/common/action.c ****                         break;
 408:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 409:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 410:tmk_core/common/action.c ****                         break;
 411:tmk_core/common/action.c ****                     default:
 412:tmk_core/common/action.c ****                         break;
 413:tmk_core/common/action.c ****                 }
 414:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 415:tmk_core/common/action.c ****                 mousekey_send();
 416:tmk_core/common/action.c ****             }
 417:tmk_core/common/action.c ****             break;
 418:tmk_core/common/action.c **** #endif
 419:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 420:tmk_core/common/action.c ****         case ACT_LAYER:
 421:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 422:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 423:tmk_core/common/action.c ****                 if (!event.pressed) {
 424:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 425:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 426:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 427:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 428:tmk_core/common/action.c ****                         case OP_BIT_AND:
 429:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 430:tmk_core/common/action.c ****                             break;
 431:tmk_core/common/action.c ****                         case OP_BIT_OR:
 432:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 433:tmk_core/common/action.c ****                             break;
 434:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 435:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 436:tmk_core/common/action.c ****                             break;
 437:tmk_core/common/action.c ****                         case OP_BIT_SET:
 438:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 439:tmk_core/common/action.c ****                             break;
 440:tmk_core/common/action.c ****                     }
 441:tmk_core/common/action.c ****                 }
 442:tmk_core/common/action.c ****             } else {
 443:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 444:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 445:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 446:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 447:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 448:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 449:tmk_core/common/action.c ****                         case OP_BIT_AND:
 450:tmk_core/common/action.c ****                             layer_and(bits | mask);
 451:tmk_core/common/action.c ****                             break;
 452:tmk_core/common/action.c ****                         case OP_BIT_OR:
 453:tmk_core/common/action.c ****                             layer_or(bits | mask);
 454:tmk_core/common/action.c ****                             break;
 455:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 456:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 457:tmk_core/common/action.c ****                             break;
 458:tmk_core/common/action.c ****                         case OP_BIT_SET:
 459:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 460:tmk_core/common/action.c ****                             break;
 461:tmk_core/common/action.c ****                     }
 462:tmk_core/common/action.c ****                 }
 463:tmk_core/common/action.c ****             }
 464:tmk_core/common/action.c ****             break;
 465:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 466:tmk_core/common/action.c ****             if (event.pressed) {
 467:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 468:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 469:tmk_core/common/action.c ****             } else {
 470:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 471:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 472:tmk_core/common/action.c ****             }
 473:tmk_core/common/action.c ****             break;
 474:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 475:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 476:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 477:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 478:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 479:tmk_core/common/action.c ****                     /* tap toggle */
 480:tmk_core/common/action.c ****                     if (event.pressed) {
 481:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 482:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 483:tmk_core/common/action.c ****                         }
 484:tmk_core/common/action.c ****                     } else {
 485:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 486:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 487:tmk_core/common/action.c ****                         }
 488:tmk_core/common/action.c ****                     }
 489:tmk_core/common/action.c ****                     break;
 490:tmk_core/common/action.c ****                 case OP_ON_OFF:
 491:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 492:tmk_core/common/action.c ****                     break;
 493:tmk_core/common/action.c ****                 case OP_OFF_ON:
 494:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 495:tmk_core/common/action.c ****                     break;
 496:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 497:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 498:tmk_core/common/action.c ****                     break;
 499:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 500:tmk_core/common/action.c ****                 case OP_ONESHOT:
 501:tmk_core/common/action.c ****                     // Oneshot modifier
 502:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 503:tmk_core/common/action.c ****                     do_release_oneshot = false;
 504:tmk_core/common/action.c ****                     if (event.pressed) {
 505:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 506:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 507:tmk_core/common/action.c ****                             reset_oneshot_layer();
 508:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 509:tmk_core/common/action.c ****                             break;
 510:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 511:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 512:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 513:tmk_core/common/action.c ****                         }
 514:tmk_core/common/action.c ****                     } else {
 515:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 516:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 517:tmk_core/common/action.c ****                             reset_oneshot_layer();
 518:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 519:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 520:tmk_core/common/action.c ****                         } else {
 521:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 522:tmk_core/common/action.c ****                         }
 523:tmk_core/common/action.c ****                     }
 524:tmk_core/common/action.c **** #            else
 525:tmk_core/common/action.c ****                     if (event.pressed) {
 526:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 527:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 528:tmk_core/common/action.c ****                     } else {
 529:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 530:tmk_core/common/action.c ****                         if (tap_count > 1) {
 531:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 532:tmk_core/common/action.c ****                         }
 533:tmk_core/common/action.c ****                     }
 534:tmk_core/common/action.c **** #            endif
 535:tmk_core/common/action.c ****                     break;
 536:tmk_core/common/action.c **** #        endif
 537:tmk_core/common/action.c ****                 default:
 538:tmk_core/common/action.c ****                     /* tap key */
 539:tmk_core/common/action.c ****                     if (event.pressed) {
 540:tmk_core/common/action.c ****                         if (tap_count > 0) {
 541:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 542:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 543:tmk_core/common/action.c ****                         } else {
 544:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 545:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     } else {
 548:tmk_core/common/action.c ****                         if (tap_count > 0) {
 549:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 550:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 551:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 552:tmk_core/common/action.c ****                             } else {
 553:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 554:tmk_core/common/action.c ****                             }
 555:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 556:tmk_core/common/action.c ****                         } else {
 557:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 558:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 559:tmk_core/common/action.c ****                         }
 560:tmk_core/common/action.c ****                     }
 561:tmk_core/common/action.c ****                     break;
 562:tmk_core/common/action.c ****             }
 563:tmk_core/common/action.c ****             break;
 564:tmk_core/common/action.c **** #    endif
 565:tmk_core/common/action.c **** #endif
 566:tmk_core/common/action.c ****             /* Extentions */
 567:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 568:tmk_core/common/action.c ****         case ACT_MACRO:
 569:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 570:tmk_core/common/action.c ****             break;
 571:tmk_core/common/action.c **** #endif
 572:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 573:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 574:tmk_core/common/action.c ****             switch (action.swap.code) {
 575:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 576:tmk_core/common/action.c ****                     if (event.pressed) {
 577:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 578:tmk_core/common/action.c ****                     }
 579:tmk_core/common/action.c ****                     break;
 580:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 581:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 582:tmk_core/common/action.c ****                     break;
 583:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 584:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 585:tmk_core/common/action.c ****                     break;
 586:tmk_core/common/action.c ****                 case OP_SH_ON:
 587:tmk_core/common/action.c ****                     if (!event.pressed) {
 588:tmk_core/common/action.c ****                         swap_hands = true;
 589:tmk_core/common/action.c ****                     }
 590:tmk_core/common/action.c ****                     break;
 591:tmk_core/common/action.c ****                 case OP_SH_OFF:
 592:tmk_core/common/action.c ****                     if (!event.pressed) {
 593:tmk_core/common/action.c ****                         swap_hands = false;
 594:tmk_core/common/action.c ****                     }
 595:tmk_core/common/action.c ****                     break;
 596:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 597:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 598:tmk_core/common/action.c ****                     /* tap toggle */
 599:tmk_core/common/action.c **** 
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         if (swap_held) {
 602:tmk_core/common/action.c ****                             swap_held = false;
 603:tmk_core/common/action.c ****                         } else {
 604:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:tmk_core/common/action.c ****                         }
 606:tmk_core/common/action.c ****                     } else {
 607:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 608:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 609:tmk_core/common/action.c ****                         }
 610:tmk_core/common/action.c ****                     }
 611:tmk_core/common/action.c ****                     break;
 612:tmk_core/common/action.c ****                 default:
 613:tmk_core/common/action.c ****                     /* tap key */
 614:tmk_core/common/action.c ****                     if (tap_count > 0) {
 615:tmk_core/common/action.c ****                         if (swap_held) {
 616:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 617:tmk_core/common/action.c ****                             swap_held  = false;
 618:tmk_core/common/action.c ****                         }
 619:tmk_core/common/action.c ****                         if (event.pressed) {
 620:tmk_core/common/action.c ****                             register_code(action.swap.code);
 621:tmk_core/common/action.c ****                         } else {
 622:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 623:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 624:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 625:tmk_core/common/action.c ****                         }
 626:tmk_core/common/action.c ****                     } else {
 627:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 628:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 629:tmk_core/common/action.c ****                             swap_held  = false;
 630:tmk_core/common/action.c ****                         }
 631:tmk_core/common/action.c ****                     }
 632:tmk_core/common/action.c **** #    endif
 633:tmk_core/common/action.c ****             }
 634:tmk_core/common/action.c **** #endif
 635:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 636:tmk_core/common/action.c ****         case ACT_FUNCTION:
 637:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 638:tmk_core/common/action.c ****             break;
 639:tmk_core/common/action.c **** #endif
 640:tmk_core/common/action.c ****         default:
 641:tmk_core/common/action.c ****             break;
 642:tmk_core/common/action.c ****     }
 643:tmk_core/common/action.c **** 
 644:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 645:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 646:tmk_core/common/action.c ****     switch (action.kind.id) {
 647:tmk_core/common/action.c ****         case ACT_LAYER:
 648:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 649:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 650:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 651:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 652:tmk_core/common/action.c **** #    endif
 653:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 654:tmk_core/common/action.c ****             break;
 655:tmk_core/common/action.c ****         default:
 656:tmk_core/common/action.c ****             break;
 657:tmk_core/common/action.c ****     }
 658:tmk_core/common/action.c **** #endif
 659:tmk_core/common/action.c **** 
 660:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 661:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 662:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 663:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 664:tmk_core/common/action.c ****     } else {
 665:tmk_core/common/action.c ****         if (event.pressed) {
 666:tmk_core/common/action.c ****             if (tap_count > 0) {
 667:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 668:tmk_core/common/action.c ****             } else {
 669:tmk_core/common/action.c ****             }
 670:tmk_core/common/action.c ****         } else {
 671:tmk_core/common/action.c ****             if (tap_count > 0) {
 672:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 673:tmk_core/common/action.c ****             } else {
 674:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 675:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 676:tmk_core/common/action.c ****                 }
 677:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 678:tmk_core/common/action.c ****             }
 679:tmk_core/common/action.c ****         }
 680:tmk_core/common/action.c ****     }
 681:tmk_core/common/action.c **** #    endif
 682:tmk_core/common/action.c **** #endif
 683:tmk_core/common/action.c **** 
 684:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 685:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 686:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 687:tmk_core/common/action.c ****      */
 688:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 689:tmk_core/common/action.c ****         record->event.pressed = false;
 690:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 691:tmk_core/common/action.c ****         process_record(record);
 692:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 693:tmk_core/common/action.c ****     }
 694:tmk_core/common/action.c **** #endif
 695:tmk_core/common/action.c **** }
 696:tmk_core/common/action.c **** 
 697:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 698:tmk_core/common/action.c ****  *
 699:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 700:tmk_core/common/action.c ****  */
 701:tmk_core/common/action.c **** void register_code(uint8_t code) {
 163               		.loc 1 701 34 is_stmt 1 view -0
 164               		.cfi_startproc
 165               		.loc 1 701 34 is_stmt 0 view .LVU23
 166 0000 CF93      		push r28
 167               	.LCFI4:
 168               		.cfi_def_cfa_offset 3
 169               		.cfi_offset 28, -2
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               	/* stack size = 1 */
 173               	.L__stack_usage = 1
 174 0002 C82F      		mov r28,r24
 702:tmk_core/common/action.c ****     if (code == KC_NO) {
 175               		.loc 1 702 5 is_stmt 1 view .LVU24
 176               		.loc 1 702 8 is_stmt 0 view .LVU25
 177 0004 8823      		tst r24
 178 0006 01F4      		brne .+2
 179 0008 00C0      		rjmp .L5
 703:tmk_core/common/action.c ****         return;
 704:tmk_core/common/action.c ****     }
 705:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 706:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 180               		.loc 1 706 10 is_stmt 1 view .LVU26
 181               		.loc 1 706 13 is_stmt 0 view .LVU27
 182 000a 8238      		cpi r24,lo8(-126)
 183 000c 01F4      		brne .L8
 707:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 708:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 709:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 184               		.loc 1 709 9 is_stmt 1 view .LVU28
 185               		.loc 1 709 13 is_stmt 0 view .LVU29
 186 000e 0E94 0000 		call host_keyboard_leds
 187               	.LVL11:
 188               		.loc 1 709 12 view .LVU30
 189 0012 81FD      		sbrc r24,1
 190 0014 00C0      		rjmp .L5
 710:tmk_core/common/action.c **** #    endif
 711:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 191               		.loc 1 711 9 is_stmt 1 view .LVU31
 192 0016 89E3      		ldi r24,lo8(57)
 193 0018 0E94 0000 		call add_key
 194               	.LVL12:
 712:tmk_core/common/action.c ****         send_keyboard_report();
 195               		.loc 1 712 9 view .LVU32
 196 001c 0E94 0000 		call send_keyboard_report
 197               	.LVL13:
 713:tmk_core/common/action.c ****         wait_ms(100);
 198               		.loc 1 713 9 view .LVU33
 199               	.LBB32:
 200               	.LBI32:
 201               		.file 2 "c:\\msys64\\home\\kyleo\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\util\\delay.h"
   1:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 202               		.loc 2 166 1 view .LVU34
 203               	.LBB33:
 167:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 204               		.loc 2 168 2 view .LVU35
 169:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 205               		.loc 2 172 2 view .LVU36
 173:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 206               		.loc 2 173 2 view .LVU37
 174:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 207               		.loc 2 174 2 view .LVU38
 175:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 208               		.loc 2 184 3 view .LVU39
 185:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 209               		.loc 2 187 2 view .LVU40
 210 0020 2FEF      		ldi r18,lo8(319999)
 211 0022 81EE      		ldi r24,hi8(319999)
 212 0024 94E0      		ldi r25,hlo8(319999)
 213 0026 2150      	1:	subi r18,1
 214 0028 8040      		sbci r24,0
 215 002a 9040      		sbci r25,0
 216 002c 01F4      		brne 1b
 217 002e 00C0      		rjmp .
 218 0030 0000      		nop
 219               	.LVL14:
 220               		.loc 2 187 2 is_stmt 0 view .LVU41
 221               	.LBE33:
 222               	.LBE32:
 714:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 223               		.loc 1 714 9 is_stmt 1 view .LVU42
 224 0032 89E3      		ldi r24,lo8(57)
 225               	.L20:
 715:tmk_core/common/action.c ****         send_keyboard_report();
 716:tmk_core/common/action.c ****     }
 717:tmk_core/common/action.c **** 
 718:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 719:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 720:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 721:tmk_core/common/action.c **** #    endif
 722:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 723:tmk_core/common/action.c ****         send_keyboard_report();
 724:tmk_core/common/action.c ****         wait_ms(100);
 725:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 226               		.loc 1 725 9 is_stmt 0 view .LVU43
 227 0034 0E94 0000 		call del_key
 228               	.LVL15:
 229               	.L21:
 726:tmk_core/common/action.c ****         send_keyboard_report();
 230               		.loc 1 726 9 is_stmt 1 view .LVU44
 231               	/* epilogue start */
 727:tmk_core/common/action.c ****     }
 728:tmk_core/common/action.c **** 
 729:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 730:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 731:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 732:tmk_core/common/action.c **** #    endif
 733:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 734:tmk_core/common/action.c ****         send_keyboard_report();
 735:tmk_core/common/action.c ****         wait_ms(100);
 736:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 737:tmk_core/common/action.c ****         send_keyboard_report();
 738:tmk_core/common/action.c ****     }
 739:tmk_core/common/action.c **** #endif
 740:tmk_core/common/action.c **** 
 741:tmk_core/common/action.c ****     else if
 742:tmk_core/common/action.c ****         IS_KEY(code) {
 743:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 744:tmk_core/common/action.c ****             if (command_proc(code)) return;
 745:tmk_core/common/action.c **** 
 746:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:tmk_core/common/action.c **** /* TODO: remove
 748:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:tmk_core/common/action.c **** 
 752:tmk_core/common/action.c ****             add_key(code);
 753:tmk_core/common/action.c ****             send_keyboard_report();
 754:tmk_core/common/action.c **** 
 755:tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:tmk_core/common/action.c ****             send_keyboard_report();
 757:tmk_core/common/action.c ****             oneshot_cancel();
 758:tmk_core/common/action.c ****         } else
 759:tmk_core/common/action.c **** */
 760:tmk_core/common/action.c **** #endif
 761:tmk_core/common/action.c ****             {
 762:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 763:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 764:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 765:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 766:tmk_core/common/action.c ****                     del_key(code);
 767:tmk_core/common/action.c ****                     send_keyboard_report();
 768:tmk_core/common/action.c ****                 }
 769:tmk_core/common/action.c ****                 add_key(code);
 770:tmk_core/common/action.c ****                 send_keyboard_report();
 771:tmk_core/common/action.c ****             }
 772:tmk_core/common/action.c ****         }
 773:tmk_core/common/action.c ****     else if
 774:tmk_core/common/action.c ****         IS_MOD(code) {
 775:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 776:tmk_core/common/action.c ****             send_keyboard_report();
 777:tmk_core/common/action.c ****         }
 778:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 779:tmk_core/common/action.c ****     else if
 780:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 781:tmk_core/common/action.c ****     else if
 782:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 783:tmk_core/common/action.c **** #endif
 784:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 785:tmk_core/common/action.c ****     else if
 786:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 787:tmk_core/common/action.c ****             mousekey_on(code);
 788:tmk_core/common/action.c ****             mousekey_send();
 789:tmk_core/common/action.c ****         }
 790:tmk_core/common/action.c **** #endif
 791:tmk_core/common/action.c **** }
 232               		.loc 1 791 1 is_stmt 0 view .LVU45
 233 0038 CF91      		pop r28
 726:tmk_core/common/action.c ****         send_keyboard_report();
 234               		.loc 1 726 9 view .LVU46
 235 003a 0C94 0000 		jmp send_keyboard_report
 236               	.LVL16:
 237               	.L8:
 718:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 238               		.loc 1 718 10 is_stmt 1 view .LVU47
 718:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 239               		.loc 1 718 13 is_stmt 0 view .LVU48
 240 003e 8338      		cpi r24,lo8(-125)
 241 0040 01F4      		brne .L10
 720:tmk_core/common/action.c **** #    endif
 242               		.loc 1 720 9 is_stmt 1 view .LVU49
 720:tmk_core/common/action.c **** #    endif
 243               		.loc 1 720 13 is_stmt 0 view .LVU50
 244 0042 0E94 0000 		call host_keyboard_leds
 245               	.LVL17:
 720:tmk_core/common/action.c **** #    endif
 246               		.loc 1 720 12 view .LVU51
 247 0046 80FD      		sbrc r24,0
 248 0048 00C0      		rjmp .L5
 722:tmk_core/common/action.c ****         send_keyboard_report();
 249               		.loc 1 722 9 is_stmt 1 view .LVU52
 250 004a 83E5      		ldi r24,lo8(83)
 251 004c 0E94 0000 		call add_key
 252               	.LVL18:
 723:tmk_core/common/action.c ****         wait_ms(100);
 253               		.loc 1 723 9 view .LVU53
 254 0050 0E94 0000 		call send_keyboard_report
 255               	.LVL19:
 724:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 256               		.loc 1 724 9 view .LVU54
 257               	.LBB34:
 258               	.LBI34:
 166:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 259               		.loc 2 166 1 view .LVU55
 260               	.LBB35:
 168:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 261               		.loc 2 168 2 view .LVU56
 172:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 262               		.loc 2 172 2 view .LVU57
 173:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 263               		.loc 2 173 2 view .LVU58
 174:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 264               		.loc 2 174 2 view .LVU59
 184:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 265               		.loc 2 184 3 view .LVU60
 266               		.loc 2 187 2 view .LVU61
 267 0054 2FEF      		ldi r18,lo8(319999)
 268 0056 81EE      		ldi r24,hi8(319999)
 269 0058 94E0      		ldi r25,hlo8(319999)
 270 005a 2150      	1:	subi r18,1
 271 005c 8040      		sbci r24,0
 272 005e 9040      		sbci r25,0
 273 0060 01F4      		brne 1b
 274 0062 00C0      		rjmp .
 275 0064 0000      		nop
 276               	.LVL20:
 277               		.loc 2 187 2 is_stmt 0 view .LVU62
 278               	.LBE35:
 279               	.LBE34:
 725:tmk_core/common/action.c ****         send_keyboard_report();
 280               		.loc 1 725 9 is_stmt 1 view .LVU63
 281 0066 83E5      		ldi r24,lo8(83)
 282 0068 00C0      		rjmp .L20
 283               	.LVL21:
 284               	.L10:
 729:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 285               		.loc 1 729 10 view .LVU64
 729:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 286               		.loc 1 729 13 is_stmt 0 view .LVU65
 287 006a 8438      		cpi r24,lo8(-124)
 288 006c 01F4      		brne .L11
 731:tmk_core/common/action.c **** #    endif
 289               		.loc 1 731 9 is_stmt 1 view .LVU66
 731:tmk_core/common/action.c **** #    endif
 290               		.loc 1 731 13 is_stmt 0 view .LVU67
 291 006e 0E94 0000 		call host_keyboard_leds
 292               	.LVL22:
 731:tmk_core/common/action.c **** #    endif
 293               		.loc 1 731 12 view .LVU68
 294 0072 82FD      		sbrc r24,2
 295 0074 00C0      		rjmp .L5
 733:tmk_core/common/action.c ****         send_keyboard_report();
 296               		.loc 1 733 9 is_stmt 1 view .LVU69
 297 0076 87E4      		ldi r24,lo8(71)
 298 0078 0E94 0000 		call add_key
 299               	.LVL23:
 734:tmk_core/common/action.c ****         wait_ms(100);
 300               		.loc 1 734 9 view .LVU70
 301 007c 0E94 0000 		call send_keyboard_report
 302               	.LVL24:
 735:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 303               		.loc 1 735 9 view .LVU71
 304               	.LBB36:
 305               	.LBI36:
 166:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 306               		.loc 2 166 1 view .LVU72
 307               	.LBB37:
 168:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 308               		.loc 2 168 2 view .LVU73
 172:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 309               		.loc 2 172 2 view .LVU74
 173:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 310               		.loc 2 173 2 view .LVU75
 174:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 311               		.loc 2 174 2 view .LVU76
 184:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 312               		.loc 2 184 3 view .LVU77
 313               		.loc 2 187 2 view .LVU78
 314 0080 2FEF      		ldi r18,lo8(319999)
 315 0082 81EE      		ldi r24,hi8(319999)
 316 0084 94E0      		ldi r25,hlo8(319999)
 317 0086 2150      	1:	subi r18,1
 318 0088 8040      		sbci r24,0
 319 008a 9040      		sbci r25,0
 320 008c 01F4      		brne 1b
 321 008e 00C0      		rjmp .
 322 0090 0000      		nop
 323               	.LVL25:
 324               		.loc 2 187 2 is_stmt 0 view .LVU79
 325               	.LBE37:
 326               	.LBE36:
 736:tmk_core/common/action.c ****         send_keyboard_report();
 327               		.loc 1 736 9 is_stmt 1 view .LVU80
 328 0092 87E4      		ldi r24,lo8(71)
 329 0094 00C0      		rjmp .L20
 330               	.LVL26:
 331               	.L11:
 741:tmk_core/common/action.c ****         IS_KEY(code) {
 332               		.loc 1 741 10 view .LVU81
 742:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 333               		.loc 1 742 9 is_stmt 0 view .LVU82
 334 0096 8CEF      		ldi r24,lo8(-4)
 335               	.LVL27:
 742:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 336               		.loc 1 742 9 view .LVU83
 337 0098 8C0F      		add r24,r28
 338 009a 813A      		cpi r24,lo8(-95)
 339 009c 00F4      		brsh .L12
 744:tmk_core/common/action.c **** 
 340               		.loc 1 744 13 is_stmt 1 view .LVU84
 765:tmk_core/common/action.c ****                     del_key(code);
 341               		.loc 1 765 17 view .LVU85
 765:tmk_core/common/action.c ****                     del_key(code);
 342               		.loc 1 765 21 is_stmt 0 view .LVU86
 343 009e 6C2F      		mov r22,r28
 344 00a0 8091 0000 		lds r24,keyboard_report
 345 00a4 9091 0000 		lds r25,keyboard_report+1
 346 00a8 0E94 0000 		call is_key_pressed
 347               	.LVL28:
 765:tmk_core/common/action.c ****                     del_key(code);
 348               		.loc 1 765 20 view .LVU87
 349 00ac 8823      		tst r24
 350 00ae 01F0      		breq .L13
 766:tmk_core/common/action.c ****                     send_keyboard_report();
 351               		.loc 1 766 21 is_stmt 1 view .LVU88
 352 00b0 8C2F      		mov r24,r28
 353 00b2 0E94 0000 		call del_key
 354               	.LVL29:
 767:tmk_core/common/action.c ****                 }
 355               		.loc 1 767 21 view .LVU89
 356 00b6 0E94 0000 		call send_keyboard_report
 357               	.LVL30:
 358               	.L13:
 769:tmk_core/common/action.c ****                 send_keyboard_report();
 359               		.loc 1 769 17 view .LVU90
 360 00ba 8C2F      		mov r24,r28
 361 00bc 0E94 0000 		call add_key
 362               	.LVL31:
 770:tmk_core/common/action.c ****             }
 363               		.loc 1 770 17 view .LVU91
 364 00c0 00C0      		rjmp .L21
 365               	.L12:
 773:tmk_core/common/action.c ****         IS_MOD(code) {
 366               		.loc 1 773 10 view .LVU92
 774:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 367               		.loc 1 774 9 is_stmt 0 view .LVU93
 368 00c2 80E2      		ldi r24,lo8(32)
 369 00c4 8C0F      		add r24,r28
 370 00c6 8830      		cpi r24,lo8(8)
 371 00c8 00F4      		brsh .L14
 775:tmk_core/common/action.c ****             send_keyboard_report();
 372               		.loc 1 775 13 is_stmt 1 view .LVU94
 775:tmk_core/common/action.c ****             send_keyboard_report();
 373               		.loc 1 775 22 is_stmt 0 view .LVU95
 374 00ca C770      		andi r28,lo8(7)
 375               	.LVL32:
 775:tmk_core/common/action.c ****             send_keyboard_report();
 376               		.loc 1 775 13 view .LVU96
 377 00cc 81E0      		ldi r24,lo8(1)
 378 00ce 00C0      		rjmp 2f
 379               		1:
 380 00d0 880F      		lsl r24
 381               		2:
 382 00d2 CA95      		dec r28
 383 00d4 02F4      		brpl 1b
 384 00d6 0E94 0000 		call add_mods
 385               	.LVL33:
 776:tmk_core/common/action.c ****         }
 386               		.loc 1 776 13 is_stmt 1 view .LVU97
 387 00da 00C0      		rjmp .L21
 388               	.LVL34:
 389               	.L14:
 779:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 390               		.loc 1 779 10 view .LVU98
 780:tmk_core/common/action.c ****     else if
 391               		.loc 1 780 9 is_stmt 0 view .LVU99
 392 00dc EBE5      		ldi r30,lo8(91)
 393 00de EC0F      		add r30,r28
 394 00e0 E330      		cpi r30,lo8(3)
 395 00e2 00F4      		brsh .L15
 780:tmk_core/common/action.c ****     else if
 396               		.loc 1 780 27 is_stmt 1 view .LVU100
 397               	.LVL35:
 398               	.LBB38:
 399               	.LBI38:
 400               		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO
  33:tmk_core/common/report.h **** };
  34:tmk_core/common/report.h **** 
  35:tmk_core/common/report.h **** /* Mouse buttons */
  36:tmk_core/common/report.h **** enum mouse_buttons {
  37:tmk_core/common/report.h ****     MOUSE_BTN1 = (1 << 0),
  38:tmk_core/common/report.h ****     MOUSE_BTN2 = (1 << 1),
  39:tmk_core/common/report.h ****     MOUSE_BTN3 = (1 << 2),
  40:tmk_core/common/report.h ****     MOUSE_BTN4 = (1 << 3),
  41:tmk_core/common/report.h ****     MOUSE_BTN5 = (1 << 4)
  42:tmk_core/common/report.h **** };
  43:tmk_core/common/report.h **** 
  44:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  45:tmk_core/common/report.h ****  *
  46:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  47:tmk_core/common/report.h ****  */
  48:tmk_core/common/report.h **** enum consumer_usages {
  49:tmk_core/common/report.h ****     // 15.5 Display Controls (https://www.usb.org/sites/default/files/hutrr41_0.pdf)
  50:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F,
  51:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  52:tmk_core/common/report.h ****     // 15.7 Transport Controls
  53:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  54:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  55:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  56:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  57:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  58:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  59:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  60:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  61:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  62:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  63:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  64:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  65:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  66:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  67:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  68:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  69:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  70:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  71:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  72:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  73:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  74:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  75:tmk_core/common/report.h ****     AC_HOME                = 0x223,
  76:tmk_core/common/report.h ****     AC_BACK                = 0x224,
  77:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
  78:tmk_core/common/report.h ****     AC_STOP                = 0x226,
  79:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
  80:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
  81:tmk_core/common/report.h **** };
  82:tmk_core/common/report.h **** 
  83:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
  84:tmk_core/common/report.h ****  *
  85:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
  86:tmk_core/common/report.h ****  */
  87:tmk_core/common/report.h **** enum desktop_usages {
  88:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
  89:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN = 0x81,
  90:tmk_core/common/report.h ****     SYSTEM_SLEEP      = 0x82,
  91:tmk_core/common/report.h ****     SYSTEM_WAKE_UP    = 0x83
  92:tmk_core/common/report.h **** };
  93:tmk_core/common/report.h **** 
  94:tmk_core/common/report.h **** // clang-format on
  95:tmk_core/common/report.h **** 
  96:tmk_core/common/report.h **** #define NKRO_SHARED_EP
  97:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
  98:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
  99:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 100:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 101:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 102:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 103:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 104:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 105:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 106:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 107:tmk_core/common/report.h **** #    else
 108:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 109:tmk_core/common/report.h **** #    endif
 110:tmk_core/common/report.h **** #endif
 111:tmk_core/common/report.h **** 
 112:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 113:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 114:tmk_core/common/report.h **** #else
 115:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 116:tmk_core/common/report.h **** #endif
 117:tmk_core/common/report.h **** 
 118:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 119:tmk_core/common/report.h **** 
 120:tmk_core/common/report.h **** /* VUSB hardcodes keyboard and mouse+extrakey only */
 121:tmk_core/common/report.h **** #if defined(PROTOCOL_VUSB)
 122:tmk_core/common/report.h **** #    undef KEYBOARD_SHARED_EP
 123:tmk_core/common/report.h **** #    undef MOUSE_SHARED_EP
 124:tmk_core/common/report.h **** #endif
 125:tmk_core/common/report.h **** 
 126:tmk_core/common/report.h **** #ifdef __cplusplus
 127:tmk_core/common/report.h **** extern "C" {
 128:tmk_core/common/report.h **** #endif
 129:tmk_core/common/report.h **** 
 130:tmk_core/common/report.h **** /*
 131:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 132:tmk_core/common/report.h ****  *
 133:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 134:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 135:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 136:tmk_core/common/report.h ****  *
 137:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 138:tmk_core/common/report.h ****  *
 139:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 140:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 141:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 142:tmk_core/common/report.h ****  *
 143:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 144:tmk_core/common/report.h ****  *
 145:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 146:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 147:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 148:tmk_core/common/report.h ****  *
 149:tmk_core/common/report.h ****  */
 150:tmk_core/common/report.h **** typedef union {
 151:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 152:tmk_core/common/report.h ****     struct {
 153:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 154:tmk_core/common/report.h ****         uint8_t report_id;
 155:tmk_core/common/report.h **** #endif
 156:tmk_core/common/report.h ****         uint8_t mods;
 157:tmk_core/common/report.h ****         uint8_t reserved;
 158:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 159:tmk_core/common/report.h ****     };
 160:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 161:tmk_core/common/report.h ****     struct nkro_report {
 162:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 163:tmk_core/common/report.h ****         uint8_t report_id;
 164:tmk_core/common/report.h **** #    endif
 165:tmk_core/common/report.h ****         uint8_t mods;
 166:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 167:tmk_core/common/report.h ****     } nkro;
 168:tmk_core/common/report.h **** #endif
 169:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 170:tmk_core/common/report.h **** 
 171:tmk_core/common/report.h **** typedef struct {
 172:tmk_core/common/report.h ****     uint8_t  report_id;
 173:tmk_core/common/report.h ****     uint16_t usage;
 174:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 175:tmk_core/common/report.h **** 
 176:tmk_core/common/report.h **** typedef struct {
 177:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 178:tmk_core/common/report.h ****     uint8_t report_id;
 179:tmk_core/common/report.h **** #endif
 180:tmk_core/common/report.h ****     uint8_t buttons;
 181:tmk_core/common/report.h ****     int8_t  x;
 182:tmk_core/common/report.h ****     int8_t  y;
 183:tmk_core/common/report.h ****     int8_t  v;
 184:tmk_core/common/report.h ****     int8_t  h;
 185:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 186:tmk_core/common/report.h **** 
 187:tmk_core/common/report.h **** /* keycode to system usage */
 188:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 401               		.loc 3 188 24 view .LVU101
 402               	.LBE38:
 189:tmk_core/common/report.h ****     switch (key) {
 403               		.loc 3 189 5 view .LVU102
 780:tmk_core/common/action.c ****     else if
 404               		.loc 1 780 27 is_stmt 0 view .LVU103
 405 00e4 F0E0      		ldi r31,0
 406 00e6 E050      		subi r30,lo8(-(CSWTCH.16))
 407 00e8 F040      		sbci r31,hi8(-(CSWTCH.16))
 408 00ea 8081      		ld r24,Z
 409 00ec 90E0      		ldi r25,0
 410               	/* epilogue start */
 411               		.loc 1 791 1 view .LVU104
 412 00ee CF91      		pop r28
 413               	.LVL36:
 780:tmk_core/common/action.c ****     else if
 414               		.loc 1 780 27 view .LVU105
 415 00f0 0C94 0000 		jmp host_system_send
 416               	.LVL37:
 417               	.L15:
 781:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 418               		.loc 1 781 10 is_stmt 1 view .LVU106
 782:tmk_core/common/action.c **** #endif
 419               		.loc 1 782 9 is_stmt 0 view .LVU107
 420 00f4 E8E5      		ldi r30,lo8(88)
 421 00f6 EC0F      		add r30,r28
 422 00f8 E731      		cpi r30,lo8(23)
 423 00fa 00F4      		brsh .L16
 782:tmk_core/common/action.c **** #endif
 424               		.loc 1 782 29 is_stmt 1 view .LVU108
 425               	.LVL38:
 426               	.LBB39:
 427               	.LBI39:
 190:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 191:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 192:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 193:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 194:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 195:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 196:tmk_core/common/report.h ****         default:
 197:tmk_core/common/report.h ****             return 0;
 198:tmk_core/common/report.h ****     }
 199:tmk_core/common/report.h **** }
 200:tmk_core/common/report.h **** 
 201:tmk_core/common/report.h **** /* keycode to consumer usage */
 202:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 428               		.loc 3 202 24 view .LVU109
 429               	.LBE39:
 203:tmk_core/common/report.h ****     switch (key) {
 430               		.loc 3 203 5 view .LVU110
 782:tmk_core/common/action.c **** #endif
 431               		.loc 1 782 29 is_stmt 0 view .LVU111
 432 00fc F0E0      		ldi r31,0
 433 00fe EE0F      		lsl r30
 434 0100 FF1F      		rol r31
 435 0102 E050      		subi r30,lo8(-(CSWTCH.17))
 436 0104 F040      		sbci r31,hi8(-(CSWTCH.17))
 437 0106 8081      		ld r24,Z
 438 0108 9181      		ldd r25,Z+1
 439               	/* epilogue start */
 440               		.loc 1 791 1 view .LVU112
 441 010a CF91      		pop r28
 442               	.LVL39:
 782:tmk_core/common/action.c **** #endif
 443               		.loc 1 782 29 view .LVU113
 444 010c 0C94 0000 		jmp host_consumer_send
 445               	.LVL40:
 446               	.L16:
 785:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 447               		.loc 1 785 10 is_stmt 1 view .LVU114
 786:tmk_core/common/action.c ****             mousekey_on(code);
 448               		.loc 1 786 9 is_stmt 0 view .LVU115
 449 0110 C03F      		cpi r28,lo8(-16)
 450 0112 00F0      		brlo .L5
 787:tmk_core/common/action.c ****             mousekey_send();
 451               		.loc 1 787 13 is_stmt 1 view .LVU116
 452 0114 8C2F      		mov r24,r28
 453 0116 0E94 0000 		call mousekey_on
 454               	.LVL41:
 788:tmk_core/common/action.c ****         }
 455               		.loc 1 788 13 view .LVU117
 456               	/* epilogue start */
 457               		.loc 1 791 1 is_stmt 0 view .LVU118
 458 011a CF91      		pop r28
 459               	.LVL42:
 788:tmk_core/common/action.c ****         }
 460               		.loc 1 788 13 view .LVU119
 461 011c 0C94 0000 		jmp mousekey_send
 462               	.LVL43:
 463               	.L5:
 464               	/* epilogue start */
 465               		.loc 1 791 1 view .LVU120
 466 0120 CF91      		pop r28
 467               	.LVL44:
 468               		.loc 1 791 1 view .LVU121
 469 0122 0895      		ret
 470               		.cfi_endproc
 471               	.LFE116:
 473               		.section	.text.unregister_code,"ax",@progbits
 474               	.global	unregister_code
 476               	unregister_code:
 477               	.LVL45:
 478               	.LFB117:
 792:tmk_core/common/action.c **** 
 793:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 794:tmk_core/common/action.c ****  *
 795:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 796:tmk_core/common/action.c ****  */
 797:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 479               		.loc 1 797 36 is_stmt 1 view -0
 480               		.cfi_startproc
 481               	/* prologue: function */
 482               	/* frame size = 0 */
 483               	/* stack size = 0 */
 484               	.L__stack_usage = 0
 798:tmk_core/common/action.c ****     if (code == KC_NO) {
 485               		.loc 1 798 5 view .LVU123
 486               		.loc 1 798 8 is_stmt 0 view .LVU124
 487 0000 8823      		tst r24
 488 0002 01F4      		brne .+2
 489 0004 00C0      		rjmp .L22
 799:tmk_core/common/action.c ****         return;
 800:tmk_core/common/action.c ****     }
 801:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 802:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 490               		.loc 1 802 10 is_stmt 1 view .LVU125
 491               		.loc 1 802 13 is_stmt 0 view .LVU126
 492 0006 8238      		cpi r24,lo8(-126)
 493 0008 01F4      		brne .L25
 803:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 804:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 805:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 494               		.loc 1 805 9 is_stmt 1 view .LVU127
 495               		.loc 1 805 15 is_stmt 0 view .LVU128
 496 000a 0E94 0000 		call host_keyboard_leds
 497               	.LVL46:
 498               		.loc 1 805 12 view .LVU129
 499 000e 81FF      		sbrs r24,1
 500 0010 00C0      		rjmp .L22
 806:tmk_core/common/action.c **** #    endif
 807:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 501               		.loc 1 807 9 is_stmt 1 view .LVU130
 502 0012 89E3      		ldi r24,lo8(57)
 503 0014 0E94 0000 		call add_key
 504               	.LVL47:
 808:tmk_core/common/action.c ****         send_keyboard_report();
 505               		.loc 1 808 9 view .LVU131
 506 0018 0E94 0000 		call send_keyboard_report
 507               	.LVL48:
 809:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 508               		.loc 1 809 9 view .LVU132
 509 001c 89E3      		ldi r24,lo8(57)
 510               	.L42:
 810:tmk_core/common/action.c ****         send_keyboard_report();
 811:tmk_core/common/action.c ****     }
 812:tmk_core/common/action.c **** 
 813:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 814:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 815:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 816:tmk_core/common/action.c **** #    endif
 817:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 818:tmk_core/common/action.c ****         send_keyboard_report();
 819:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 511               		.loc 1 819 9 is_stmt 0 view .LVU133
 512 001e 0E94 0000 		call del_key
 513               	.LVL49:
 514               	.L43:
 820:tmk_core/common/action.c ****         send_keyboard_report();
 515               		.loc 1 820 9 is_stmt 1 view .LVU134
 516 0022 0C94 0000 		jmp send_keyboard_report
 517               	.LVL50:
 518               	.L25:
 813:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 519               		.loc 1 813 10 view .LVU135
 813:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 520               		.loc 1 813 13 is_stmt 0 view .LVU136
 521 0026 8338      		cpi r24,lo8(-125)
 522 0028 01F4      		brne .L27
 815:tmk_core/common/action.c **** #    endif
 523               		.loc 1 815 9 is_stmt 1 view .LVU137
 815:tmk_core/common/action.c **** #    endif
 524               		.loc 1 815 15 is_stmt 0 view .LVU138
 525 002a 0E94 0000 		call host_keyboard_leds
 526               	.LVL51:
 815:tmk_core/common/action.c **** #    endif
 527               		.loc 1 815 12 view .LVU139
 528 002e 80FF      		sbrs r24,0
 529 0030 00C0      		rjmp .L22
 817:tmk_core/common/action.c ****         send_keyboard_report();
 530               		.loc 1 817 9 is_stmt 1 view .LVU140
 531 0032 83E5      		ldi r24,lo8(83)
 532 0034 0E94 0000 		call add_key
 533               	.LVL52:
 818:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 534               		.loc 1 818 9 view .LVU141
 535 0038 0E94 0000 		call send_keyboard_report
 536               	.LVL53:
 819:tmk_core/common/action.c ****         send_keyboard_report();
 537               		.loc 1 819 9 view .LVU142
 538 003c 83E5      		ldi r24,lo8(83)
 539 003e 00C0      		rjmp .L42
 540               	.LVL54:
 541               	.L27:
 821:tmk_core/common/action.c ****     }
 822:tmk_core/common/action.c **** 
 823:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 542               		.loc 1 823 10 view .LVU143
 543               		.loc 1 823 13 is_stmt 0 view .LVU144
 544 0040 8438      		cpi r24,lo8(-124)
 545 0042 01F4      		brne .L28
 824:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 825:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 546               		.loc 1 825 9 is_stmt 1 view .LVU145
 547               		.loc 1 825 15 is_stmt 0 view .LVU146
 548 0044 0E94 0000 		call host_keyboard_leds
 549               	.LVL55:
 550               		.loc 1 825 12 view .LVU147
 551 0048 82FF      		sbrs r24,2
 552 004a 00C0      		rjmp .L22
 826:tmk_core/common/action.c **** #    endif
 827:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 553               		.loc 1 827 9 is_stmt 1 view .LVU148
 554 004c 87E4      		ldi r24,lo8(71)
 555 004e 0E94 0000 		call add_key
 556               	.LVL56:
 828:tmk_core/common/action.c ****         send_keyboard_report();
 557               		.loc 1 828 9 view .LVU149
 558 0052 0E94 0000 		call send_keyboard_report
 559               	.LVL57:
 829:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 560               		.loc 1 829 9 view .LVU150
 561 0056 87E4      		ldi r24,lo8(71)
 562 0058 00C0      		rjmp .L42
 563               	.LVL58:
 564               	.L28:
 830:tmk_core/common/action.c ****         send_keyboard_report();
 831:tmk_core/common/action.c ****     }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** 
 834:tmk_core/common/action.c ****     else if
 565               		.loc 1 834 10 view .LVU151
 835:tmk_core/common/action.c ****         IS_KEY(code) {
 566               		.loc 1 835 9 is_stmt 0 view .LVU152
 567 005a 9CEF      		ldi r25,lo8(-4)
 568 005c 980F      		add r25,r24
 569 005e 913A      		cpi r25,lo8(-95)
 570 0060 00F0      		brlo .L42
 836:tmk_core/common/action.c ****             del_key(code);
 837:tmk_core/common/action.c ****             send_keyboard_report();
 838:tmk_core/common/action.c ****         }
 839:tmk_core/common/action.c ****     else if
 571               		.loc 1 839 10 is_stmt 1 view .LVU153
 840:tmk_core/common/action.c ****         IS_MOD(code) {
 572               		.loc 1 840 9 is_stmt 0 view .LVU154
 573 0062 90E2      		ldi r25,lo8(32)
 574 0064 980F      		add r25,r24
 575 0066 9830      		cpi r25,lo8(8)
 576 0068 00F4      		brsh .L30
 841:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 577               		.loc 1 841 13 is_stmt 1 view .LVU155
 578               		.loc 1 841 22 is_stmt 0 view .LVU156
 579 006a 8770      		andi r24,lo8(7)
 580               	.LVL59:
 581               		.loc 1 841 13 view .LVU157
 582 006c 91E0      		ldi r25,lo8(1)
 583 006e 00C0      		rjmp 2f
 584               		1:
 585 0070 990F      		lsl r25
 586               		2:
 587 0072 8A95      		dec r24
 588 0074 02F4      		brpl 1b
 589 0076 892F      		mov r24,r25
 590 0078 0E94 0000 		call del_mods
 591               	.LVL60:
 842:tmk_core/common/action.c ****             send_keyboard_report();
 592               		.loc 1 842 13 is_stmt 1 view .LVU158
 593 007c 00C0      		rjmp .L43
 594               	.LVL61:
 595               	.L30:
 843:tmk_core/common/action.c ****         }
 844:tmk_core/common/action.c ****     else if
 596               		.loc 1 844 10 view .LVU159
 845:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 597               		.loc 1 845 9 is_stmt 0 view .LVU160
 598 007e 9BE5      		ldi r25,lo8(91)
 599 0080 980F      		add r25,r24
 600 0082 9330      		cpi r25,lo8(3)
 601 0084 00F4      		brsh .L31
 602               		.loc 1 845 27 is_stmt 1 discriminator 1 view .LVU161
 603 0086 90E0      		ldi r25,0
 604 0088 80E0      		ldi r24,0
 605               	.LVL62:
 606               		.loc 1 845 27 is_stmt 0 discriminator 1 view .LVU162
 607 008a 0C94 0000 		jmp host_system_send
 608               	.LVL63:
 609               	.L31:
 846:tmk_core/common/action.c ****     else if
 610               		.loc 1 846 10 is_stmt 1 view .LVU163
 847:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 611               		.loc 1 847 9 is_stmt 0 view .LVU164
 612 008e 98E5      		ldi r25,lo8(88)
 613 0090 980F      		add r25,r24
 614 0092 9731      		cpi r25,lo8(23)
 615 0094 00F4      		brsh .L32
 616               		.loc 1 847 29 is_stmt 1 discriminator 1 view .LVU165
 617 0096 90E0      		ldi r25,0
 618 0098 80E0      		ldi r24,0
 619               	.LVL64:
 620               		.loc 1 847 29 is_stmt 0 discriminator 1 view .LVU166
 621 009a 0C94 0000 		jmp host_consumer_send
 622               	.LVL65:
 623               	.L32:
 848:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 849:tmk_core/common/action.c ****     else if
 624               		.loc 1 849 10 is_stmt 1 view .LVU167
 850:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 625               		.loc 1 850 9 is_stmt 0 view .LVU168
 626 009e 803F      		cpi r24,lo8(-16)
 627 00a0 00F0      		brlo .L22
 851:tmk_core/common/action.c ****             mousekey_off(code);
 628               		.loc 1 851 13 is_stmt 1 view .LVU169
 629 00a2 0E94 0000 		call mousekey_off
 630               	.LVL66:
 852:tmk_core/common/action.c ****             mousekey_send();
 631               		.loc 1 852 13 view .LVU170
 632 00a6 0C94 0000 		jmp mousekey_send
 633               	.LVL67:
 634               	.L22:
 635               	/* epilogue start */
 853:tmk_core/common/action.c ****         }
 854:tmk_core/common/action.c **** #endif
 855:tmk_core/common/action.c **** }
 636               		.loc 1 855 1 is_stmt 0 view .LVU171
 637 00aa 0895      		ret
 638               		.cfi_endproc
 639               	.LFE117:
 641               		.section	.text.tap_code,"ax",@progbits
 642               	.global	tap_code
 644               	tap_code:
 645               	.LVL68:
 646               	.LFB118:
 856:tmk_core/common/action.c **** 
 857:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 858:tmk_core/common/action.c ****  *
 859:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 860:tmk_core/common/action.c ****  */
 861:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 647               		.loc 1 861 29 is_stmt 1 view -0
 648               		.cfi_startproc
 649               		.loc 1 861 29 is_stmt 0 view .LVU173
 650 0000 CF93      		push r28
 651               	.LCFI5:
 652               		.cfi_def_cfa_offset 3
 653               		.cfi_offset 28, -2
 654               	/* prologue: function */
 655               	/* frame size = 0 */
 656               	/* stack size = 1 */
 657               	.L__stack_usage = 1
 658 0002 C82F      		mov r28,r24
 862:tmk_core/common/action.c ****     register_code(code);
 659               		.loc 1 862 5 is_stmt 1 view .LVU174
 660 0004 0E94 0000 		call register_code
 661               	.LVL69:
 863:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 662               		.loc 1 863 5 view .LVU175
 663               		.loc 1 863 8 is_stmt 0 view .LVU176
 664 0008 C933      		cpi r28,lo8(57)
 665 000a 01F4      		brne .L46
 864:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 666               		.loc 1 864 9 is_stmt 1 view .LVU177
 667               	.LVL70:
 668               	.LBB40:
 669               	.LBI40:
 166:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 670               		.loc 2 166 1 view .LVU178
 671               	.LBB41:
 168:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 672               		.loc 2 168 2 view .LVU179
 172:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 673               		.loc 2 172 2 view .LVU180
 173:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 674               		.loc 2 173 2 view .LVU181
 174:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 675               		.loc 2 174 2 view .LVU182
 184:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 676               		.loc 2 184 3 view .LVU183
 677               		.loc 2 187 2 view .LVU184
 678 000c 2FEF      		ldi r18,lo8(255999)
 679 000e 87EE      		ldi r24,hi8(255999)
 680 0010 93E0      		ldi r25,hlo8(255999)
 681 0012 2150      	1:	subi r18,1
 682 0014 8040      		sbci r24,0
 683 0016 9040      		sbci r25,0
 684 0018 01F4      		brne 1b
 685 001a 00C0      		rjmp .
 686 001c 0000      		nop
 687               	.LVL71:
 688               	.L46:
 689               		.loc 2 187 2 is_stmt 0 view .LVU185
 690               	.LBE41:
 691               	.LBE40:
 865:tmk_core/common/action.c ****     } else {
 866:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 867:tmk_core/common/action.c ****     }
 868:tmk_core/common/action.c ****     unregister_code(code);
 692               		.loc 1 868 5 is_stmt 1 view .LVU186
 693 001e 8C2F      		mov r24,r28
 694               	/* epilogue start */
 869:tmk_core/common/action.c **** }
 695               		.loc 1 869 1 is_stmt 0 view .LVU187
 696 0020 CF91      		pop r28
 697               	.LVL72:
 868:tmk_core/common/action.c **** }
 698               		.loc 1 868 5 view .LVU188
 699 0022 0C94 0000 		jmp unregister_code
 700               	.LVL73:
 868:tmk_core/common/action.c **** }
 701               		.loc 1 868 5 view .LVU189
 702               		.cfi_endproc
 703               	.LFE118:
 705               		.section	.text.register_mods,"ax",@progbits
 706               	.global	register_mods
 708               	register_mods:
 709               	.LVL74:
 710               	.LFB119:
 870:tmk_core/common/action.c **** 
 871:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 872:tmk_core/common/action.c ****  *
 873:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 874:tmk_core/common/action.c ****  */
 875:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 711               		.loc 1 875 34 is_stmt 1 view -0
 712               		.cfi_startproc
 713               	/* prologue: function */
 714               	/* frame size = 0 */
 715               	/* stack size = 0 */
 716               	.L__stack_usage = 0
 876:tmk_core/common/action.c ****     if (mods) {
 717               		.loc 1 876 5 view .LVU191
 718               		.loc 1 876 8 is_stmt 0 view .LVU192
 719 0000 8823      		tst r24
 720 0002 01F0      		breq .L47
 877:tmk_core/common/action.c ****         add_mods(mods);
 721               		.loc 1 877 9 is_stmt 1 view .LVU193
 722 0004 0E94 0000 		call add_mods
 723               	.LVL75:
 878:tmk_core/common/action.c ****         send_keyboard_report();
 724               		.loc 1 878 9 view .LVU194
 725 0008 0C94 0000 		jmp send_keyboard_report
 726               	.LVL76:
 727               	.L47:
 728               	/* epilogue start */
 879:tmk_core/common/action.c ****     }
 880:tmk_core/common/action.c **** }
 729               		.loc 1 880 1 is_stmt 0 view .LVU195
 730 000c 0895      		ret
 731               		.cfi_endproc
 732               	.LFE119:
 734               		.section	.text.unregister_mods,"ax",@progbits
 735               	.global	unregister_mods
 737               	unregister_mods:
 738               	.LVL77:
 739               	.LFB120:
 881:tmk_core/common/action.c **** 
 882:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 883:tmk_core/common/action.c ****  *
 884:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 885:tmk_core/common/action.c ****  */
 886:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 740               		.loc 1 886 36 is_stmt 1 view -0
 741               		.cfi_startproc
 742               	/* prologue: function */
 743               	/* frame size = 0 */
 744               	/* stack size = 0 */
 745               	.L__stack_usage = 0
 887:tmk_core/common/action.c ****     if (mods) {
 746               		.loc 1 887 5 view .LVU197
 747               		.loc 1 887 8 is_stmt 0 view .LVU198
 748 0000 8823      		tst r24
 749 0002 01F0      		breq .L49
 888:tmk_core/common/action.c ****         del_mods(mods);
 750               		.loc 1 888 9 is_stmt 1 view .LVU199
 751 0004 0E94 0000 		call del_mods
 752               	.LVL78:
 889:tmk_core/common/action.c ****         send_keyboard_report();
 753               		.loc 1 889 9 view .LVU200
 754 0008 0C94 0000 		jmp send_keyboard_report
 755               	.LVL79:
 756               	.L49:
 757               	/* epilogue start */
 890:tmk_core/common/action.c ****     }
 891:tmk_core/common/action.c **** }
 758               		.loc 1 891 1 is_stmt 0 view .LVU201
 759 000c 0895      		ret
 760               		.cfi_endproc
 761               	.LFE120:
 763               		.section	.text.process_action,"ax",@progbits
 764               	.global	process_action
 766               	process_action:
 767               	.LVL80:
 768               	.LFB115:
 213:tmk_core/common/action.c ****     keyevent_t event = record->event;
 769               		.loc 1 213 59 is_stmt 1 view -0
 770               		.cfi_startproc
 213:tmk_core/common/action.c ****     keyevent_t event = record->event;
 771               		.loc 1 213 59 is_stmt 0 view .LVU203
 772 0000 BF92      		push r11
 773               	.LCFI6:
 774               		.cfi_def_cfa_offset 3
 775               		.cfi_offset 11, -2
 776 0002 CF92      		push r12
 777               	.LCFI7:
 778               		.cfi_def_cfa_offset 4
 779               		.cfi_offset 12, -3
 780 0004 DF92      		push r13
 781               	.LCFI8:
 782               		.cfi_def_cfa_offset 5
 783               		.cfi_offset 13, -4
 784 0006 EF92      		push r14
 785               	.LCFI9:
 786               		.cfi_def_cfa_offset 6
 787               		.cfi_offset 14, -5
 788 0008 FF92      		push r15
 789               	.LCFI10:
 790               		.cfi_def_cfa_offset 7
 791               		.cfi_offset 15, -6
 792 000a 0F93      		push r16
 793               	.LCFI11:
 794               		.cfi_def_cfa_offset 8
 795               		.cfi_offset 16, -7
 796 000c 1F93      		push r17
 797               	.LCFI12:
 798               		.cfi_def_cfa_offset 9
 799               		.cfi_offset 17, -8
 800 000e CF93      		push r28
 801               	.LCFI13:
 802               		.cfi_def_cfa_offset 10
 803               		.cfi_offset 28, -9
 804 0010 DF93      		push r29
 805               	.LCFI14:
 806               		.cfi_def_cfa_offset 11
 807               		.cfi_offset 29, -10
 808               	/* prologue: function */
 809               	/* frame size = 0 */
 810               	/* stack size = 9 */
 811               	.L__stack_usage = 9
 812 0012 6C01      		movw r12,r24
 813 0014 D62F      		mov r29,r22
 213:tmk_core/common/action.c ****     keyevent_t event = record->event;
 814               		.loc 1 213 59 view .LVU204
 815 0016 C72F      		mov r28,r23
 214:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 816               		.loc 1 214 5 is_stmt 1 view .LVU205
 817               	.LVL81:
 216:tmk_core/common/action.c **** #endif
 818               		.loc 1 216 5 view .LVU206
 216:tmk_core/common/action.c **** #endif
 819               		.loc 1 216 36 is_stmt 0 view .LVU207
 820 0018 FC01      		movw r30,r24
 821 001a 0581      		ldd r16,Z+5
 822 001c 0295      		swap r16
 823 001e 0F70      		andi r16,lo8(15)
 824               	.LVL82:
 219:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 825               		.loc 1 219 5 is_stmt 1 view .LVU208
 219:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 826               		.loc 1 219 14 is_stmt 0 view .LVU209
 827 0020 1281      		ldd r17,Z+2
 219:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 828               		.loc 1 219 8 view .LVU210
 829 0022 1111      		cpse r17,__zero_reg__
 221:tmk_core/common/action.c ****     }
 830               		.loc 1 221 9 is_stmt 1 view .LVU211
 831 0024 0E94 0000 		call clear_weak_mods
 832               	.LVL83:
 833               	.L52:
 225:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 834               		.loc 1 225 5 view .LVU212
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 835               		.loc 1 227 5 view .LVU213
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 836               		.loc 1 227 9 is_stmt 0 view .LVU214
 837 0028 0E94 0000 		call is_oneshot_layer_active
 838               	.LVL84:
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 839               		.loc 1 227 9 view .LVU215
 840 002c E82E      		mov r14,r24
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 841               		.loc 1 227 8 view .LVU216
 842 002e 8823      		tst r24
 843 0030 01F0      		breq .L53
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 844               		.loc 1 227 35 discriminator 1 view .LVU217
 845 0032 1123      		tst r17
 846 0034 01F0      		breq .L136
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 847               		.loc 1 227 55 discriminator 2 view .LVU218
 848 0036 80E2      		ldi r24,lo8(32)
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 849               		.loc 1 227 55 discriminator 2 view .LVU219
 850 0038 8D0F      		add r24,r29
 227:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 851               		.loc 1 227 52 discriminator 2 view .LVU220
 852 003a 8830      		cpi r24,lo8(8)
 853 003c 00F0      		brlo .L136
 228:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 854               		.loc 1 228 9 is_stmt 1 view .LVU221
 855 003e 82E0      		ldi r24,lo8(2)
 856 0040 0E94 0000 		call clear_oneshot_layer_state
 857               	.LVL85:
 229:tmk_core/common/action.c ****     }
 858               		.loc 1 229 9 view .LVU222
 229:tmk_core/common/action.c ****     }
 859               		.loc 1 229 31 is_stmt 0 view .LVU223
 860 0044 0E94 0000 		call is_oneshot_layer_active
 861               	.LVL86:
 229:tmk_core/common/action.c ****     }
 862               		.loc 1 229 9 view .LVU224
 863 0048 91E0      		ldi r25,lo8(1)
 864 004a E82E      		mov r14,r24
 865 004c E926      		eor r14,r25
 866               	.LVL87:
 867               	.L53:
 233:tmk_core/common/action.c ****         /* Key and Mods */
 868               		.loc 1 233 5 is_stmt 1 view .LVU225
 233:tmk_core/common/action.c ****         /* Key and Mods */
 869               		.loc 1 233 24 is_stmt 0 view .LVU226
 870 004e BC2E      		mov r11,r28
 871 0050 B294      		swap r11
 872 0052 9FE0      		ldi r25,lo8(15)
 873 0054 B922      		and r11,r25
 233:tmk_core/common/action.c ****         /* Key and Mods */
 874               		.loc 1 233 5 view .LVU227
 875 0056 EB2D      		mov r30,r11
 876 0058 F0E0      		ldi r31,0
 877 005a E050      		subi r30,lo8(-(gs(.L56)))
 878 005c F040      		sbci r31,hi8(-(gs(.L56)))
 879 005e 0C94 0000 		jmp __tablejump2__
 880               		.section	.jumptables.gcc.process_action,"a",@progbits
 881               		.p2align	1
 882               	.L56:
 883 0000 0000      		.word gs(.L64)
 884 0002 0000      		.word gs(.L64)
 885 0004 0000      		.word gs(.L63)
 886 0006 0000      		.word gs(.L63)
 887 0008 0000      		.word gs(.L62)
 888 000a 0000      		.word gs(.L61)
 889 000c 0000      		.word gs(.L54)
 890 000e 0000      		.word gs(.L54)
 891 0010 0000      		.word gs(.L60)
 892 0012 0000      		.word gs(.L59)
 893 0014 0000      		.word gs(.L58)
 894 0016 0000      		.word gs(.L58)
 895 0018 0000      		.word gs(.L57)
 896 001a 0000      		.word gs(.L54)
 897 001c 0000      		.word gs(.L54)
 898 001e 0000      		.word gs(.L55)
 899               		.section	.text.process_action
 900               	.LVL88:
 901               	.L136:
 225:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 902               		.loc 1 225 10 view .LVU228
 903 0062 E12C      		mov r14,__zero_reg__
 904 0064 00C0      		rjmp .L53
 905               	.LVL89:
 906               	.L64:
 907               	.LBB42:
 237:tmk_core/common/action.c ****             if (event.pressed) {
 908               		.loc 1 237 13 is_stmt 1 view .LVU229
 909 0066 0C2F      		mov r16,r28
 910               	.LVL90:
 237:tmk_core/common/action.c ****             if (event.pressed) {
 911               		.loc 1 237 13 is_stmt 0 view .LVU230
 912 0068 0F70      		andi r16,lo8(15)
 237:tmk_core/common/action.c ****             if (event.pressed) {
 913               		.loc 1 237 44 view .LVU231
 914 006a C07F      		andi r28,lo8(-16)
 915               	.LVL91:
 237:tmk_core/common/action.c ****             if (event.pressed) {
 916               		.loc 1 237 21 view .LVU232
 917 006c 01F0      		breq .L65
 237:tmk_core/common/action.c ****             if (event.pressed) {
 918               		.loc 1 237 21 discriminator 2 view .LVU233
 919 006e 0295      		swap r16
 920 0070 007F      		andi r16,lo8(-16)
 921               	.L65:
 922               	.LVL92:
 238:tmk_core/common/action.c ****                 if (mods) {
 923               		.loc 1 238 13 is_stmt 1 discriminator 4 view .LVU234
 238:tmk_core/common/action.c ****                 if (mods) {
 924               		.loc 1 238 16 is_stmt 0 discriminator 4 view .LVU235
 925 0072 1123      		tst r17
 926 0074 01F0      		breq .L66
 239:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 927               		.loc 1 239 17 is_stmt 1 view .LVU236
 239:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 928               		.loc 1 239 20 is_stmt 0 view .LVU237
 929 0076 0023      		tst r16
 930 0078 01F0      		breq .L168
 240:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 931               		.loc 1 240 21 is_stmt 1 view .LVU238
 240:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 932               		.loc 1 240 25 is_stmt 0 view .LVU239
 933 007a 80E2      		ldi r24,lo8(32)
 934 007c 8D0F      		add r24,r29
 240:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 935               		.loc 1 240 24 view .LVU240
 936 007e 8830      		cpi r24,lo8(8)
 937 0080 00F0      		brlo .L68
 240:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 938               		.loc 1 240 49 discriminator 1 view .LVU241
 939 0082 D111      		cpse r29,__zero_reg__
 940 0084 00C0      		rjmp .L69
 941               	.L68:
 244:tmk_core/common/action.c ****                     } else {
 942               		.loc 1 244 25 is_stmt 1 view .LVU242
 943 0086 802F      		mov r24,r16
 944 0088 0E94 0000 		call add_mods
 945               	.LVL93:
 946               	.L70:
 248:tmk_core/common/action.c ****                 }
 947               		.loc 1 248 21 view .LVU243
 948 008c 0E94 0000 		call send_keyboard_report
 949               	.LVL94:
 250:tmk_core/common/action.c ****             } else {
 950               		.loc 1 250 17 view .LVU244
 951               	.L168:
 250:tmk_core/common/action.c ****             } else {
 952               		.loc 1 250 17 is_stmt 0 view .LVU245
 953               	.LBE42:
 541:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 954               		.loc 1 541 75 is_stmt 1 view .LVU246
 542:tmk_core/common/action.c ****                         } else {
 955               		.loc 1 542 29 view .LVU247
 956 0090 8D2F      		mov r24,r29
 957 0092 0E94 0000 		call register_code
 958               	.LVL95:
 959 0096 00C0      		rjmp .L54
 960               	.LVL96:
 961               	.L69:
 962               	.LBB43:
 246:tmk_core/common/action.c ****                     }
 963               		.loc 1 246 25 view .LVU248
 964 0098 802F      		mov r24,r16
 965 009a 0E94 0000 		call add_weak_mods
 966               	.LVL97:
 967 009e 00C0      		rjmp .L70
 968               	.L66:
 252:tmk_core/common/action.c ****                 if (mods) {
 969               		.loc 1 252 17 view .LVU249
 970 00a0 8D2F      		mov r24,r29
 971 00a2 0E94 0000 		call unregister_code
 972               	.LVL98:
 253:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 973               		.loc 1 253 17 view .LVU250
 253:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 974               		.loc 1 253 20 is_stmt 0 view .LVU251
 975 00a6 0023      		tst r16
 976 00a8 01F0      		breq .L54
 254:tmk_core/common/action.c ****                         del_mods(mods);
 977               		.loc 1 254 21 is_stmt 1 view .LVU252
 254:tmk_core/common/action.c ****                         del_mods(mods);
 978               		.loc 1 254 25 is_stmt 0 view .LVU253
 979 00aa 80E2      		ldi r24,lo8(32)
 980 00ac 8D0F      		add r24,r29
 254:tmk_core/common/action.c ****                         del_mods(mods);
 981               		.loc 1 254 24 view .LVU254
 982 00ae 8830      		cpi r24,lo8(8)
 983 00b0 00F0      		brlo .L72
 254:tmk_core/common/action.c ****                         del_mods(mods);
 984               		.loc 1 254 49 discriminator 1 view .LVU255
 985 00b2 D111      		cpse r29,__zero_reg__
 986 00b4 00C0      		rjmp .L73
 987               	.L72:
 255:tmk_core/common/action.c ****                     } else {
 988               		.loc 1 255 25 is_stmt 1 view .LVU256
 989 00b6 802F      		mov r24,r16
 990 00b8 0E94 0000 		call del_mods
 991               	.LVL99:
 992               	.L74:
 259:tmk_core/common/action.c ****                 }
 993               		.loc 1 259 21 view .LVU257
 994 00bc 0E94 0000 		call send_keyboard_report
 995               	.LVL100:
 996               	.L54:
 259:tmk_core/common/action.c ****                 }
 997               		.loc 1 259 21 is_stmt 0 view .LVU258
 998               	.LBE43:
 646:tmk_core/common/action.c ****         case ACT_LAYER:
 999               		.loc 1 646 5 is_stmt 1 view .LVU259
 1000 00c0 2B2D      		mov r18,r11
 1001 00c2 2850      		subi r18,8
 1002 00c4 330B      		sbc r19,r19
 1003 00c6 2430      		cpi r18,4
 1004 00c8 3105      		cpc r19,__zero_reg__
 1005 00ca 00F4      		brsh .L131
 653:tmk_core/common/action.c ****             break;
 1006               		.loc 1 653 13 view .LVU260
 1007 00cc 0E94 0000 		call host_keyboard_leds
 1008               	.LVL101:
 1009 00d0 0E94 0000 		call led_set
 1010               	.LVL102:
 654:tmk_core/common/action.c ****         default:
 1011               		.loc 1 654 13 view .LVU261
 1012               	.L131:
 688:tmk_core/common/action.c ****         record->event.pressed = false;
 1013               		.loc 1 688 5 view .LVU262
 688:tmk_core/common/action.c ****         record->event.pressed = false;
 1014               		.loc 1 688 8 is_stmt 0 view .LVU263
 1015 00d4 EE20      		tst r14
 1016 00d6 01F4      		brne .+2
 1017 00d8 00C0      		rjmp .L51
 688:tmk_core/common/action.c ****         record->event.pressed = false;
 1018               		.loc 1 688 33 discriminator 1 view .LVU264
 1019 00da 0E94 0000 		call get_oneshot_layer_state
 1020               	.LVL103:
 688:tmk_core/common/action.c ****         record->event.pressed = false;
 1021               		.loc 1 688 28 discriminator 1 view .LVU265
 1022 00de 80FD      		sbrc r24,0
 1023 00e0 00C0      		rjmp .L51
 689:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1024               		.loc 1 689 9 is_stmt 1 view .LVU266
 689:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1025               		.loc 1 689 31 is_stmt 0 view .LVU267
 1026 00e2 F601      		movw r30,r12
 1027 00e4 1282      		std Z+2,__zero_reg__
 690:tmk_core/common/action.c ****         process_record(record);
 1028               		.loc 1 690 9 is_stmt 1 view .LVU268
 1029 00e6 0E94 0000 		call get_oneshot_layer
 1030               	.LVL104:
 1031 00ea 0E94 0000 		call layer_on
 1032               	.LVL105:
 691:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1033               		.loc 1 691 9 view .LVU269
 1034 00ee C601      		movw r24,r12
 1035 00f0 0E94 0000 		call process_record
 1036               	.LVL106:
 692:tmk_core/common/action.c ****     }
 1037               		.loc 1 692 9 view .LVU270
 1038 00f4 0E94 0000 		call get_oneshot_layer
 1039               	.LVL107:
 1040               	/* epilogue start */
 695:tmk_core/common/action.c **** 
 1041               		.loc 1 695 1 is_stmt 0 view .LVU271
 1042 00f8 DF91      		pop r29
 1043               	.LVL108:
 695:tmk_core/common/action.c **** 
 1044               		.loc 1 695 1 view .LVU272
 1045 00fa CF91      		pop r28
 695:tmk_core/common/action.c **** 
 1046               		.loc 1 695 1 view .LVU273
 1047 00fc 1F91      		pop r17
 1048 00fe 0F91      		pop r16
 1049 0100 FF90      		pop r15
 1050 0102 EF90      		pop r14
 1051               	.LVL109:
 695:tmk_core/common/action.c **** 
 1052               		.loc 1 695 1 view .LVU274
 1053 0104 DF90      		pop r13
 1054 0106 CF90      		pop r12
 1055               	.LVL110:
 695:tmk_core/common/action.c **** 
 1056               		.loc 1 695 1 view .LVU275
 1057 0108 BF90      		pop r11
 692:tmk_core/common/action.c ****     }
 1058               		.loc 1 692 9 view .LVU276
 1059 010a 0C94 0000 		jmp layer_off
 1060               	.LVL111:
 1061               	.L73:
 1062               	.LBB44:
 257:tmk_core/common/action.c ****                     }
 1063               		.loc 1 257 25 is_stmt 1 view .LVU277
 1064 010e 802F      		mov r24,r16
 1065 0110 0E94 0000 		call del_weak_mods
 1066               	.LVL112:
 1067 0114 00C0      		rjmp .L74
 1068               	.LVL113:
 1069               	.L63:
 257:tmk_core/common/action.c ****                     }
 1070               		.loc 1 257 25 is_stmt 0 view .LVU278
 1071               	.LBE44:
 1072               	.LBB45:
 266:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1073               		.loc 1 266 13 is_stmt 1 view .LVU279
 1074 0116 FC2F      		mov r31,r28
 1075 0118 FF70      		andi r31,lo8(15)
 1076 011a FF2E      		mov r15,r31
 266:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1077               		.loc 1 266 44 is_stmt 0 view .LVU280
 1078 011c C07F      		andi r28,lo8(-16)
 1079               	.LVL114:
 266:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1080               		.loc 1 266 21 view .LVU281
 1081 011e C032      		cpi r28,lo8(32)
 1082 0120 01F0      		breq .L75
 266:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1083               		.loc 1 266 21 discriminator 2 view .LVU282
 1084 0122 F294      		swap r15
 1085 0124 80EF      		ldi r24,lo8(-16)
 1086 0126 F822      		and r15,r24
 1087               	.L75:
 1088               	.LVL115:
 267:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1089               		.loc 1 267 13 is_stmt 1 discriminator 4 view .LVU283
 1090 0128 DD23      		tst r29
 1091 012a 01F0      		breq .L76
 1092 012c D130      		cpi r29,lo8(1)
 1093 012e 01F0      		breq .L77
 322:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1094               		.loc 1 322 21 view .LVU284
 322:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1095               		.loc 1 322 24 is_stmt 0 view .LVU285
 1096 0130 1123      		tst r17
 1097 0132 01F0      		breq .L85
 323:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1098               		.loc 1 323 25 is_stmt 1 view .LVU286
 323:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1099               		.loc 1 323 28 is_stmt 0 view .LVU287
 1100 0134 0023      		tst r16
 1101 0136 01F0      		breq .L86
 325:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1102               		.loc 1 325 29 is_stmt 1 view .LVU288
 329:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1103               		.loc 1 329 33 is_stmt 0 view .LVU289
 1104 0138 F601      		movw r30,r12
 1105 013a 8581      		ldd r24,Z+5
 325:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1106               		.loc 1 325 32 view .LVU290
 1107 013c 80FF      		sbrs r24,0
 1108 013e 00C0      		rjmp .L168
 330:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 1109               		.loc 1 330 76 is_stmt 1 view .LVU291
 332:tmk_core/common/action.c ****                                 register_mods(mods);
 1110               		.loc 1 332 33 view .LVU292
 332:tmk_core/common/action.c ****                                 register_mods(mods);
 1111               		.loc 1 332 51 is_stmt 0 view .LVU293
 1112 0140 8F70      		andi r24,lo8(15)
 1113 0142 8583      		std Z+5,r24
 333:tmk_core/common/action.c ****                             } else
 1114               		.loc 1 333 33 is_stmt 1 view .LVU294
 1115 0144 00C0      		rjmp .L86
 1116               	.L76:
 271:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1117               		.loc 1 271 21 view .LVU295
 271:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1118               		.loc 1 271 24 is_stmt 0 view .LVU296
 1119 0146 1123      		tst r17
 1120 0148 01F0      		breq .L79
 272:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1121               		.loc 1 272 25 is_stmt 1 view .LVU297
 272:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1122               		.loc 1 272 28 is_stmt 0 view .LVU298
 1123 014a 0111      		cpse r16,__zero_reg__
 1124 014c 00C0      		rjmp .L80
 1125               	.L81:
 286:tmk_core/common/action.c ****                         }
 1126               		.loc 1 286 29 is_stmt 1 view .LVU299
 286:tmk_core/common/action.c ****                         }
 1127               		.loc 1 286 50 is_stmt 0 view .LVU300
 1128 014e 0E94 0000 		call get_oneshot_mods
 1129               	.LVL116:
 286:tmk_core/common/action.c ****                         }
 1130               		.loc 1 286 29 view .LVU301
 1131 0152 8F29      		or r24,r15
 1132               	.LVL117:
 1133               	.L167:
 286:tmk_core/common/action.c ****                         }
 1134               		.loc 1 286 29 view .LVU302
 1135               	.LBE45:
 468:tmk_core/common/action.c ****             } else {
 1136               		.loc 1 468 17 view .LVU303
 1137 0154 0E94 0000 		call register_mods
 1138               	.LVL118:
 1139 0158 00C0      		rjmp .L54
 1140               	.LVL119:
 1141               	.L80:
 1142               	.LBB48:
 275:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1143               		.loc 1 275 32 is_stmt 1 view .LVU304
 275:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1144               		.loc 1 275 35 is_stmt 0 view .LVU305
 1145 015a 0130      		cpi r16,lo8(1)
 1146 015c 01F4      		brne .L81
 276:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1147               		.loc 1 276 65 is_stmt 1 view .LVU306
 277:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1148               		.loc 1 277 29 view .LVU307
 277:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1149               		.loc 1 277 53 is_stmt 0 view .LVU308
 1150 015e 0E94 0000 		call get_oneshot_mods
 1151               	.LVL120:
 277:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1152               		.loc 1 277 29 view .LVU309
 1153 0162 8F29      		or r24,r15
 1154 0164 0E94 0000 		call set_oneshot_mods
 1155               	.LVL121:
 1156 0168 00C0      		rjmp .L54
 1157               	.L79:
 289:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1158               		.loc 1 289 25 is_stmt 1 view .LVU310
 289:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1159               		.loc 1 289 28 is_stmt 0 view .LVU311
 1160 016a 0111      		cpse r16,__zero_reg__
 1161 016c 00C0      		rjmp .L82
 1162               	.L170:
 304:tmk_core/common/action.c ****                             unregister_mods(mods);
 1163               		.loc 1 304 29 is_stmt 1 view .LVU312
 1164 016e 0E94 0000 		call clear_oneshot_mods
 1165               	.LVL122:
 305:tmk_core/common/action.c ****                         }
 1166               		.loc 1 305 29 view .LVU313
 1167               	.L88:
 352:tmk_core/common/action.c ****                             unregister_mods(mods);
 1168               		.loc 1 352 67 view .LVU314
 353:tmk_core/common/action.c ****                         }
 1169               		.loc 1 353 29 view .LVU315
 1170 0172 8F2D      		mov r24,r15
 1171 0174 0E94 0000 		call unregister_mods
 1172               	.LVL123:
 1173 0178 00C0      		rjmp .L54
 1174               	.L82:
 292:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1175               		.loc 1 292 32 view .LVU316
 292:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1176               		.loc 1 292 35 is_stmt 0 view .LVU317
 1177 017a 0130      		cpi r16,lo8(1)
 1178 017c 01F4      		brne .+2
 1179 017e 00C0      		rjmp .L54
 1180 0180 00C0      		rjmp .L170
 1181               	.L77:
 311:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1182               		.loc 1 311 21 is_stmt 1 view .LVU318
 311:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1183               		.loc 1 311 24 is_stmt 0 view .LVU319
 1184 0182 1123      		tst r17
 1185 0184 01F0      		breq .L84
 312:tmk_core/common/action.c ****                             register_mods(mods);
 1186               		.loc 1 312 25 is_stmt 1 view .LVU320
 312:tmk_core/common/action.c ****                             register_mods(mods);
 1187               		.loc 1 312 28 is_stmt 0 view .LVU321
 1188 0186 0630      		cpi r16,lo8(6)
 1189 0188 00F0      		brlo .+2
 1190 018a 00C0      		rjmp .L54
 1191               	.L86:
 341:tmk_core/common/action.c ****                             register_mods(mods);
 1192               		.loc 1 341 67 is_stmt 1 view .LVU322
 342:tmk_core/common/action.c ****                         }
 1193               		.loc 1 342 29 view .LVU323
 1194 018c 8F2D      		mov r24,r15
 1195 018e 00C0      		rjmp .L167
 1196               	.L84:
 316:tmk_core/common/action.c ****                             unregister_mods(mods);
 1197               		.loc 1 316 25 view .LVU324
 316:tmk_core/common/action.c ****                             unregister_mods(mods);
 1198               		.loc 1 316 28 is_stmt 0 view .LVU325
 1199 0190 0530      		cpi r16,lo8(5)
 1200 0192 00F0      		brlo .+2
 1201 0194 00C0      		rjmp .L54
 1202 0196 00C0      		rjmp .L88
 1203               	.L85:
 345:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1204               		.loc 1 345 25 is_stmt 1 view .LVU326
 345:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1205               		.loc 1 345 28 is_stmt 0 view .LVU327
 1206 0198 0023      		tst r16
 1207 019a 01F0      		breq .L88
 346:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1208               		.loc 1 346 71 is_stmt 1 view .LVU328
 347:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1209               		.loc 1 347 29 view .LVU329
 347:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1210               		.loc 1 347 32 is_stmt 0 view .LVU330
 1211 019c D933      		cpi r29,lo8(57)
 1212 019e 01F4      		brne .L130
 348:tmk_core/common/action.c ****                             }
 1213               		.loc 1 348 33 is_stmt 1 view .LVU331
 1214               	.LVL124:
 1215               	.LBB46:
 1216               	.LBI46:
 166:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 1217               		.loc 2 166 1 view .LVU332
 1218               	.LBB47:
 168:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1219               		.loc 2 168 2 view .LVU333
 172:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1220               		.loc 2 172 2 view .LVU334
 173:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1221               		.loc 2 173 2 view .LVU335
 174:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1222               		.loc 2 174 2 view .LVU336
 184:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 1223               		.loc 2 184 3 view .LVU337
 1224               		.loc 2 187 2 view .LVU338
 1225 01a0 FFEF      		ldi r31,lo8(255999)
 1226 01a2 27EE      		ldi r18,hi8(255999)
 1227 01a4 33E0      		ldi r19,hlo8(255999)
 1228 01a6 F150      	1:	subi r31,1
 1229 01a8 2040      		sbci r18,0
 1230 01aa 3040      		sbci r19,0
 1231 01ac 01F4      		brne 1b
 1232               	.LVL125:
 1233               	.L171:
 1234               		.loc 2 187 2 is_stmt 0 view .LVU339
 1235               	.LBE47:
 1236               	.LBE46:
 1237               	.LBE48:
 1238               	.LBB49:
 1239               	.LBB50:
 1240 01ae 00C0      		rjmp .
 1241 01b0 0000      		nop
 1242               	.L130:
 1243               	.LBE50:
 1244               	.LBE49:
 555:tmk_core/common/action.c ****                         } else {
 1245               		.loc 1 555 29 is_stmt 1 view .LVU340
 1246 01b2 8D2F      		mov r24,r29
 1247 01b4 0E94 0000 		call unregister_code
 1248               	.LVL126:
 1249 01b8 00C0      		rjmp .L54
 1250               	.L62:
 363:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1251               		.loc 1 363 13 view .LVU341
 363:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1252               		.loc 1 363 33 is_stmt 0 view .LVU342
 1253 01ba 8C2F      		mov r24,r28
 1254 01bc 8695      		lsr r24
 1255 01be 8695      		lsr r24
 1256 01c0 8370      		andi r24,lo8(3)
 1257 01c2 01F0      		breq .L90
 1258 01c4 8130      		cpi r24,lo8(1)
 1259 01c6 01F0      		breq .+2
 1260 01c8 00C0      		rjmp .L54
 372:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1261               		.loc 1 372 21 is_stmt 1 view .LVU343
 373:tmk_core/common/action.c ****                     } else {
 1262               		.loc 1 373 25 is_stmt 0 view .LVU344
 1263 01ca 8D2F      		mov r24,r29
 1264 01cc 9C2F      		mov r25,r28
 1265 01ce 9370      		andi r25,lo8(3)
 372:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1266               		.loc 1 372 24 view .LVU345
 1267 01d0 1111      		cpse r17,__zero_reg__
 1268 01d2 00C0      		rjmp .L169
 375:tmk_core/common/action.c ****                     }
 1269               		.loc 1 375 25 is_stmt 1 view .LVU346
 1270 01d4 90E0      		ldi r25,0
 1271 01d6 80E0      		ldi r24,0
 1272               	.L169:
 1273 01d8 0E94 0000 		call host_consumer_send
 1274               	.LVL127:
 1275 01dc 00C0      		rjmp .L54
 1276               	.L90:
 365:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1277               		.loc 1 365 21 view .LVU347
 366:tmk_core/common/action.c ****                     } else {
 1278               		.loc 1 366 25 is_stmt 0 view .LVU348
 1279 01de 8D2F      		mov r24,r29
 1280 01e0 9C2F      		mov r25,r28
 1281 01e2 9370      		andi r25,lo8(3)
 365:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1282               		.loc 1 365 24 view .LVU349
 1283 01e4 1111      		cpse r17,__zero_reg__
 1284 01e6 00C0      		rjmp .L164
 368:tmk_core/common/action.c ****                     }
 1285               		.loc 1 368 25 is_stmt 1 view .LVU350
 1286 01e8 90E0      		ldi r25,0
 1287 01ea 80E0      		ldi r24,0
 1288               	.L164:
 1289 01ec 0E94 0000 		call host_system_send
 1290               	.LVL128:
 1291 01f0 00C0      		rjmp .L54
 1292               	.L61:
 384:tmk_core/common/action.c ****                 switch (action.key.code) {
 1293               		.loc 1 384 13 view .LVU351
 384:tmk_core/common/action.c ****                 switch (action.key.code) {
 1294               		.loc 1 384 16 is_stmt 0 view .LVU352
 1295 01f2 1123      		tst r17
 1296 01f4 01F0      		breq .L94
 385:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1297               		.loc 1 385 17 is_stmt 1 view .LVU353
 1298 01f6 D53F      		cpi r29,lo8(-11)
 1299 01f8 01F0      		breq .L95
 1300 01fa D63F      		cpi r29,lo8(-10)
 1301 01fc 01F0      		breq .L96
 1302 01fe D43F      		cpi r29,lo8(-12)
 1303 0200 01F4      		brne .L97
 387:tmk_core/common/action.c ****                         break;
 1304               		.loc 1 387 25 view .LVU354
 387:tmk_core/common/action.c ****                         break;
 1305               		.loc 1 387 36 is_stmt 0 view .LVU355
 1306 0202 8091 0000 		lds r24,tp_buttons
 1307 0206 9091 0000 		lds r25,tp_buttons+1
 1308 020a 8160      		ori r24,1
 1309               	.L161:
 393:tmk_core/common/action.c ****                         break;
 1310               		.loc 1 393 36 view .LVU356
 1311 020c 9093 0000 		sts tp_buttons+1,r25
 1312 0210 8093 0000 		sts tp_buttons,r24
 394:tmk_core/common/action.c ****                     default:
 1313               		.loc 1 394 25 is_stmt 1 view .LVU357
 1314               	.L97:
 398:tmk_core/common/action.c ****                 mousekey_send();
 1315               		.loc 1 398 17 view .LVU358
 1316 0214 8D2F      		mov r24,r29
 1317 0216 0E94 0000 		call mousekey_on
 1318               	.LVL129:
 399:tmk_core/common/action.c ****             } else {
 1319               		.loc 1 399 17 view .LVU359
 1320               	.L165:
 415:tmk_core/common/action.c ****             }
 1321               		.loc 1 415 17 view .LVU360
 1322 021a 0E94 0000 		call mousekey_send
 1323               	.LVL130:
 1324 021e 00C0      		rjmp .L54
 1325               	.L95:
 390:tmk_core/common/action.c ****                         break;
 1326               		.loc 1 390 25 view .LVU361
 390:tmk_core/common/action.c ****                         break;
 1327               		.loc 1 390 36 is_stmt 0 view .LVU362
 1328 0220 8091 0000 		lds r24,tp_buttons
 1329 0224 9091 0000 		lds r25,tp_buttons+1
 1330 0228 8260      		ori r24,2
 1331 022a 00C0      		rjmp .L161
 1332               	.L96:
 393:tmk_core/common/action.c ****                         break;
 1333               		.loc 1 393 25 is_stmt 1 view .LVU363
 393:tmk_core/common/action.c ****                         break;
 1334               		.loc 1 393 36 is_stmt 0 view .LVU364
 1335 022c 8091 0000 		lds r24,tp_buttons
 1336 0230 9091 0000 		lds r25,tp_buttons+1
 1337 0234 8460      		ori r24,4
 1338 0236 00C0      		rjmp .L161
 1339               	.L94:
 401:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1340               		.loc 1 401 17 is_stmt 1 view .LVU365
 1341 0238 D53F      		cpi r29,lo8(-11)
 1342 023a 01F0      		breq .L98
 1343 023c D63F      		cpi r29,lo8(-10)
 1344 023e 01F0      		breq .L99
 1345 0240 D43F      		cpi r29,lo8(-12)
 1346 0242 01F4      		brne .L100
 403:tmk_core/common/action.c ****                         break;
 1347               		.loc 1 403 25 view .LVU366
 403:tmk_core/common/action.c ****                         break;
 1348               		.loc 1 403 36 is_stmt 0 view .LVU367
 1349 0244 8091 0000 		lds r24,tp_buttons
 1350 0248 9091 0000 		lds r25,tp_buttons+1
 1351 024c 8E7F      		andi r24,254
 1352               	.L162:
 409:tmk_core/common/action.c ****                         break;
 1353               		.loc 1 409 36 view .LVU368
 1354 024e 9093 0000 		sts tp_buttons+1,r25
 1355 0252 8093 0000 		sts tp_buttons,r24
 410:tmk_core/common/action.c ****                     default:
 1356               		.loc 1 410 25 is_stmt 1 view .LVU369
 1357               	.L100:
 414:tmk_core/common/action.c ****                 mousekey_send();
 1358               		.loc 1 414 17 view .LVU370
 1359 0256 8D2F      		mov r24,r29
 1360 0258 0E94 0000 		call mousekey_off
 1361               	.LVL131:
 1362 025c 00C0      		rjmp .L165
 1363               	.L98:
 406:tmk_core/common/action.c ****                         break;
 1364               		.loc 1 406 25 view .LVU371
 406:tmk_core/common/action.c ****                         break;
 1365               		.loc 1 406 36 is_stmt 0 view .LVU372
 1366 025e 8091 0000 		lds r24,tp_buttons
 1367 0262 9091 0000 		lds r25,tp_buttons+1
 1368 0266 8D7F      		andi r24,253
 1369 0268 00C0      		rjmp .L162
 1370               	.L99:
 409:tmk_core/common/action.c ****                         break;
 1371               		.loc 1 409 25 is_stmt 1 view .LVU373
 409:tmk_core/common/action.c ****                         break;
 1372               		.loc 1 409 36 is_stmt 0 view .LVU374
 1373 026a 8091 0000 		lds r24,tp_buttons
 1374 026e 9091 0000 		lds r25,tp_buttons+1
 1375 0272 8B7F      		andi r24,251
 1376 0274 00C0      		rjmp .L162
 1377               	.L60:
 421:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1378               		.loc 1 421 13 is_stmt 1 view .LVU375
 421:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1379               		.loc 1 421 39 is_stmt 0 view .LVU376
 1380 0276 8C2F      		mov r24,r28
 1381 0278 8370      		andi r24,lo8(3)
 421:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1382               		.loc 1 421 16 view .LVU377
 1383 027a 01F0      		breq .+2
 1384 027c 00C0      		rjmp .L101
 423:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1385               		.loc 1 423 17 is_stmt 1 view .LVU378
 423:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1386               		.loc 1 423 20 is_stmt 0 view .LVU379
 1387 027e 1111      		cpse r17,__zero_reg__
 1388 0280 00C0      		rjmp .L54
 1389               	.LBB52:
 424:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1390               		.loc 1 424 21 is_stmt 1 view .LVU380
 1391               	.LVL132:
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1392               		.loc 1 425 21 view .LVU381
 424:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1393               		.loc 1 424 61 is_stmt 0 view .LVU382
 1394 0282 4D2F      		mov r20,r29
 1395 0284 4295      		swap r20
 1396 0286 4695      		lsr r20
 1397 0288 4770      		andi r20,lo8(7)
 424:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1398               		.loc 1 424 35 view .LVU383
 1399 028a 440F      		lsl r20
 1400 028c 440F      		lsl r20
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1401               		.loc 1 425 77 view .LVU384
 1402 028e 0D2F      		mov r16,r29
 1403               	.LVL133:
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1404               		.loc 1 425 77 view .LVU385
 1405 0290 0F70      		andi r16,lo8(15)
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1406               		.loc 1 425 44 view .LVU386
 1407 0292 10E0      		ldi r17,0
 1408               	.LVL134:
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1409               		.loc 1 425 44 view .LVU387
 1410 0294 30E0      		ldi r19,0
 1411 0296 20E0      		ldi r18,0
 425:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1412               		.loc 1 425 35 view .LVU388
 1413 0298 042E      		mov r0,r20
 1414 029a 00C0      		rjmp 2f
 1415               		1:
 1416 029c 000F      		lsl r16
 1417 029e 111F      		rol r17
 1418 02a0 221F      		rol r18
 1419 02a2 331F      		rol r19
 1420               		2:
 1421 02a4 0A94      		dec r0
 1422 02a6 02F4      		brpl 1b
 1423               	.LVL135:
 426:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1424               		.loc 1 426 21 is_stmt 1 view .LVU389
 426:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1425               		.loc 1 426 104 is_stmt 0 view .LVU390
 1426 02a8 60E0      		ldi r22,0
 1427 02aa 70E0      		ldi r23,0
 1428 02ac CB01      		movw r24,r22
 1429 02ae D4FF      		sbrs r29,4
 1430 02b0 00C0      		rjmp .L102
 426:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1431               		.loc 1 426 94 discriminator 1 view .LVU391
 1432 02b2 6FE0      		ldi r22,lo8(15)
 1433 02b4 70E0      		ldi r23,0
 1434 02b6 80E0      		ldi r24,0
 1435 02b8 90E0      		ldi r25,0
 1436 02ba 00C0      		rjmp 2f
 1437               		1:
 1438 02bc 660F      		lsl r22
 1439 02be 771F      		rol r23
 1440 02c0 881F      		rol r24
 1441 02c2 991F      		rol r25
 1442               		2:
 1443 02c4 4A95      		dec r20
 1444 02c6 02F4      		brpl 1b
 426:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1445               		.loc 1 426 104 discriminator 1 view .LVU392
 1446 02c8 6095      		com r22
 1447 02ca 7095      		com r23
 1448 02cc 8095      		com r24
 1449 02ce 9095      		com r25
 1450               	.L102:
 1451               	.LVL136:
 427:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1452               		.loc 1 427 21 is_stmt 1 discriminator 4 view .LVU393
 427:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1453               		.loc 1 427 47 is_stmt 0 discriminator 4 view .LVU394
 1454 02d0 C695      		lsr r28
 1455 02d2 C695      		lsr r28
 1456               	.LVL137:
 427:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1457               		.loc 1 427 47 discriminator 4 view .LVU395
 1458 02d4 C370      		andi r28,lo8(3)
 1459 02d6 602B      		or r22,r16
 1460               	.LVL138:
 427:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1461               		.loc 1 427 47 discriminator 4 view .LVU396
 1462 02d8 712B      		or r23,r17
 1463 02da 822B      		or r24,r18
 1464 02dc 932B      		or r25,r19
 1465 02de C230      		cpi r28,lo8(2)
 1466 02e0 01F0      		breq .L103
 1467 02e2 00F4      		brsh .L104
 1468 02e4 C130      		cpi r28,lo8(1)
 1469 02e6 01F0      		breq .L105
 429:tmk_core/common/action.c ****                             break;
 1470               		.loc 1 429 29 is_stmt 1 view .LVU397
 1471 02e8 0E94 0000 		call default_layer_and
 1472               	.LVL139:
 430:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1473               		.loc 1 430 29 view .LVU398
 1474 02ec 00C0      		rjmp .L54
 1475               	.L105:
 432:tmk_core/common/action.c ****                             break;
 1476               		.loc 1 432 29 view .LVU399
 1477 02ee 0E94 0000 		call default_layer_or
 1478               	.LVL140:
 433:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1479               		.loc 1 433 29 view .LVU400
 1480 02f2 00C0      		rjmp .L54
 1481               	.L103:
 435:tmk_core/common/action.c ****                             break;
 1482               		.loc 1 435 29 view .LVU401
 1483 02f4 0E94 0000 		call default_layer_xor
 1484               	.LVL141:
 436:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1485               		.loc 1 436 29 view .LVU402
 1486 02f8 00C0      		rjmp .L54
 1487               	.L104:
 438:tmk_core/common/action.c ****                             break;
 1488               		.loc 1 438 29 view .LVU403
 1489 02fa 0E94 0000 		call default_layer_set
 1490               	.LVL142:
 439:tmk_core/common/action.c ****                     }
 1491               		.loc 1 439 29 view .LVU404
 1492 02fe 00C0      		rjmp .L54
 1493               	.LVL143:
 1494               	.L101:
 439:tmk_core/common/action.c ****                     }
 1495               		.loc 1 439 29 is_stmt 0 view .LVU405
 1496               	.LBE52:
 444:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1497               		.loc 1 444 17 is_stmt 1 view .LVU406
 444:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1498               		.loc 1 444 21 is_stmt 0 view .LVU407
 1499 0300 8695      		lsr r24
 1500 0302 1123      		tst r17
 1501 0304 01F0      		breq .L107
 444:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1502               		.loc 1 444 21 discriminator 1 view .LVU408
 1503 0306 8C2F      		mov r24,r28
 1504 0308 8170      		andi r24,lo8(1)
 1505               	.L107:
 444:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1506               		.loc 1 444 20 discriminator 4 view .LVU409
 1507 030a 8823      		tst r24
 1508 030c 01F4      		brne .+2
 1509 030e 00C0      		rjmp .L54
 1510               	.LBB53:
 445:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1511               		.loc 1 445 21 is_stmt 1 view .LVU410
 1512               	.LVL144:
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1513               		.loc 1 446 21 view .LVU411
 445:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1514               		.loc 1 445 61 is_stmt 0 view .LVU412
 1515 0310 4D2F      		mov r20,r29
 1516 0312 4295      		swap r20
 1517 0314 4695      		lsr r20
 1518 0316 4770      		andi r20,lo8(7)
 445:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1519               		.loc 1 445 35 view .LVU413
 1520 0318 440F      		lsl r20
 1521 031a 440F      		lsl r20
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1522               		.loc 1 446 77 view .LVU414
 1523 031c 0D2F      		mov r16,r29
 1524               	.LVL145:
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1525               		.loc 1 446 77 view .LVU415
 1526 031e 0F70      		andi r16,lo8(15)
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1527               		.loc 1 446 44 view .LVU416
 1528 0320 10E0      		ldi r17,0
 1529               	.LVL146:
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1530               		.loc 1 446 44 view .LVU417
 1531 0322 30E0      		ldi r19,0
 1532 0324 20E0      		ldi r18,0
 446:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1533               		.loc 1 446 35 view .LVU418
 1534 0326 042E      		mov r0,r20
 1535 0328 00C0      		rjmp 2f
 1536               		1:
 1537 032a 000F      		lsl r16
 1538 032c 111F      		rol r17
 1539 032e 221F      		rol r18
 1540 0330 331F      		rol r19
 1541               		2:
 1542 0332 0A94      		dec r0
 1543 0334 02F4      		brpl 1b
 1544               	.LVL147:
 447:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1545               		.loc 1 447 21 is_stmt 1 view .LVU419
 447:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1546               		.loc 1 447 104 is_stmt 0 view .LVU420
 1547 0336 60E0      		ldi r22,0
 1548 0338 70E0      		ldi r23,0
 1549 033a CB01      		movw r24,r22
 1550 033c D4FF      		sbrs r29,4
 1551 033e 00C0      		rjmp .L108
 447:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1552               		.loc 1 447 94 discriminator 1 view .LVU421
 1553 0340 6FE0      		ldi r22,lo8(15)
 1554 0342 70E0      		ldi r23,0
 1555 0344 80E0      		ldi r24,0
 1556 0346 90E0      		ldi r25,0
 1557 0348 00C0      		rjmp 2f
 1558               		1:
 1559 034a 660F      		lsl r22
 1560 034c 771F      		rol r23
 1561 034e 881F      		rol r24
 1562 0350 991F      		rol r25
 1563               		2:
 1564 0352 4A95      		dec r20
 1565 0354 02F4      		brpl 1b
 447:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1566               		.loc 1 447 104 discriminator 1 view .LVU422
 1567 0356 6095      		com r22
 1568 0358 7095      		com r23
 1569 035a 8095      		com r24
 1570 035c 9095      		com r25
 1571               	.L108:
 1572               	.LVL148:
 448:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1573               		.loc 1 448 21 is_stmt 1 discriminator 4 view .LVU423
 448:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1574               		.loc 1 448 47 is_stmt 0 discriminator 4 view .LVU424
 1575 035e C695      		lsr r28
 1576 0360 C695      		lsr r28
 1577               	.LVL149:
 448:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1578               		.loc 1 448 47 discriminator 4 view .LVU425
 1579 0362 C370      		andi r28,lo8(3)
 1580 0364 602B      		or r22,r16
 1581               	.LVL150:
 448:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1582               		.loc 1 448 47 discriminator 4 view .LVU426
 1583 0366 712B      		or r23,r17
 1584 0368 822B      		or r24,r18
 1585 036a 932B      		or r25,r19
 1586 036c C230      		cpi r28,lo8(2)
 1587 036e 01F0      		breq .L109
 1588 0370 00F4      		brsh .L110
 1589 0372 C130      		cpi r28,lo8(1)
 1590 0374 01F0      		breq .L111
 450:tmk_core/common/action.c ****                             break;
 1591               		.loc 1 450 29 is_stmt 1 view .LVU427
 1592 0376 0E94 0000 		call layer_and
 1593               	.LVL151:
 451:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1594               		.loc 1 451 29 view .LVU428
 1595 037a 00C0      		rjmp .L54
 1596               	.L111:
 453:tmk_core/common/action.c ****                             break;
 1597               		.loc 1 453 29 view .LVU429
 1598 037c 0E94 0000 		call layer_or
 1599               	.LVL152:
 454:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1600               		.loc 1 454 29 view .LVU430
 1601 0380 00C0      		rjmp .L54
 1602               	.L109:
 456:tmk_core/common/action.c ****                             break;
 1603               		.loc 1 456 29 view .LVU431
 1604 0382 0E94 0000 		call layer_xor
 1605               	.LVL153:
 457:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1606               		.loc 1 457 29 view .LVU432
 1607 0386 00C0      		rjmp .L54
 1608               	.L110:
 459:tmk_core/common/action.c ****                             break;
 1609               		.loc 1 459 29 view .LVU433
 1610 0388 0E94 0000 		call layer_state_set
 1611               	.LVL154:
 460:tmk_core/common/action.c ****                     }
 1612               		.loc 1 460 29 view .LVU434
 1613 038c 00C0      		rjmp .L54
 1614               	.LVL155:
 1615               	.L59:
 460:tmk_core/common/action.c ****                     }
 1616               		.loc 1 460 29 is_stmt 0 view .LVU435
 1617               	.LBE53:
 466:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1618               		.loc 1 466 13 is_stmt 1 view .LVU436
 1619 038e CF70      		andi r28,lo8(15)
 1620               	.LVL156:
 466:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1621               		.loc 1 466 16 is_stmt 0 view .LVU437
 1622 0390 1123      		tst r17
 1623 0392 01F0      		breq .L112
 467:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1624               		.loc 1 467 17 is_stmt 1 view .LVU438
 1625 0394 8C2F      		mov r24,r28
 1626 0396 0E94 0000 		call layer_on
 1627               	.LVL157:
 468:tmk_core/common/action.c ****             } else {
 1628               		.loc 1 468 17 view .LVU439
 1629 039a 8D2F      		mov r24,r29
 1630 039c 00C0      		rjmp .L167
 1631               	.L112:
 470:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1632               		.loc 1 470 17 view .LVU440
 1633 039e 8D2F      		mov r24,r29
 1634 03a0 0E94 0000 		call unregister_mods
 1635               	.LVL158:
 471:tmk_core/common/action.c ****             }
 1636               		.loc 1 471 17 view .LVU441
 1637 03a4 8C2F      		mov r24,r28
 1638               	.LVL159:
 1639               	.L163:
 558:tmk_core/common/action.c ****                         }
 1640               		.loc 1 558 29 is_stmt 0 view .LVU442
 1641 03a6 0E94 0000 		call layer_off
 1642               	.LVL160:
 1643 03aa 00C0      		rjmp .L54
 1644               	.L58:
 477:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1645               		.loc 1 477 13 is_stmt 1 view .LVU443
 1646 03ac D23F      		cpi r29,lo8(-14)
 1647 03ae 01F0      		breq .L113
 1648 03b0 00F4      		brsh .L114
 1649 03b2 D03F      		cpi r29,lo8(-16)
 1650 03b4 01F0      		breq .L115
 1651 03b6 D13F      		cpi r29,lo8(-15)
 1652 03b8 01F0      		breq .L116
 1653               	.L117:
 539:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1654               		.loc 1 539 21 view .LVU444
 539:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1655               		.loc 1 539 24 is_stmt 0 view .LVU445
 1656 03ba 1123      		tst r17
 1657 03bc 01F4      		brne .+2
 1658 03be 00C0      		rjmp .L126
 540:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1659               		.loc 1 540 25 is_stmt 1 view .LVU446
 540:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1660               		.loc 1 540 28 is_stmt 0 view .LVU447
 1661 03c0 0111      		cpse r16,__zero_reg__
 1662 03c2 00C0      		rjmp .L168
 544:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1663               		.loc 1 544 76 is_stmt 1 view .LVU448
 545:tmk_core/common/action.c ****                         }
 1664               		.loc 1 545 29 view .LVU449
 1665 03c4 8C2F      		mov r24,r28
 1666 03c6 8F71      		andi r24,lo8(31)
 1667 03c8 00C0      		rjmp .L166
 1668               	.L114:
 1669 03ca D33F      		cpi r29,lo8(-13)
 1670 03cc 01F0      		breq .L118
 1671 03ce D43F      		cpi r29,lo8(-12)
 1672 03d0 01F4      		brne .L117
 525:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1673               		.loc 1 525 21 view .LVU450
 525:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1674               		.loc 1 525 24 is_stmt 0 view .LVU451
 1675 03d2 1123      		tst r17
 1676 03d4 01F0      		breq .L125
 526:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1677               		.loc 1 526 25 is_stmt 1 view .LVU452
 526:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1678               		.loc 1 526 50 is_stmt 0 view .LVU453
 1679 03d6 CF71      		andi r28,lo8(31)
 1680               	.LVL161:
 526:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1681               		.loc 1 526 25 view .LVU454
 1682 03d8 8C2F      		mov r24,r28
 1683 03da 0E94 0000 		call layer_on
 1684               	.LVL162:
 527:tmk_core/common/action.c ****                     } else {
 1685               		.loc 1 527 25 is_stmt 1 view .LVU455
 1686 03de 63E0      		ldi r22,lo8(3)
 1687 03e0 8C2F      		mov r24,r28
 1688 03e2 0E94 0000 		call set_oneshot_layer
 1689               	.LVL163:
 1690 03e6 00C0      		rjmp .L54
 1691               	.LVL164:
 1692               	.L115:
 480:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1693               		.loc 1 480 21 view .LVU456
 480:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1694               		.loc 1 480 24 is_stmt 0 view .LVU457
 1695 03e8 1123      		tst r17
 1696 03ea 01F0      		breq .L120
 481:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1697               		.loc 1 481 25 is_stmt 1 view .LVU458
 481:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1698               		.loc 1 481 28 is_stmt 0 view .LVU459
 1699 03ec 0530      		cpi r16,lo8(5)
 1700 03ee 00F0      		brlo .+2
 1701 03f0 00C0      		rjmp .L54
 1702               	.L121:
 482:tmk_core/common/action.c ****                         }
 1703               		.loc 1 482 29 is_stmt 1 view .LVU460
 1704 03f2 8C2F      		mov r24,r28
 1705 03f4 8F71      		andi r24,lo8(31)
 1706 03f6 0E94 0000 		call layer_invert
 1707               	.LVL165:
 1708 03fa 00C0      		rjmp .L54
 1709               	.L120:
 485:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1710               		.loc 1 485 25 view .LVU461
 485:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1711               		.loc 1 485 28 is_stmt 0 view .LVU462
 1712 03fc 0630      		cpi r16,lo8(6)
 1713 03fe 00F0      		brlo .+2
 1714 0400 00C0      		rjmp .L54
 1715 0402 00C0      		rjmp .L121
 1716               	.L116:
 491:tmk_core/common/action.c ****                     break;
 1717               		.loc 1 491 21 is_stmt 1 view .LVU463
 1718 0404 8C2F      		mov r24,r28
 1719 0406 8F71      		andi r24,lo8(31)
 491:tmk_core/common/action.c ****                     break;
 1720               		.loc 1 491 68 is_stmt 0 view .LVU464
 1721 0408 1123      		tst r17
 1722 040a 01F0      		breq .L163
 1723               	.L166:
 545:tmk_core/common/action.c ****                         }
 1724               		.loc 1 545 29 view .LVU465
 1725 040c 0E94 0000 		call layer_on
 1726               	.LVL166:
 1727 0410 00C0      		rjmp .L54
 1728               	.L113:
 494:tmk_core/common/action.c ****                     break;
 1729               		.loc 1 494 21 is_stmt 1 view .LVU466
 1730 0412 8C2F      		mov r24,r28
 1731 0414 8F71      		andi r24,lo8(31)
 494:tmk_core/common/action.c ****                     break;
 1732               		.loc 1 494 69 is_stmt 0 view .LVU467
 1733 0416 1123      		tst r17
 1734 0418 01F0      		breq .L166
 1735 041a 00C0      		rjmp .L163
 1736               	.L118:
 497:tmk_core/common/action.c ****                     break;
 1737               		.loc 1 497 21 is_stmt 1 view .LVU468
 497:tmk_core/common/action.c ****                     break;
 1738               		.loc 1 497 70 is_stmt 0 view .LVU469
 1739 041c 1123      		tst r17
 1740 041e 01F0      		breq .L124
 497:tmk_core/common/action.c ****                     break;
 1741               		.loc 1 497 37 discriminator 1 view .LVU470
 1742 0420 8C2F      		mov r24,r28
 1743 0422 8F71      		andi r24,lo8(31)
 1744 0424 0E94 0000 		call layer_move
 1745               	.LVL167:
 1746 0428 00C0      		rjmp .L54
 1747               	.L124:
 497:tmk_core/common/action.c ****                     break;
 1748               		.loc 1 497 72 discriminator 2 view .LVU471
 1749 042a 0E94 0000 		call layer_clear
 1750               	.LVL168:
 1751 042e 00C0      		rjmp .L54
 1752               	.L125:
 529:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1753               		.loc 1 529 25 is_stmt 1 view .LVU472
 1754 0430 81E0      		ldi r24,lo8(1)
 1755 0432 0E94 0000 		call clear_oneshot_layer_state
 1756               	.LVL169:
 530:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1757               		.loc 1 530 25 view .LVU473
 530:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1758               		.loc 1 530 28 is_stmt 0 view .LVU474
 1759 0436 0230      		cpi r16,lo8(2)
 1760 0438 00F4      		brsh .+2
 1761 043a 00C0      		rjmp .L54
 531:tmk_core/common/action.c ****                         }
 1762               		.loc 1 531 29 is_stmt 1 view .LVU475
 1763 043c 82E0      		ldi r24,lo8(2)
 1764 043e 0E94 0000 		call clear_oneshot_layer_state
 1765               	.LVL170:
 1766 0442 00C0      		rjmp .L54
 1767               	.L126:
 548:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1768               		.loc 1 548 25 view .LVU476
 548:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1769               		.loc 1 548 28 is_stmt 0 view .LVU477
 1770 0444 0023      		tst r16
 1771 0446 01F0      		breq .L128
 549:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1772               		.loc 1 549 77 is_stmt 1 view .LVU478
 550:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1773               		.loc 1 550 29 view .LVU479
 550:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1774               		.loc 1 550 32 is_stmt 0 view .LVU480
 1775 0448 D933      		cpi r29,lo8(57)
 1776 044a 01F0      		breq .+2
 1777 044c 00C0      		rjmp .L130
 551:tmk_core/common/action.c ****                             } else {
 1778               		.loc 1 551 33 is_stmt 1 view .LVU481
 1779               	.LVL171:
 1780               	.LBB54:
 1781               	.LBI49:
 166:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 1782               		.loc 2 166 1 view .LVU482
 1783               	.LBB51:
 168:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1784               		.loc 2 168 2 view .LVU483
 172:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1785               		.loc 2 172 2 view .LVU484
 173:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1786               		.loc 2 173 2 view .LVU485
 174:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 1787               		.loc 2 174 2 view .LVU486
 184:c:\msys64\home\kyleo\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 1788               		.loc 2 184 3 view .LVU487
 1789               		.loc 2 187 2 view .LVU488
 1790 044e 8FEF      		ldi r24,lo8(255999)
 1791 0450 97EE      		ldi r25,hi8(255999)
 1792 0452 E3E0      		ldi r30,hlo8(255999)
 1793 0454 8150      	1:	subi r24,1
 1794 0456 9040      		sbci r25,0
 1795 0458 E040      		sbci r30,0
 1796 045a 01F4      		brne 1b
 1797 045c 00C0      		rjmp .L171
 1798               	.LVL172:
 1799               	.L128:
 1800               		.loc 2 187 2 is_stmt 0 view .LVU489
 1801               	.LBE51:
 1802               	.LBE54:
 557:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1803               		.loc 1 557 79 is_stmt 1 view .LVU490
 558:tmk_core/common/action.c ****                         }
 1804               		.loc 1 558 29 view .LVU491
 1805 045e 8C2F      		mov r24,r28
 1806 0460 8F71      		andi r24,lo8(31)
 1807 0462 00C0      		rjmp .L163
 1808               	.L57:
 569:tmk_core/common/action.c ****             break;
 1809               		.loc 1 569 13 view .LVU492
 569:tmk_core/common/action.c ****             break;
 1810               		.loc 1 569 83 is_stmt 0 view .LVU493
 1811 0464 4C2F      		mov r20,r28
 1812 0466 4F70      		andi r20,lo8(15)
 569:tmk_core/common/action.c ****             break;
 1813               		.loc 1 569 13 view .LVU494
 1814 0468 6D2F      		mov r22,r29
 1815 046a C601      		movw r24,r12
 1816 046c 0E94 0000 		call action_get_macro
 1817               	.LVL173:
 1818 0470 0E94 0000 		call action_macro_play
 1819               	.LVL174:
 570:tmk_core/common/action.c **** #endif
 1820               		.loc 1 570 13 is_stmt 1 view .LVU495
 1821 0474 00C0      		rjmp .L54
 1822               	.L55:
 637:tmk_core/common/action.c ****             break;
 1823               		.loc 1 637 13 view .LVU496
 637:tmk_core/common/action.c ****             break;
 1824               		.loc 1 637 64 is_stmt 0 view .LVU497
 1825 0476 4C2F      		mov r20,r28
 1826 0478 4F70      		andi r20,lo8(15)
 637:tmk_core/common/action.c ****             break;
 1827               		.loc 1 637 13 view .LVU498
 1828 047a 6D2F      		mov r22,r29
 1829 047c C601      		movw r24,r12
 1830 047e 0E94 0000 		call action_function
 1831               	.LVL175:
 638:tmk_core/common/action.c **** #endif
 1832               		.loc 1 638 13 is_stmt 1 view .LVU499
 1833 0482 00C0      		rjmp .L54
 1834               	.LVL176:
 1835               	.L51:
 1836               	/* epilogue start */
 695:tmk_core/common/action.c **** 
 1837               		.loc 1 695 1 is_stmt 0 view .LVU500
 1838 0484 DF91      		pop r29
 1839               	.LVL177:
 695:tmk_core/common/action.c **** 
 1840               		.loc 1 695 1 view .LVU501
 1841 0486 CF91      		pop r28
 695:tmk_core/common/action.c **** 
 1842               		.loc 1 695 1 view .LVU502
 1843 0488 1F91      		pop r17
 1844 048a 0F91      		pop r16
 1845 048c FF90      		pop r15
 1846 048e EF90      		pop r14
 1847               	.LVL178:
 695:tmk_core/common/action.c **** 
 1848               		.loc 1 695 1 view .LVU503
 1849 0490 DF90      		pop r13
 1850 0492 CF90      		pop r12
 1851               	.LVL179:
 695:tmk_core/common/action.c **** 
 1852               		.loc 1 695 1 view .LVU504
 1853 0494 BF90      		pop r11
 1854 0496 0895      		ret
 1855               		.cfi_endproc
 1856               	.LFE115:
 1858               		.section	.text.process_record_handler,"ax",@progbits
 1859               	.global	process_record_handler
 1861               	process_record_handler:
 1862               	.LVL180:
 1863               	.LFB114:
 194:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1864               		.loc 1 194 50 is_stmt 1 view -0
 1865               		.cfi_startproc
 194:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1866               		.loc 1 194 50 is_stmt 0 view .LVU506
 1867 0000 0F93      		push r16
 1868               	.LCFI15:
 1869               		.cfi_def_cfa_offset 3
 1870               		.cfi_offset 16, -2
 1871 0002 1F93      		push r17
 1872               	.LCFI16:
 1873               		.cfi_def_cfa_offset 4
 1874               		.cfi_offset 17, -3
 1875 0004 CF93      		push r28
 1876               	.LCFI17:
 1877               		.cfi_def_cfa_offset 5
 1878               		.cfi_offset 28, -4
 1879 0006 DF93      		push r29
 1880               	.LCFI18:
 1881               		.cfi_def_cfa_offset 6
 1882               		.cfi_offset 29, -5
 1883               	/* prologue: function */
 1884               	/* frame size = 0 */
 1885               	/* stack size = 4 */
 1886               	.L__stack_usage = 4
 1887 0008 EC01      		movw r28,r24
 195:tmk_core/common/action.c ****     dprint("ACTION: ");
 1888               		.loc 1 195 5 is_stmt 1 view .LVU507
 195:tmk_core/common/action.c ****     dprint("ACTION: ");
 1889               		.loc 1 195 23 is_stmt 0 view .LVU508
 1890 000a 6881      		ld r22,Y
 1891 000c 7981      		ldd r23,Y+1
 1892 000e 8A81      		ldd r24,Y+2
 1893               	.LVL181:
 195:tmk_core/common/action.c ****     dprint("ACTION: ");
 1894               		.loc 1 195 23 view .LVU509
 1895 0010 0E94 0000 		call store_or_get_action
 1896               	.LVL182:
 1897 0014 8C01      		movw r16,r24
 1898               	.LVL183:
 196:tmk_core/common/action.c ****     debug_action(action);
 1899               		.loc 1 196 23 is_stmt 1 view .LVU510
 197:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1900               		.loc 1 197 5 view .LVU511
 199:tmk_core/common/action.c ****     layer_debug();
 1901               		.loc 1 199 29 view .LVU512
 200:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1902               		.loc 1 200 5 view .LVU513
 1903 0016 0E94 0000 		call layer_debug
 1904               	.LVL184:
 201:tmk_core/common/action.c ****     default_layer_debug();
 1905               		.loc 1 201 37 view .LVU514
 202:tmk_core/common/action.c **** #endif
 1906               		.loc 1 202 5 view .LVU515
 1907 001a 0E94 0000 		call default_layer_debug
 1908               	.LVL185:
 204:tmk_core/common/action.c **** 
 1909               		.loc 1 204 15 view .LVU516
 206:tmk_core/common/action.c **** }
 1910               		.loc 1 206 5 view .LVU517
 206:tmk_core/common/action.c **** }
 1911               		.loc 1 206 5 is_stmt 0 view .LVU518
 1912 001e B801      		movw r22,r16
 1913 0020 CE01      		movw r24,r28
 1914               	/* epilogue start */
 207:tmk_core/common/action.c **** 
 1915               		.loc 1 207 1 view .LVU519
 1916 0022 DF91      		pop r29
 1917 0024 CF91      		pop r28
 1918               	.LVL186:
 207:tmk_core/common/action.c **** 
 1919               		.loc 1 207 1 view .LVU520
 1920 0026 1F91      		pop r17
 1921 0028 0F91      		pop r16
 1922               	.LVL187:
 206:tmk_core/common/action.c **** }
 1923               		.loc 1 206 5 view .LVU521
 1924 002a 0C94 0000 		jmp process_action
 1925               	.LVL188:
 206:tmk_core/common/action.c **** }
 1926               		.loc 1 206 5 view .LVU522
 1927               		.cfi_endproc
 1928               	.LFE114:
 1930               		.section	.text.process_record,"ax",@progbits
 1931               	.global	process_record
 1933               	process_record:
 1934               	.LVL189:
 1935               	.LFB113:
 183:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1936               		.loc 1 183 42 is_stmt 1 view -0
 1937               		.cfi_startproc
 183:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1938               		.loc 1 183 42 is_stmt 0 view .LVU524
 1939 0000 CF93      		push r28
 1940               	.LCFI19:
 1941               		.cfi_def_cfa_offset 3
 1942               		.cfi_offset 28, -2
 1943 0002 DF93      		push r29
 1944               	.LCFI20:
 1945               		.cfi_def_cfa_offset 4
 1946               		.cfi_offset 29, -3
 1947               	/* prologue: function */
 1948               	/* frame size = 0 */
 1949               	/* stack size = 2 */
 1950               	.L__stack_usage = 2
 1951 0004 EC01      		movw r28,r24
 184:tmk_core/common/action.c ****         return;
 1952               		.loc 1 184 5 is_stmt 1 view .LVU525
 1953               	.LBB57:
 1954               	.LBI57:
 1955               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1956               		.loc 4 48 20 view .LVU526
 1957               	.LBB58:
 1958               		.loc 4 48 51 view .LVU527
 1959               		.loc 4 48 74 is_stmt 0 view .LVU528
 1960 0006 8B81      		ldd r24,Y+3
 1961 0008 9C81      		ldd r25,Y+4
 1962               	.LVL190:
 1963               		.loc 4 48 74 view .LVU529
 1964 000a 892B      		or r24,r25
 1965 000c 01F0      		breq .L173
 1966 000e 8881      		ld r24,Y
 1967 0010 9981      		ldd r25,Y+1
 1968 0012 8923      		and r24,r25
 1969 0014 8F3F      		cpi r24,lo8(-1)
 1970 0016 01F4      		brne .L182
 1971               	.L173:
 1972               	/* epilogue start */
 1973               	.LBE58:
 1974               	.LBE57:
 192:tmk_core/common/action.c **** 
 1975               		.loc 1 192 1 view .LVU530
 1976 0018 DF91      		pop r29
 1977 001a CF91      		pop r28
 1978               	.LVL191:
 192:tmk_core/common/action.c **** 
 1979               		.loc 1 192 1 view .LVU531
 1980 001c 0895      		ret
 1981               	.LVL192:
 1982               	.L182:
 188:tmk_core/common/action.c **** 
 1983               		.loc 1 188 5 is_stmt 1 view .LVU532
 188:tmk_core/common/action.c **** 
 1984               		.loc 1 188 10 is_stmt 0 view .LVU533
 1985 001e CE01      		movw r24,r28
 1986 0020 0E94 0000 		call process_record_quantum
 1987               	.LVL193:
 188:tmk_core/common/action.c **** 
 1988               		.loc 1 188 8 view .LVU534
 1989 0024 8823      		tst r24
 1990 0026 01F0      		breq .L173
 190:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1991               		.loc 1 190 5 is_stmt 1 view .LVU535
 1992 0028 CE01      		movw r24,r28
 1993 002a 0E94 0000 		call process_record_handler
 1994               	.LVL194:
 191:tmk_core/common/action.c **** }
 1995               		.loc 1 191 5 view .LVU536
 1996 002e CE01      		movw r24,r28
 1997               	/* epilogue start */
 192:tmk_core/common/action.c **** 
 1998               		.loc 1 192 1 is_stmt 0 view .LVU537
 1999 0030 DF91      		pop r29
 2000 0032 CF91      		pop r28
 2001               	.LVL195:
 191:tmk_core/common/action.c **** }
 2002               		.loc 1 191 5 view .LVU538
 2003 0034 0C94 0000 		jmp post_process_record_quantum
 2004               	.LVL196:
 191:tmk_core/common/action.c **** }
 2005               		.loc 1 191 5 view .LVU539
 2006               		.cfi_endproc
 2007               	.LFE113:
 2009               		.section	.text.process_record_nocache,"ax",@progbits
 2010               	.global	process_record_nocache
 2012               	process_record_nocache:
 2013               	.LVL197:
 2014               	.LFB109:
 143:tmk_core/common/action.c ****     disable_action_cache = true;
 2015               		.loc 1 143 50 is_stmt 1 view -0
 2016               		.cfi_startproc
 2017               	/* prologue: function */
 2018               	/* frame size = 0 */
 2019               	/* stack size = 0 */
 2020               	.L__stack_usage = 0
 144:tmk_core/common/action.c ****     process_record(record);
 2021               		.loc 1 144 5 view .LVU541
 144:tmk_core/common/action.c ****     process_record(record);
 2022               		.loc 1 144 26 is_stmt 0 view .LVU542
 2023 0000 21E0      		ldi r18,lo8(1)
 2024 0002 2093 0000 		sts disable_action_cache,r18
 145:tmk_core/common/action.c ****     disable_action_cache = false;
 2025               		.loc 1 145 5 is_stmt 1 view .LVU543
 2026 0006 0E94 0000 		call process_record
 2027               	.LVL198:
 146:tmk_core/common/action.c **** }
 2028               		.loc 1 146 5 view .LVU544
 146:tmk_core/common/action.c **** }
 2029               		.loc 1 146 26 is_stmt 0 view .LVU545
 2030 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2031               	/* epilogue start */
 147:tmk_core/common/action.c **** #else
 2032               		.loc 1 147 1 view .LVU546
 2033 000e 0895      		ret
 2034               		.cfi_endproc
 2035               	.LFE109:
 2037               		.section	.text.register_weak_mods,"ax",@progbits
 2038               	.global	register_weak_mods
 2040               	register_weak_mods:
 2041               	.LVL199:
 2042               	.LFB121:
 892:tmk_core/common/action.c **** 
 893:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 894:tmk_core/common/action.c ****  *
 895:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 896:tmk_core/common/action.c ****  */
 897:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 2043               		.loc 1 897 39 is_stmt 1 view -0
 2044               		.cfi_startproc
 2045               	/* prologue: function */
 2046               	/* frame size = 0 */
 2047               	/* stack size = 0 */
 2048               	.L__stack_usage = 0
 898:tmk_core/common/action.c ****     if (mods) {
 2049               		.loc 1 898 5 view .LVU548
 2050               		.loc 1 898 8 is_stmt 0 view .LVU549
 2051 0000 8823      		tst r24
 2052 0002 01F0      		breq .L184
 899:tmk_core/common/action.c ****         add_weak_mods(mods);
 2053               		.loc 1 899 9 is_stmt 1 view .LVU550
 2054 0004 0E94 0000 		call add_weak_mods
 2055               	.LVL200:
 900:tmk_core/common/action.c ****         send_keyboard_report();
 2056               		.loc 1 900 9 view .LVU551
 2057 0008 0C94 0000 		jmp send_keyboard_report
 2058               	.LVL201:
 2059               	.L184:
 2060               	/* epilogue start */
 901:tmk_core/common/action.c ****     }
 902:tmk_core/common/action.c **** }
 2061               		.loc 1 902 1 is_stmt 0 view .LVU552
 2062 000c 0895      		ret
 2063               		.cfi_endproc
 2064               	.LFE121:
 2066               		.section	.text.unregister_weak_mods,"ax",@progbits
 2067               	.global	unregister_weak_mods
 2069               	unregister_weak_mods:
 2070               	.LVL202:
 2071               	.LFB122:
 903:tmk_core/common/action.c **** 
 904:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 905:tmk_core/common/action.c ****  *
 906:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 907:tmk_core/common/action.c ****  */
 908:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 2072               		.loc 1 908 41 is_stmt 1 view -0
 2073               		.cfi_startproc
 2074               	/* prologue: function */
 2075               	/* frame size = 0 */
 2076               	/* stack size = 0 */
 2077               	.L__stack_usage = 0
 909:tmk_core/common/action.c ****     if (mods) {
 2078               		.loc 1 909 5 view .LVU554
 2079               		.loc 1 909 8 is_stmt 0 view .LVU555
 2080 0000 8823      		tst r24
 2081 0002 01F0      		breq .L186
 910:tmk_core/common/action.c ****         del_weak_mods(mods);
 2082               		.loc 1 910 9 is_stmt 1 view .LVU556
 2083 0004 0E94 0000 		call del_weak_mods
 2084               	.LVL203:
 911:tmk_core/common/action.c ****         send_keyboard_report();
 2085               		.loc 1 911 9 view .LVU557
 2086 0008 0C94 0000 		jmp send_keyboard_report
 2087               	.LVL204:
 2088               	.L186:
 2089               	/* epilogue start */
 912:tmk_core/common/action.c ****     }
 913:tmk_core/common/action.c **** }
 2090               		.loc 1 913 1 is_stmt 0 view .LVU558
 2091 000c 0895      		ret
 2092               		.cfi_endproc
 2093               	.LFE122:
 2095               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2096               	.global	clear_keyboard_but_mods_and_keys
 2098               	clear_keyboard_but_mods_and_keys:
 2099               	.LFB125:
 914:tmk_core/common/action.c **** 
 915:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 916:tmk_core/common/action.c ****  *
 917:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 918:tmk_core/common/action.c ****  */
 919:tmk_core/common/action.c **** void clear_keyboard(void) {
 920:tmk_core/common/action.c ****     clear_mods();
 921:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 922:tmk_core/common/action.c **** }
 923:tmk_core/common/action.c **** 
 924:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 925:tmk_core/common/action.c ****  *
 926:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 927:tmk_core/common/action.c ****  */
 928:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 929:tmk_core/common/action.c ****     clear_keys();
 930:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 931:tmk_core/common/action.c **** }
 932:tmk_core/common/action.c **** 
 933:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 934:tmk_core/common/action.c ****  *
 935:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 936:tmk_core/common/action.c ****  */
 937:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 2100               		.loc 1 937 41 is_stmt 1 view -0
 2101               		.cfi_startproc
 2102               	/* prologue: function */
 2103               	/* frame size = 0 */
 2104               	/* stack size = 0 */
 2105               	.L__stack_usage = 0
 938:tmk_core/common/action.c ****     clear_weak_mods();
 2106               		.loc 1 938 5 view .LVU560
 2107 0000 0E94 0000 		call clear_weak_mods
 2108               	.LVL205:
 939:tmk_core/common/action.c ****     clear_macro_mods();
 2109               		.loc 1 939 5 view .LVU561
 2110 0004 0E94 0000 		call clear_macro_mods
 2111               	.LVL206:
 940:tmk_core/common/action.c ****     send_keyboard_report();
 2112               		.loc 1 940 5 view .LVU562
 2113 0008 0E94 0000 		call send_keyboard_report
 2114               	.LVL207:
 941:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 942:tmk_core/common/action.c ****     mousekey_clear();
 2115               		.loc 1 942 5 view .LVU563
 2116 000c 0E94 0000 		call mousekey_clear
 2117               	.LVL208:
 943:tmk_core/common/action.c ****     mousekey_send();
 2118               		.loc 1 943 5 view .LVU564
 2119 0010 0E94 0000 		call mousekey_send
 2120               	.LVL209:
 944:tmk_core/common/action.c **** #endif
 945:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 946:tmk_core/common/action.c ****     host_system_send(0);
 2121               		.loc 1 946 5 view .LVU565
 2122 0014 90E0      		ldi r25,0
 2123 0016 80E0      		ldi r24,0
 2124 0018 0E94 0000 		call host_system_send
 2125               	.LVL210:
 947:tmk_core/common/action.c ****     host_consumer_send(0);
 2126               		.loc 1 947 5 view .LVU566
 2127 001c 90E0      		ldi r25,0
 2128 001e 80E0      		ldi r24,0
 2129 0020 0C94 0000 		jmp host_consumer_send
 2130               	.LVL211:
 2131               		.cfi_endproc
 2132               	.LFE125:
 2134               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2135               	.global	clear_keyboard_but_mods
 2137               	clear_keyboard_but_mods:
 2138               	.LFB124:
 928:tmk_core/common/action.c ****     clear_keys();
 2139               		.loc 1 928 36 view -0
 2140               		.cfi_startproc
 2141               	/* prologue: function */
 2142               	/* frame size = 0 */
 2143               	/* stack size = 0 */
 2144               	.L__stack_usage = 0
 929:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2145               		.loc 1 929 5 view .LVU568
 2146 0000 0E94 0000 		call clear_keys
 2147               	.LVL212:
 930:tmk_core/common/action.c **** }
 2148               		.loc 1 930 5 view .LVU569
 2149 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2150               	.LVL213:
 2151               		.cfi_endproc
 2152               	.LFE124:
 2154               		.section	.text.clear_keyboard,"ax",@progbits
 2155               	.global	clear_keyboard
 2157               	clear_keyboard:
 2158               	.LFB123:
 919:tmk_core/common/action.c ****     clear_mods();
 2159               		.loc 1 919 27 view -0
 2160               		.cfi_startproc
 2161               	/* prologue: function */
 2162               	/* frame size = 0 */
 2163               	/* stack size = 0 */
 2164               	.L__stack_usage = 0
 920:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2165               		.loc 1 920 5 view .LVU571
 2166 0000 0E94 0000 		call clear_mods
 2167               	.LVL214:
 921:tmk_core/common/action.c **** }
 2168               		.loc 1 921 5 view .LVU572
 2169 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2170               	.LVL215:
 2171               		.cfi_endproc
 2172               	.LFE123:
 2174               		.section	.text.is_tap_action,"ax",@progbits
 2175               	.global	is_tap_action
 2177               	is_tap_action:
 2178               	.LVL216:
 2179               	.LFB127:
 948:tmk_core/common/action.c **** #endif
 949:tmk_core/common/action.c **** }
 950:tmk_core/common/action.c **** 
 951:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 952:tmk_core/common/action.c ****  *
 953:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 954:tmk_core/common/action.c ****  */
 955:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 956:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 957:tmk_core/common/action.c ****     return is_tap_action(action);
 958:tmk_core/common/action.c **** }
 959:tmk_core/common/action.c **** 
 960:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 961:tmk_core/common/action.c ****  *
 962:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 963:tmk_core/common/action.c ****  */
 964:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 2180               		.loc 1 964 37 view -0
 2181               		.cfi_startproc
 2182               	/* prologue: function */
 2183               	/* frame size = 0 */
 2184               	/* stack size = 0 */
 2185               	.L__stack_usage = 0
 965:tmk_core/common/action.c ****     switch (action.kind.id) {
 2186               		.loc 1 965 5 view .LVU574
 2187               		.loc 1 965 24 is_stmt 0 view .LVU575
 2188 0000 E92F      		mov r30,r25
 2189 0002 E295      		swap r30
 2190 0004 EF70      		andi r30,lo8(15)
 2191               		.loc 1 965 5 view .LVU576
 2192 0006 E250      		subi r30,lo8(-(-2))
 2193 0008 EE30      		cpi r30,lo8(14)
 2194 000a 00F4      		brsh .L200
 2195 000c F0E0      		ldi r31,0
 2196 000e E050      		subi r30,lo8(-(gs(.L194)))
 2197 0010 F040      		sbci r31,hi8(-(gs(.L194)))
 2198 0012 0C94 0000 		jmp __tablejump2__
 2199               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2200               		.p2align	1
 2201               	.L194:
 2202 0000 0000      		.word gs(.L195)
 2203 0002 0000      		.word gs(.L195)
 2204 0004 0000      		.word gs(.L200)
 2205 0006 0000      		.word gs(.L200)
 2206 0008 0000      		.word gs(.L196)
 2207 000a 0000      		.word gs(.L200)
 2208 000c 0000      		.word gs(.L200)
 2209 000e 0000      		.word gs(.L200)
 2210 0010 0000      		.word gs(.L195)
 2211 0012 0000      		.word gs(.L195)
 2212 0014 0000      		.word gs(.L193)
 2213 0016 0000      		.word gs(.L200)
 2214 0018 0000      		.word gs(.L200)
 2215 001a 0000      		.word gs(.L193)
 2216               		.section	.text.is_tap_action
 2217               	.L195:
 966:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 967:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 968:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 969:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 970:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2218               		.loc 1 970 13 is_stmt 1 view .LVU577
 2219 0016 803F      		cpi r24,lo8(-16)
 2220 0018 01F0      		breq .L203
 2221 001a 00F4      		brsh .L197
 2222 001c 883E      		cpi r24,lo8(-24)
 2223 001e 00F4      		brsh .L200
 2224               	.L203:
 971:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 972:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 973:tmk_core/common/action.c ****                 case OP_ONESHOT:
 974:tmk_core/common/action.c ****                     return true;
 2225               		.loc 1 974 28 is_stmt 0 view .LVU578
 2226 0020 81E0      		ldi r24,lo8(1)
 2227               	.LVL217:
 2228               	/* epilogue start */
 975:tmk_core/common/action.c ****             }
 976:tmk_core/common/action.c ****             return false;
 977:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 978:tmk_core/common/action.c ****             switch (action.swap.code) {
 979:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 980:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 981:tmk_core/common/action.c ****                     return true;
 982:tmk_core/common/action.c ****             }
 983:tmk_core/common/action.c ****             return false;
 984:tmk_core/common/action.c ****         case ACT_MACRO:
 985:tmk_core/common/action.c ****         case ACT_FUNCTION:
 986:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
 987:tmk_core/common/action.c ****                 return true;
 988:tmk_core/common/action.c ****             }
 989:tmk_core/common/action.c ****             return false;
 990:tmk_core/common/action.c ****     }
 991:tmk_core/common/action.c ****     return false;
 992:tmk_core/common/action.c **** }
 2229               		.loc 1 992 1 view .LVU579
 2230 0022 0895      		ret
 2231               	.LVL218:
 2232               	.L197:
 2233               		.loc 1 992 1 view .LVU580
 2234 0024 843F      		cpi r24,lo8(-12)
 2235 0026 01F0      		breq .L203
 2236               	.L200:
 976:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2237               		.loc 1 976 20 view .LVU581
 2238 0028 80E0      		ldi r24,0
 2239               	.LVL219:
 976:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2240               		.loc 1 976 20 view .LVU582
 2241 002a 0895      		ret
 2242               	.LVL220:
 2243               	.L196:
 978:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2244               		.loc 1 978 13 is_stmt 1 view .LVU583
 2245 002c 883E      		cpi r24,lo8(-24)
 2246 002e 00F0      		brlo .L203
 2247 0030 813F      		cpi r24,lo8(-15)
 2248 0032 01F4      		brne .L200
 2249 0034 00C0      		rjmp .L203
 2250               	.L193:
 986:tmk_core/common/action.c ****                 return true;
 2251               		.loc 1 986 13 view .LVU584
 986:tmk_core/common/action.c ****                 return true;
 2252               		.loc 1 986 16 is_stmt 0 view .LVU585
 2253 0036 93FB      		bst r25,3
 2254 0038 8827      		clr r24
 2255 003a 80F9      		bld r24,0
 2256               	.LVL221:
 986:tmk_core/common/action.c ****                 return true;
 2257               		.loc 1 986 16 view .LVU586
 2258 003c 0895      		ret
 2259               		.cfi_endproc
 2260               	.LFE127:
 2262               		.section	.text.is_tap_key,"ax",@progbits
 2263               	.global	is_tap_key
 2265               	is_tap_key:
 2266               	.LVL222:
 2267               	.LFB126:
 955:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2268               		.loc 1 955 31 is_stmt 1 view -0
 2269               		.cfi_startproc
 2270               	/* prologue: function */
 2271               	/* frame size = 0 */
 2272               	/* stack size = 0 */
 2273               	.L__stack_usage = 0
 956:tmk_core/common/action.c ****     return is_tap_action(action);
 2274               		.loc 1 956 5 view .LVU588
 956:tmk_core/common/action.c ****     return is_tap_action(action);
 2275               		.loc 1 956 23 is_stmt 0 view .LVU589
 2276 0000 0E94 0000 		call layer_switch_get_action
 2277               	.LVL223:
 957:tmk_core/common/action.c **** }
 2278               		.loc 1 957 5 is_stmt 1 view .LVU590
 957:tmk_core/common/action.c **** }
 2279               		.loc 1 957 12 is_stmt 0 view .LVU591
 2280 0004 0C94 0000 		jmp is_tap_action
 2281               	.LVL224:
 2282               		.cfi_endproc
 2283               	.LFE126:
 2285               		.section	.text.debug_event,"ax",@progbits
 2286               	.global	debug_event
 2288               	debug_event:
 2289               	.LFB128:
 993:tmk_core/common/action.c **** 
 994:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 995:tmk_core/common/action.c ****  *
 996:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 997:tmk_core/common/action.c ****  */
 998:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2290               		.loc 1 998 36 is_stmt 1 view -0
 2291               		.cfi_startproc
 2292 0000 CF93      		push r28
 2293               	.LCFI21:
 2294               		.cfi_def_cfa_offset 3
 2295               		.cfi_offset 28, -2
 2296 0002 DF93      		push r29
 2297               	.LCFI22:
 2298               		.cfi_def_cfa_offset 4
 2299               		.cfi_offset 29, -3
 2300 0004 00D0      		rcall .
 2301 0006 00D0      		rcall .
 2302 0008 0F92      		push __tmp_reg__
 2303               	.LCFI23:
 2304               		.cfi_def_cfa_offset 9
 2305 000a CDB7      		in r28,__SP_L__
 2306 000c DEB7      		in r29,__SP_H__
 2307               	.LCFI24:
 2308               		.cfi_def_cfa_register 28
 2309               	/* prologue: function */
 2310               	/* frame size = 5 */
 2311               	/* stack size = 7 */
 2312               	.L__stack_usage = 7
 2313               		.loc 1 998 138 view .LVU593
 2314               	/* epilogue start */
 2315               		.loc 1 998 1 is_stmt 0 view .LVU594
 2316 000e 0F90      		pop __tmp_reg__
 2317 0010 0F90      		pop __tmp_reg__
 2318 0012 0F90      		pop __tmp_reg__
 2319 0014 0F90      		pop __tmp_reg__
 2320 0016 0F90      		pop __tmp_reg__
 2321 0018 DF91      		pop r29
 2322 001a CF91      		pop r28
 2323 001c 0895      		ret
 2324               		.cfi_endproc
 2325               	.LFE128:
 2327               		.section	.text.debug_record,"ax",@progbits
 2328               	.global	debug_record
 2330               	debug_record:
 2331               	.LFB129:
 999:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1000:tmk_core/common/action.c ****  *
1001:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1002:tmk_core/common/action.c ****  */
1003:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2332               		.loc 1 1003 39 is_stmt 1 view -0
 2333               		.cfi_startproc
 2334 0000 CF93      		push r28
 2335               	.LCFI25:
 2336               		.cfi_def_cfa_offset 3
 2337               		.cfi_offset 28, -2
 2338 0002 DF93      		push r29
 2339               	.LCFI26:
 2340               		.cfi_def_cfa_offset 4
 2341               		.cfi_offset 29, -3
 2342 0004 00D0      		rcall .
 2343 0006 00D0      		rcall .
 2344 0008 00D0      		rcall .
 2345               	.LCFI27:
 2346               		.cfi_def_cfa_offset 10
 2347 000a CDB7      		in r28,__SP_L__
 2348 000c DEB7      		in r29,__SP_H__
 2349               	.LCFI28:
 2350               		.cfi_def_cfa_register 28
 2351               	/* prologue: function */
 2352               	/* frame size = 6 */
 2353               	/* stack size = 8 */
 2354               	.L__stack_usage = 8
1004:tmk_core/common/action.c ****     debug_event(record.event);
 2355               		.loc 1 1004 5 view .LVU596
1005:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1006:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2356               		.loc 1 1006 77 view .LVU597
 2357               	/* epilogue start */
1007:tmk_core/common/action.c **** #endif
1008:tmk_core/common/action.c **** }
 2358               		.loc 1 1008 1 is_stmt 0 view .LVU598
 2359 000e 2696      		adiw r28,6
 2360 0010 0FB6      		in __tmp_reg__,__SREG__
 2361 0012 F894      		cli
 2362 0014 DEBF      		out __SP_H__,r29
 2363 0016 0FBE      		out __SREG__,__tmp_reg__
 2364 0018 CDBF      		out __SP_L__,r28
 2365 001a DF91      		pop r29
 2366 001c CF91      		pop r28
 2367 001e 0895      		ret
 2368               		.cfi_endproc
 2369               	.LFE129:
 2371               		.section	.text.debug_action,"ax",@progbits
 2372               	.global	debug_action
 2374               	debug_action:
 2375               	.LVL225:
 2376               	.LFB130:
1009:tmk_core/common/action.c **** 
1010:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1011:tmk_core/common/action.c ****  *
1012:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1013:tmk_core/common/action.c ****  */
1014:tmk_core/common/action.c **** void debug_action(action_t action) {
 2377               		.loc 1 1014 36 is_stmt 1 view -0
 2378               		.cfi_startproc
 2379               	/* prologue: function */
 2380               	/* frame size = 0 */
 2381               	/* stack size = 0 */
 2382               	.L__stack_usage = 0
1015:tmk_core/common/action.c ****     switch (action.kind.id) {
 2383               		.loc 1 1015 5 view .LVU600
1016:tmk_core/common/action.c ****         case ACT_LMODS:
1017:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1018:tmk_core/common/action.c ****             break;
1019:tmk_core/common/action.c ****         case ACT_RMODS:
1020:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1021:tmk_core/common/action.c ****             break;
1022:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1023:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1024:tmk_core/common/action.c ****             break;
1025:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1026:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1027:tmk_core/common/action.c ****             break;
1028:tmk_core/common/action.c ****         case ACT_USAGE:
1029:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1030:tmk_core/common/action.c ****             break;
1031:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1032:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1033:tmk_core/common/action.c ****             break;
1034:tmk_core/common/action.c ****         case ACT_LAYER:
1035:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1036:tmk_core/common/action.c ****             break;
1037:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1038:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1039:tmk_core/common/action.c ****             break;
1040:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1041:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1042:tmk_core/common/action.c ****             break;
1043:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1044:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1045:tmk_core/common/action.c ****             break;
1046:tmk_core/common/action.c ****         case ACT_MACRO:
1047:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1048:tmk_core/common/action.c ****             break;
1049:tmk_core/common/action.c ****         case ACT_FUNCTION:
1050:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1051:tmk_core/common/action.c ****             break;
1052:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1053:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1054:tmk_core/common/action.c ****             break;
1055:tmk_core/common/action.c ****         default:
1056:tmk_core/common/action.c ****             dprint("UNKNOWN");
1057:tmk_core/common/action.c ****             break;
1058:tmk_core/common/action.c ****     }
1059:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2384               		.loc 1 1059 75 view .LVU601
 2385               	/* epilogue start */
1060:tmk_core/common/action.c **** }
 2386               		.loc 1 1060 1 is_stmt 0 view .LVU602
 2387 0000 0895      		ret
 2388               		.cfi_endproc
 2389               	.LFE130:
 2391               		.section	.rodata.CSWTCH.17,"a"
 2394               	CSWTCH.17:
 2395 0000 E200      		.word	226
 2396 0002 E900      		.word	233
 2397 0004 EA00      		.word	234
 2398 0006 B500      		.word	181
 2399 0008 B600      		.word	182
 2400 000a B700      		.word	183
 2401 000c CD00      		.word	205
 2402 000e 8301      		.word	387
 2403 0010 CC00      		.word	204
 2404 0012 8A01      		.word	394
 2405 0014 9201      		.word	402
 2406 0016 9401      		.word	404
 2407 0018 2102      		.word	545
 2408 001a 2302      		.word	547
 2409 001c 2402      		.word	548
 2410 001e 2502      		.word	549
 2411 0020 2602      		.word	550
 2412 0022 2702      		.word	551
 2413 0024 2A02      		.word	554
 2414 0026 B300      		.word	179
 2415 0028 B400      		.word	180
 2416 002a 6F00      		.word	111
 2417 002c 7000      		.word	112
 2418               		.section	.rodata.CSWTCH.16,"a"
 2421               	CSWTCH.16:
 2422 0000 81        		.byte	-127
 2423 0001 82        		.byte	-126
 2424 0002 83        		.byte	-125
 2425               	.global	disable_action_cache
 2426               		.section	.bss.disable_action_cache,"aw",@nobits
 2429               	disable_action_cache:
 2430 0000 00        		.zero	1
 2431               		.comm	tp_buttons,2,1
 2432               		.text
 2433               	.Letext0:
 2434               		.file 5 "c:\\msys64\\home\\kyleo\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\stdint.h"
 2435               		.file 6 "tmk_core/common/keycode.h"
 2436               		.file 7 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 2437               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 2438               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2439               		.file 10 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 2440               		.file 11 "c:\\msys64\\home\\kyleo\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\stdio.h"
 2441               		.file 12 "tmk_core/common/host.h"
 2442               		.file 13 "tmk_core/common/mousekey.h"
 2443               		.file 14 "tmk_core/common/command.h"
 2444               		.file 15 "tmk_core/common/action_code.h"
 2445               		.file 16 "tmk_core/common/action.h"
 2446               		.file 17 "tmk_core/common/action_layer.h"
 2447               		.file 18 "tmk_core/common/action_util.h"
 2448               		.file 19 "tmk_core/common/avr/xprintf.h"
 2449               		.file 20 "tmk_core/common/debug.h"
 2450               		.file 21 "tmk_core/common/led.h"
 2451               		.file 22 "tmk_core/common/action_macro.h"
 2452               		.file 23 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:00000000 action.c
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2      *ABS*:0000003e __SP_H__
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:3      *ABS*:0000003d __SP_L__
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:4      *ABS*:0000003f __SREG__
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:6      *ABS*:00000001 __zero_reg__
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:13     .text.action_exec:00000000 action_exec
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:94     .text.process_record_quantum:00000000 process_record_quantum
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:116    .text.post_process_record_quantum:00000000 post_process_record_quantum
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:135    .text.process_record_tap_hint:00000000 process_record_tap_hint
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:160    .text.register_code:00000000 register_code
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2421   .rodata.CSWTCH.16:00000000 CSWTCH.16
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2394   .rodata.CSWTCH.17:00000000 CSWTCH.17
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:476    .text.unregister_code:00000000 unregister_code
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:644    .text.tap_code:00000000 tap_code
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:708    .text.register_mods:00000000 register_mods
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:737    .text.unregister_mods:00000000 unregister_mods
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:766    .text.process_action:00000000 process_action
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:1933   .text.process_record:00000000 process_record
                            *COM*:00000002 tp_buttons
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:1861   .text.process_record_handler:00000000 process_record_handler
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2012   .text.process_record_nocache:00000000 process_record_nocache
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2429   .bss.disable_action_cache:00000000 disable_action_cache
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2040   .text.register_weak_mods:00000000 register_weak_mods
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2069   .text.unregister_weak_mods:00000000 unregister_weak_mods
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2098   .text.clear_keyboard_but_mods_and_keys:00000000 clear_keyboard_but_mods_and_keys
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2137   .text.clear_keyboard_but_mods:00000000 clear_keyboard_but_mods
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2157   .text.clear_keyboard:00000000 clear_keyboard
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2177   .text.is_tap_action:00000000 is_tap_action
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2265   .text.is_tap_key:00000000 is_tap_key
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2288   .text.debug_event:00000000 debug_event
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2330   .text.debug_record:00000000 debug_record
C:\Users\kyleo\AppData\Local\Temp\ccpGdaDg.s:2374   .text.debug_action:00000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
keyboard_report
is_key_pressed
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
